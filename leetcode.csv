Title;Front;Back
0556 Next Greater Element III;"https://leetcode.com/problems/next-greater-element-iii/description/

* algorithms
* Medium (29.75%)
* Total Accepted:    23.5K
* Total Submissions: 78.9K
* Testcase Example:  '12'

Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.

Example 1:


Input: 12
Output: 21


 

Example 2:


Input: 21
Output: -1


 






";"
```cpp
class Solution {
public:
    int nextGreaterElement(int n) {
        vector<int> digits;
        while (n > 0) { digits.push_back(n % 10); n = n / 10; }
        
        int i, j, L = digits.size();
        for (j = 1; j < L; ++j) if (digits[j-1] > digits[j]) break; 
        if  (j == L) return -1;
        for (i = 0; i < j; ++i) if (digits[i] > digits[j]) break;
        
        swap(digits[i], digits[j]);
        reverse(digits.begin(), digits.begin() + j);
        
        long long nn = 0;
        for (int i = L-1; i >= 0; --i) nn = nn * 10 + digits[i];
            
        return nn > INT_MAX ? -1 : int(nn);
    }
};
```

"
0554 Brick Wall;"https://leetcode.com/problems/brick-wall/description/

* algorithms
* Medium (47.38%)
* Total Accepted:    35.1K
* Total Submissions: 74.1K
* Testcase Example:  '[[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]'

There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks.

The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.

If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.

You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. 

 

Example:


Input: [[1,2,2,1],
        [3,1,2],
        [1,3,2],
        [2,4],
        [3,1,2],
        [1,3,1,1]]

Output: 2

Explanation: 



 

Note:


	The width sum of bricks in different rows are the same and won't exceed INT_MAX.
	The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.








";"
```cpp
class Solution {
public:
    int leastBricks(vector<vector<int>>& wall) {
        int L = wall.size(), result = 0; map<int, int> tbl;
        
        for (int i = 0; i < L; ++i) {
            int space = 0, len = wall[i].size();
            for (int j = 0; j <= len-2; ++j) {
                space += wall[i][j];
                if (tbl.find(space) == tbl.end())  tbl[space] = 1;
                else tbl[space]++;
                result = max(result, tbl[space]);
            }
        }
        
        return L - result;
    }
};
```


"
0552 Student Attendance Record II;"https://leetcode.com/problems/student-attendance-record-ii/description/

* algorithms
* Hard (32.40%)
* Total Accepted:    11.4K
* Total Submissions: 35.2K
* Testcase Example:  '1'

Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7.

A student attendance record is a string that only contains the following three characters:



'A' : Absent. 
'L' : Late.
 'P' : Present. 




A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).

Example 1:

Input: n = 2
Output: 8 
Explanation:
There are 8 records with length 2 will be regarded as rewardable:
""PP"" , ""AP"", ""PA"", ""LP"", ""PL"", ""AL"", ""LA"", ""LL""
Only ""AA"" won't be regarded as rewardable owing to more than one absent times. 



Note:
The value of n won't exceed 100,000.










";"
```cpp
class Solution {
public:
    int checkRecord(int n) {
        long a0l0 = 1, a0l1 = 1, a0l2 = 0;
        long a1l0 = 1, a1l1 = 0, a1l2 = 0;
        long long tmp = 0, M = 1000000007;
        for (int i=1; i<n; i++) {
            tmp = (a0l0 + a0l1 + a0l2) % M;
            a0l2 = a0l1;
            a0l1 = a0l0;
            a0l0 = tmp;
            tmp = (a1l0 + a1l1 + a1l2 + tmp) % M;
            a1l2 = a1l1;
            a1l1 = a1l0;
            a1l0 = tmp;
        }
        return (a0l0 + a0l1 + a0l2 + a1l0 + a1l1 + a1l2) % M;
    }
};
```


"
0324 Wiggle Sort II;"https://leetcode.com/problems/wiggle-sort-ii/description/

* algorithms
* Medium (27.51%)
* Total Accepted:    54.4K
* Total Submissions: 197.9K
* Testcase Example:  '[1,5,1,1,6,4]'

Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....

Example 1:


Input: nums = [1, 5, 1, 1, 6, 4]
Output: One possible answer is [1, 4, 1, 5, 1, 6].

Example 2:


Input: nums = [1, 3, 2, 2, 3, 1]
Output: One possible answer is [2, 3, 1, 3, 1, 2].

Note:
You may assume all input has valid answer.

Follow Up:
Can you do it in O(n) time and/or in-place with O(1) extra space?





";"
```cpp
class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        int len = nums.size();
        auto p  = nums.begin() + len/2;
        nth_element(nums.begin(), p, nums.end());
        #define NUMS(i) nums[(2*i+1)%(len|1)]
        int m = *p, i = 0, l = 0, h = len-1;
        while (i <= h) {
            if      (NUMS(i) > m) swap(NUMS(i++), NUMS(l++));
            else if (NUMS(i) < m) swap(NUMS(i)  , NUMS(h--));
            else                  i++;
        }
        #undef NUMS
    }
};
```


"
0321 Create Maximum Number;"https://leetcode.com/problems/create-maximum-number/description/

* algorithms
* Hard (25.16%)
* Total Accepted:    28.9K
* Total Submissions: 114.7K
* Testcase Example:  '[3,4,6,5]\n[9,1,2,5,8,3]\n5'

Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits.

Note: You should try to optimize your time and space complexity.

Example 1:


Input:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
Output:
[9, 8, 6, 5, 3]

Example 2:


Input:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
Output:
[6, 7, 6, 0, 4]

Example 3:


Input:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
Output:
[9, 8, 9]






";"
```cpp
class Solution {
public:
    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        vector<int> result;
        for (int i=0; i<=k; i++) {
            if (i  >nums1.size()) break;
            if (k-i>nums2.size()) continue;
            vector<int> s1 = maxSubarray(nums1, i), s2 = maxSubarray(nums2, k-i);
            vector<int> s  = mergeArray(s1, s2);
            if (greaterThen(s, 0, result, 0)) result.swap(s);
        }
        return result;
    }
    
    vector<int> maxSubarray(vector<int>& nums, int k) {
        vector<int> result; int len=nums.size();
        for (int i=0; i<len; ++i) {
            while (!result.empty()&&len-i>k-result.size()&&result.back()<nums[i]) result.pop_back();
            if (result.size()<k) result.push_back(nums[i]);
        }
        return move(result);
    }
    
    vector<int> mergeArray(vector<int>& nums1, vector<int>& nums2) {
        vector<int> result;
        int i1=0, i2=0;
        while (i1<nums1.size() && i2<nums2.size()) {
            if   (greaterThen(nums1, i1, nums2, i2)) result.push_back(nums1[i1++]);
            else                                     result.push_back(nums2[i2++]);
        }
        while (i1<nums1.size()) result.push_back(nums1[i1++]);
        while (i2<nums2.size()) result.push_back(nums2[i2++]);
        return move(result);
    }
    
    bool greaterThen(vector<int>& nums1, int i1, vector<int>& nums2, int i2) {
        int n = min(nums1.size()-i1, nums2.size()-i2);
        for (int i=0; i<n; i++) if (nums1[i1+i]!=nums2[i2+i]) return nums1[i1+i]>nums2[i2+i];
        return nums1.size()-i1 > nums2.size()-i2;
    }
};
```


"
0307 Range Sum Query - Mutable;"https://leetcode.com/problems/range-sum-query-mutable/description/

* algorithms
* Medium (27.55%)
* Total Accepted:    66.1K
* Total Submissions: 239.9K
* Testcase Example:  '[""NumArray"",""sumRange"",""update"",""sumRange""]\n[[[1,3,5]],[0,2],[1,2],[0,2]]'

Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

The update(i, val) function modifies nums by updating the element at index i to val.

Example:


Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8


Note:


	The array is only modifiable by the update function.
	You may assume the number of calls to update and sumRange function is distributed evenly.







";"
```cpp
class NumArray {
public:
    NumArray(vector<int> &nums) {
        this->nums = nums; tree = nums; tree.insert(tree.begin(), 0);
        for (int i=tree.size()-1; i>=0; --i) for (int j=i-(i&-i)+1; j<i; j++) {
            tree[i] += tree[j];
        }
    }

    void update(int i, int val) {
        int delta = val - nums[i]; nums[i] = val; i++;
        while (i < tree.size()) tree[i] += delta, i += i&-i;
    }

    int sumRange(int i, int j) {
        // result = tree[1,j+1] - tree[1,i+1] + nums[i]; 
        int result = nums[i]; j++; i++;
        while (j >= 1) result += tree[j], j -= j&-j;
        while (i >= 1) result -= tree[i], i -= i&-i;
        return result;
    }

private:
    vector<int> nums;
    vector<int> tree;
};


// Your NumArray object will be instantiated and called as such:
// NumArray numArray(nums);
// numArray.sumRange(0, 1);
// numArray.update(1, 10);
// numArray.sumRange(1, 2);
```


"
0304 Range Sum Query 2D - Immutable;"https://leetcode.com/problems/range-sum-query-2d-immutable/description/

* algorithms
* Medium (31.28%)
* Total Accepted:    63.8K
* Total Submissions: 203.9K
* Testcase Example:  '[""NumMatrix"",""sumRegion"",""sumRegion"",""sumRegion""]\n[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]'

Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).



The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.


Example:

Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12



Note:

You may assume that the matrix does not change.
There are many calls to sumRegion function.
You may assume that row1 ≤ row2 and col1 ≤ col2.







";"
```cpp
class NumMatrix {
    vector<vector<int>> summat;
public:
    NumMatrix(vector<vector<int>> &matrix) {
        if (matrix.empty()) return ;
        const int ROW = matrix.size(), COL = matrix[0].size();
        summat = vector<vector<int>>(ROW, vector<int>(COL, 0));
        for (int i=0; i<ROW; i++) {
            int sumrow=0; vector<int>& row = matrix[i];
            for (int j=0; j<COL; j++) {
                sumrow += row[j];
                summat[i][j] = sumrow + (i>0 ? summat[i-1][j] : 0);
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        if (summat.empty()) return 0;
        int a = summat[row2][col2];
        int b = col1>0 ? summat[row2  ][col1-1] : 0;
        int c = row1>0 ? summat[row1-1][col2  ] : 0;
        int d = row1>0&&col1>0 ? summat[row1-1][col1-1] : 0;
        return a - b - c + d;
    }
};

// Your NumMatrix object will be instantiated and called as such:
// NumMatrix numMatrix(matrix);
// numMatrix.sumRegion(0, 1, 2, 3);
// numMatrix.sumRegion(1, 2, 3, 4);
```


"
0295 Find Median from Data Stream;"https://leetcode.com/problems/find-median-from-data-stream/description/

* algorithms
* Hard (35.01%)
* Total Accepted:    94.6K
* Total Submissions: 270.1K
* Testcase Example:  '[""MedianFinder"",""addNum"",""addNum"",""findMedian"",""addNum"",""findMedian""]\n[[],[1],[2],[],[3],[]]'

Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.
For example,

[2,3,4], the median is 3

[2,3], the median is (2 + 3) / 2 = 2.5

Design a data structure that supports the following two operations:


	void addNum(int num) - Add a integer number from the data stream to the data structure.
	double findMedian() - Return the median of all elements so far.


 

Example:


addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2


 

Follow up:


	If all integer numbers from the stream are between 0 and 100, how would you optimize it?
	If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?







";"
```cpp
// Your MedianFinder object will be instantiated and called as such:
// MedianFinder mf;
// mf.addNum(1);
// mf.findMedian();
class MedianFinder {
    priority_queue<int, vector<int>, less<int>>    l;
    priority_queue<int, vector<int>, greater<int>> r;
public:
    // Adds a number into the data structure.
    void addNum(int num) {
        if (l.empty() || num <= l.top()) l.push(num); else r.push(num);
        if      (l.size() > r.size()+1) { r.push(l.top()); l.pop(); }
        else if (r.size() > l.size())   { l.push(r.top()); r.pop(); }
    }

    // Returns the median of current data stream
    double findMedian() {
        return l.size()==r.size() ? double(l.top()+r.top())/2 : l.top();
    }
};
```


"
0239 Sliding Window Maximum;"https://leetcode.com/problems/sliding-window-maximum/description/

* algorithms
* Hard (37.18%)
* Total Accepted:    140K
* Total Submissions: 376.4K
* Testcase Example:  '[1,3,-1,-3,5,3,6,7]\n3'

Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.

Example:


Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7


Note: 
You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array.

Follow up:
Could you solve it in linear time?






";"
看答案的，不是很好理解。不过貌似是一种专门的数据结构，这种一般比较难搞。

https://abitofcs.blogspot.com/2014/11/data-structure-sliding-window-minimum.html

我的理解是在Sliding Window的区间内，维护一个降序的序列。所有超出范围的去掉，所有逆序的去掉（对后续最大值没有帮助）。

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        const int N = nums.size();
        vector<int> result; deque<int> q;
        for (int i=0; i<N; i++) {
            if    (!q.empty() && q.front() == i-k)         q.pop_front();
            while (!q.empty() && nums[q.back()] < nums[i]) q.pop_back();
            q.push_back(i);
            if (i-k+1 >= 0) result.push_back(nums[q.front()]);
        }
        return result;
    }
};
```
"
0238 Product of Array Except Self;"https://leetcode.com/problems/product-of-array-except-self/description/

* algorithms
* Medium (53.93%)
* Total Accepted:    228.6K
* Total Submissions: 423.8K
* Testcase Example:  '[1,2,3,4]'

Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Example:


Input:  [1,2,3,4]
Output: [24,12,8,6]


Note: Please solve it without division and in O(n).

Follow up:
Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)






";"
以[a, b, c, d]为例

* 顺着[1, a, ab, abc]的形式
* 反着[bcd, bc, b, 1]的形式

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        const int N = nums.size(); vector<int> result(N, 1); 
        for (int i = 1, n = 1; i < N; i++) {
            n = n * nums[i-1];
            result[i] = n;
        }
        for (int i = N-2, n = 1; i >= 0; i--) {
            n = n * nums[i+1];
            result[i] = result[i] * n;
        }
        return result;
    }
};
```


"
0237 Delete Node in a Linked List;"https://leetcode.com/problems/delete-node-in-a-linked-list/description/

* algorithms
* Easy (52.09%)
* Total Accepted:    266.8K
* Total Submissions: 512K
* Testcase Example:  '[4,5,1,9]\n5'

Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Given linked list -- head = [4,5,1,9], which looks like following:



 

Example 1:


Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.


Example 2:


Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.


 

Note:


	The linked list will have at least two elements.
	All of the nodes' values will be unique.
	The given node will not be the tail and it will always be a valid node of the linked list.
	Do not return anything from your function.








";"
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        while (node->next->next) {
            node->val = node->next->val;
            node = node->next;
        }
        node->val = node->next->val;
        delete node->next;
        node->next = NULL;
    }
};
```


"
0236 Lowest Common Ancestor of a Binary Tree;"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/

* algorithms
* Medium (35.56%)
* Total Accepted:    249.5K
* Total Submissions: 701.4K
* Testcase Example:  '[3,5,1,6,2,0,8,null,null,7,4]\n5\n1'

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]

 

Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.


Example 2:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.


 

Note:


	All of the nodes' values will be unique.
	p and q are different and both values will exist in the binary tree.







";"
先找到反向的关系，用unordered_map记录。再用set反向查找一下就可以了。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* a, TreeNode* b) {
        if (!root) return NULL;
        unordered_map<TreeNode*, TreeNode*> tbl; queue<TreeNode*> q({root});
        while (!q.empty()) {
            TreeNode *n = q.front(); q.pop();
            if (n->left ) tbl[n->left ] = n, q.push(n->left );
            if (n->right) tbl[n->right] = n, q.push(n->right);
        }
        unordered_set<TreeNode*> s;
        while (a) s.insert(a), a = tbl[a];
        while (b) if (s.find(b) != s.end()) return b; else b = tbl[b];
        return NULL;
    }
};
```

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* a, TreeNode* b) {
        if (!root || root == a || root == b) return root;
        TreeNode *left  = lowestCommonAncestor(root->left , a, b);
        TreeNode *right = lowestCommonAncestor(root->right, a, b);
        if (left && right) return root;
        return left ? left : right;
    }
};
```


"
0235 Lowest Common Ancestor of a Binary Search Tree;"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/

* algorithms
* Easy (43.52%)
* Total Accepted:    259.7K
* Total Submissions: 596.5K
* Testcase Example:  '[6,2,8,0,4,7,9,null,null,3,5]\n2\n8'

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

 

Example 1:


Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.


Example 2:


Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.


 

Note:


	All of the nodes' values will be unique.
	p and q are different and both values will exist in the BST.







";"
比较简单，递归判断两个节点是不是在BST的同一个子树下即可，注意不要溢出。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* a, TreeNode* b) {
        TreeNode *p = root;
        while ((p->val - a->val) * (p->val - b->val) > 0)
            p = a->val < p->val ? p->left : p->right;
        return p;
    }
};
```


"
0233 Number of Digit One;"https://leetcode.com/problems/number-of-digit-one/description/

* algorithms
* Hard (29.90%)
* Total Accepted:    39.4K
* Total Submissions: 131.7K
* Testcase Example:  '13'

Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

Example:


Input: 13
Output: 6 
Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.







";"
f[9]表示[0,9]的范围内有多少个1。所以，f[99] = 10 * f[9] + 99 + 1，由此可推出f[999]、f[9999]、f[9999...]

给定任意一个数字，如 23456，计算其包括多少个1应该包含几个部分

* [0, 20000]包含 
    - 2 * f[9999] 
    - [10000, 19999]共10000
* (20000, 23456]包括 countDigitOne(3456)

如 12345，计算方式如下

* [0, 10000]包含 1 * f[9999]
* (1, 12345]包含 2345
* countDigitOne(2345)

```cpp
class Solution {
public:
    unordered_map<int, int> tbl;
    
    Solution() {
        int i = 9; tbl[9] = 1;
        while (i*10+9 < INT_MAX) { tbl[i*10+9] = tbl[i]*10 + i + 1; i = i*10 + 9; }
    }
    
    int countDigitOne(int n) {
        if (n <= 0) return 0; if (n <= 9) return 1;
        int divisor = 1; while (n/divisor >= 10) divisor *= 10;
        int result = 0;
        result += n / divisor * tbl[divisor-1];
        result += n/divisor > 1 ? divisor : n-divisor+1;
        result += countDigitOne(n%divisor);
        return result;
    }
};
```

又重新做了一遍

```cpp
class Solution {
public:
    unordered_map<int, int> f;

    Solution() {
        int i = 9; f[9] = 1;
        while (i < INT_MAX) { f[i*10+9] = 10 * f[i] + i + 1; i = i * 10 + 9; }
    }

    int countDigitOne(int n) {
        if (n < 1) return 0;
        int divisor = 1; while (n / divisor >= 10) divisor = divisor * 10;
        return countDigitOne(n, divisor);
    }

    int countDigitOne(int n, int divisor) {
        if (n <= 0) return 0; if (n <= 9) return 1;
        int result = 0, d = n / divisor;
        if (d == 0) return countDigitOne(n, divisor/10);
        result = d * f[divisor-1];
        result = result + (d > 1 ? divisor : n%divisor+1);
        result = result + countDigitOne(n%divisor, divisor/10);
        return result;
    }
};
```


"
0232 Implement Queue using Stacks;"https://leetcode.com/problems/implement-queue-using-stacks/description/

* algorithms
* Easy (42.12%)
* Total Accepted:    138.6K
* Total Submissions: 329K
* Testcase Example:  '[""MyQueue"",""push"",""push"",""peek"",""pop"",""empty""]\n[[],[1],[2],[],[],[]]'

Implement the following operations of a queue using stacks.


	push(x) -- Push element x to the back of queue.
	pop() -- Removes the element from in front of queue.
	peek() -- Get the front element.
	empty() -- Return whether the queue is empty.


Example:


MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // returns 1
queue.pop();   // returns 1
queue.empty(); // returns false

Notes:


	You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
	Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
	You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).







";"
```cpp
class MyQueue {
private:
    stack<int> s_;
    bool flag_;
public:
    /** Initialize your data structure here. */
    MyQueue() {
        flag_ = true;
    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        if (!flag_) {
            flag_ = true; stack<int> s; s.swap(s_);
            while (!s.empty()) { s_.push(s.top()); s.pop(); }
        }
        s_.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if (flag_) {
            flag_ = false; stack<int> s; s.swap(s_);
            while (!s.empty()) { s_.push(s.top()); s.pop(); }
        }
        int x = s_.top();
        s_.pop();
        return x;
    }
    
    /** Get the front element. */
    int peek() {
        if (flag_) {
            flag_ = false; stack<int> s; s.swap(s_);
            while (!s.empty()) { s_.push(s.top()); s.pop(); }
        }
        return s_.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return s_.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * bool param_4 = obj.empty();
 */
```


"
0231 Power of Two;"https://leetcode.com/problems/power-of-two/description/

* algorithms
* Easy (41.65%)
* Total Accepted:    214.4K
* Total Submissions: 514.7K
* Testcase Example:  '1'

Given an integer, write a function to determine if it is a power of two.

Example 1:


Input: 1
Output: true 
Explanation: 20 = 1


Example 2:


Input: 16
Output: true
Explanation: 24 = 16

Example 3:


Input: 218
Output: false






";"
位运算，比较简单。

```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return false;
        return (n & n-1) == 0;
    }
};
```


"
0230 Kth Smallest Element in a BST;"https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/

* algorithms
* Medium (50.03%)
* Total Accepted:    203K
* Total Submissions: 405.6K
* Testcase Example:  '[3,1,4,null,2]\n1'

Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note: 
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

Example 1:


Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1

Example 2:


Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3


Follow up:
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?






";"
二叉平衡树排序的思路

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode *> s; TreeNode *p = root;
        while (!s.empty() || p) {
            while (p) s.push(p), p = p->left;
            TreeNode *curr = s.top(); s.pop();
            if (--k == 0) return curr->val;
            p = curr->right;
        }
        return 0;
    }
};
```


"
0229 Majority Element II;"https://leetcode.com/problems/majority-element-ii/description/

* algorithms
* Medium (31.33%)
* Total Accepted:    93.4K
* Total Submissions: 298.2K
* Testcase Example:  '[3,2,3]'

Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

Note: The algorithm should run in linear time and in O(1) space.

Example 1:


Input: [3,2,3]
Output: [3]

Example 2:


Input: [1,1,1,3,3,2,2,2]
Output: [1,2]







";"
思路：

Boyer-Moore Majority Vote algorithm

假设主要数为num1，次要数为num2

* 如果当前数字等于主要数num1
    - 增加主要数的计数器cnt1
* 否则，如果当前数等于次要数num2
    - 增加次要数的计数器cnt2
* 否则，若主要数为空，则假设当前数为主要数
* 否则，若次要数为空，则假设当前数为次要数
* 否则，将主要数和次要数跟当前数配对，各自计数器减少1

```cpp
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int num1 = 0, cnt1 = 0, num2 = 0, cnt2 = 0;
        for (int n : nums) {
            if      (n == num1) cnt1++;
            else if (n == num2) cnt2++;
            else if (cnt1 == 0) num1 = n, cnt1 = 1;
            else if (cnt2 == 0) num2 = n, cnt2 = 1;
            else                cnt1--  , cnt2--;
        }
        cnt1 = 0, cnt2 = 0;
        for (int n : nums) {
            if      (n == num1) cnt1++;
            else if (n == num2) cnt2++;
        }
        vector<int> result;
        if (cnt1 > nums.size() / 3) result.push_back(num1);
        if (cnt2 > nums.size() / 3) result.push_back(num2);
        return result;
    }
};
```


"
0228 Summary Ranges;"https://leetcode.com/problems/summary-ranges/description/

* algorithms
* Medium (35.25%)
* Total Accepted:    124.9K
* Total Submissions: 354.3K
* Testcase Example:  '[0,1,2,4,5,7]'

Given a sorted integer array without duplicates, return the summary of its ranges.

Example 1:


Input:  [0,1,2,4,5,7]
Output: [""0->2"",""4->5"",""7""]
Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.


Example 2:


Input:  [0,2,3,4,6,8,9]
Output: [""0"",""2->4"",""6"",""8->9""]
Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.







";"
* 注意两个数相减之后溢出

```cpp
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        const int len = nums.size(); vector<string> result; 
        if (len == 0) return {};
        if (len == 1) return { to_string(nums[0]) };
        int i = 0, lo = nums[0], hi = nums[0];
        while (i < len) {
            if (i >= len-1) {
                if (lo != hi) result.push_back(to_string(lo)+""->""+to_string(hi));
                else          result.push_back(to_string(lo));
                break;
            } else if ((long)nums[i+1]-nums[i] >  1) {
                if (lo != hi) result.push_back(to_string(lo)+""->""+to_string(hi));
                else          result.push_back(to_string(lo));
                hi = lo = nums[++i];
            } else if ((long)nums[i+1]-nums[i] == 1) {
                hi = nums[++i];
            }  
        }
        return result;
    }
};
```


"
0227 Basic Calculator II;"https://leetcode.com/problems/basic-calculator-ii/description/

* algorithms
* Medium (32.65%)
* Total Accepted:    98.3K
* Total Submissions: 301K
* Testcase Example:  '""3+2*2""'

Implement a basic calculator to evaluate a simple expression string.

The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero.

Example 1:


Input: ""3+2*2""
Output: 7


Example 2:


Input: "" 3/2 ""
Output: 1

Example 3:


Input: "" 3+5 / 2 ""
Output: 5


Note:


	You may assume that the given expression is always valid.
	Do not use the eval built-in library function.






";"
细节题

```cpp
class Solution {
public:
    int calculate(const string& e) {
        stack<int> s; char op = '+'; int i = 0;
        while (i < e.length()) {
            if (isdigit(e[i])) {
                int n = 0; while (isdigit(e[i])) n = n * 10 + e[i++] - '0';
                switch (op) {
                case '+': s.push(+n); break;
                case '-': s.push(-n); break; 
                case '*': n = s.top()*n; s.pop(); s.push(n); break;
                case '/': n = s.top()/n; s.pop(); s.push(n); break;
                }
            } 
            else if (e[i] == ' ') i++;
            else                  op = e[i++];
        }
        int result = 0; while (!s.empty()) { result += s.top(); s.pop(); }
        return result;
    }
};
```


"
0226 Invert Binary Tree;"https://leetcode.com/problems/invert-binary-tree/description/

* algorithms
* Easy (57.09%)
* Total Accepted:    301.9K
* Total Submissions: 528.7K
* Testcase Example:  '[4,2,7,1,3,6,9]'

Invert a binary tree.

Example:

Input:


     4
   /   \
  2     7
 / \   / \
1   3 6   9

Output:


     4
   /   \
  7     2
 / \   / \
9   6 3   1

Trivia:
This problem was inspired by this original tweet by Max Howell:

Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.






";"
用队列记录。

```cpp
 /**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        queue<TreeNode*> q({root});
        while (!q.empty()) {
            auto node = q.front(); q.pop();
            if (node == NULL) continue;
            auto tmp = node->left; node->left = node->right; node->right = tmp;
            q.push(node->left); q.push(node->right);
        }
        return root;
    }
};
```


"
0225 Implement Stack using Queues;"https://leetcode.com/problems/implement-stack-using-queues/description/

* algorithms
* Easy (38.07%)
* Total Accepted:    120.5K
* Total Submissions: 316.5K
* Testcase Example:  '[""MyStack"",""push"",""push"",""top"",""pop"",""empty""]\n[[],[1],[2],[],[],[]]'

Implement the following operations of a stack using queues.


	push(x) -- Push element x onto stack.
	pop() -- Removes the element on top of the stack.
	top() -- Get the top element.
	empty() -- Return whether the stack is empty.


Example:


MyStack stack = new MyStack();

stack.push(1);
stack.push(2);  
stack.top();   // returns 2
stack.pop();   // returns 2
stack.empty(); // returns false

Notes:


	You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.
	Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
	You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).







";"
思路：暴力解决。

```cpp
class MyStack {
private:
    queue<int> q_;
public:
    /** Initialize your data structure here. */
    MyStack() {}
    
    /** Push element x onto stack. */
    void push(int x) {
        q_.push(x);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        queue<int> q; q.swap(q_);
        for (int i = q.size()-1; i > 0; i--) { q_.push(q.front()); q.pop(); }
        return q.front();
    }
    
    /** Get the top element. */
    int top() {
        queue<int> q; q.swap(q_);
        for (int i = q.size()-1; i > 0; i--) { q_.push(q.front()); q.pop(); }
        int top = q.front(); q_.push(q.front());
        return top;
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q_.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * bool param_4 = obj.empty();
 */
 ```


"
0224 Basic Calculator;"https://leetcode.com/problems/basic-calculator/description/

* algorithms
* Hard (31.80%)
* Total Accepted:    96.7K
* Total Submissions: 304K
* Testcase Example:  '""1 + 1""'

Implement a basic calculator to evaluate a simple expression string.

The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .

Example 1:


Input: ""1 + 1""
Output: 2


Example 2:


Input: "" 2-1 + 2 ""
Output: 3

Example 3:


Input: ""(1+(4+5+2)-3)+(6+8)""
Output: 23
Note:


	You may assume that the given expression is always valid.
	Do not use the eval built-in library function.







";"
当遇到括号时，用栈来暂存当前结果和符号。

```cpp
class Solution {
public:
    int calculate(const string& e) {
        stack<int> s; int n = 0, op = +1, len = e.length(), i = 0;
        while (i < len) {
            switch (e[i]) {
                case '+':
                    op = +1; 
                    i++;
                    break;
                case '-':
                    op = -1; 
                    i++;
                    break;
                case '(':
                    s.push(n ); n  =  0;
                    s.push(op); op = +1;
                    i++;
                    break;
                case ')':
                    op = s.top();        s.pop();
                    n  = s.top() + op*n; s.pop();
                    op = +1;
                    i++;
                    break;
                case ' ':
                    i++;
                    break;
                default:
                    int r = 0; while (isdigit(e[i])) r = r*10 + e[i++] - '0';
                    n = n + op*r;
                    break;
            }
        }
        return n;
    }
};
```


"
0223 Rectangle Area;"https://leetcode.com/problems/rectangle-area/description/

* algorithms
* Medium (35.52%)
* Total Accepted:    83.9K
* Total Submissions: 236.3K
* Testcase Example:  '-3\n0\n3\n4\n0\n-1\n9\n2'

Find the total area covered by two rectilinear rectangles in a 2D plane.

Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.



Example:


Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2
Output: 45

Note:

Assume that the total area is never beyond the maximum possible value of int.






";"
找出重合部分的leftbottom和righttop位置，然后加和两个矩形的面积减去重合部分的面积。

```cpp
class Solution {
public:
    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        int a = max(A, E), b = max(B, F), c = min(C, G), d = min(D, H), result = 0;
        result += (C-A) * (D-B);
        result += (G-E) * (H-F);
        if (c<a || d<b) return result;
        result -= (c-a) * (d-b);
        return result;
    }
};
```


"
0222 Count Complete Tree Nodes;"https://leetcode.com/problems/count-complete-tree-nodes/description/

* algorithms
* Medium (31.54%)
* Total Accepted:    108.2K
* Total Submissions: 342.7K
* Testcase Example:  '[1,2,3,4,5,6]'

Given a complete binary tree, count the number of nodes.

Note: 

Definition of a complete binary tree from Wikipedia:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

Example:


Input: 
    1
   / \
  2   3
 / \  /
4  5 6

Output: 6






";"
如果leftmost节点和rightmost节点的深度一样，就可以用公式`2^n+1`来计算节点数。
如果不相等，则只能继续递归计算左右子树的节点数。

60ms

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == NULL) return 0;
        int lh = 0; for (auto p = root; p; p = p->left ) lh++;
        int rh = 0; for (auto p = root; p; p = p->right) rh++;
        if (lh == rh) return (1 << lh) - 1;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

* 尝试做点优化，把左右子节点的深度复用，防止重复计算每个子树的leftmost和rightmost的深度

40ms

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        return countNodes(root, 0, 0);
    }

    int countNodes(TreeNode* root, int lh, int rh) {
        if (root == NULL) return 0;
        if (lh == 0) for (auto p = root; p; p = p->left ) lh++;
        if (rh == 0) for (auto p = root; p; p = p->right) rh++;
        if (lh == rh) return (1 << lh) - 1;
        return countNodes(root->left, lh-1, 0) + countNodes(root->right, 0, rh-1) + 1;
    }
};
```


"
0221 Maximal Square;"https://leetcode.com/problems/maximal-square/description/

* algorithms
* Medium (32.30%)
* Total Accepted:    119.5K
* Total Submissions: 369.8K
* Testcase Example:  '[[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]]'

Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

Example:


Input: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Output: 4






";"
* 动态规划，`f[i][j]`表示以(i,j)为rightbottom节点的最大矩形大小
* a表示当前节点的右上角节点，b表示当前的上方一个节点，c表示当前节点左边的一个节点
* 只有知道a b c的最小值就可以了。

16 ms

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int m = matrix.size();    if (m == 0) return 0;
        int n = matrix[0].size(); if (n == 0) return 0;
        vector<vector<int>> f(m, vector<int>(n, 0));
        int a, b, c, result = 0;
        for (int i=0; i<m; i++) for (int j=0; j<n; j++) {
            if (matrix[i][j] == '0') continue;
            a = b = c = 0;
            if (i>0 && j>0) a = f[i-1][j-1];
            if (i > 0) b      = f[i-1][j  ];
            if (j > 0) c      = f[i  ][j-1];
            f[i][j] = min({a, b, c}) + 1;
            result = max(result, f[i][j] * f[i][j]);
        }
        return result;
    }
};
```

试试将dp的二维表改成一维表试试效果，12ms。

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int m = matrix.size();    if (m == 0) return 0;
        int n = matrix[0].size(); if (n == 0) return 0;
        vector<int> f(n, 0); 
        int a = 0, b, c, i, j, result = 0;
        for (i=0; i<m; i++) for (j=0, a=0; j<n; j++) {
            if (matrix[i][j] == '0') { f[j] = 0; continue; }
            a = a;
            b = f[j];
            c = 0; if (j > 0) c = f[j-1];
            f[j] = min({a, b, c}) + 1; 
            if (i > 0) a = b;
            result = max(result, f[j]*f[j]);
        }
        return result;
    }
};
```


"
0220 Contains Duplicate III;"https://leetcode.com/problems/contains-duplicate-iii/description/

* algorithms
* Medium (19.45%)
* Total Accepted:    86.5K
* Total Submissions: 444.6K
* Testcase Example:  '[1,2,3,1]\n3\n0'

Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.


Example 1:


Input: nums = [1,2,3,1], k = 3, t = 0
Output: true



Example 2:


Input: nums = [1,0,1,1], k = 1, t = 2
Output: true



Example 3:


Input: nums = [1,5,9,1,5,9], k = 2, t = 3
Output: false











";"
* 用bucket的思路，桶的映射区间用 t+1。
* 每个bucket如果有两个数，则表示return true。
* 相邻的bucket则需要通过算差值来判断。
* 注意n t bucket都要转换成long，防止溢出。

```cpp
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        if (k<1 || t<0) return false;
        unordered_map<long, long> tbl; 
        for (int i=0; i<nums.size(); i++) {
            long n = (long)nums[i] - INT_MIN;
            long bucket = n / ((long)t+1);
            if (tbl.find(bucket) != end(tbl) || 
                (tbl.find(bucket-1) != end(tbl) && n-tbl[bucket-1] <= t) ||
                (tbl.find(bucket+1) != end(tbl) && tbl[bucket+1]-n <= t))
                return true;
            tbl[bucket] = n;
            if (i >= k) tbl.erase(((long)nums[i-k] - INT_MIN) / ((long)t+1));
        }
        return false;
    }
};
```
"
0219 Contains Duplicate II;"https://leetcode.com/problems/contains-duplicate-ii/description/

* algorithms
* Easy (34.73%)
* Total Accepted:    184.8K
* Total Submissions: 532.1K
* Testcase Example:  '[1,2,3,1]\n3'

Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.


Example 1:


Input: nums = [1,2,3,1], k = 3
Output: true



Example 2:


Input: nums = [1,0,1,1], k = 1
Output: true



Example 3:


Input: nums = [1,2,3,1,2,3], k = 2
Output: false










";"
用一个set将区间为k范围内的数字都放进去，进行查重。

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_set<int> tbl; int i=0;
        for (int i=0; i<nums.size(); i++) {
            if (!tbl.insert(nums[i]).second) return true;
            if (i >= k) tbl.erase(nums[i-k]);
        }
        return false;
    }
};
```


"
0218 The Skyline Problem;"https://leetcode.com/problems/the-skyline-problem/description/

* algorithms
* Hard (31.10%)
* Total Accepted:    85.8K
* Total Submissions: 275.7K
* Testcase Example:  '[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]'

A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).
    

The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.

For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .

The output is a list of ""key points"" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.

For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].

Notes:


	The number of buildings in any input list is guaranteed to be in the range [0, 10000].
	The input list is already sorted in ascending order by the left x position Li.
	The output list must be sorted by the x position.
	There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]







";"
```cpp
class Solution {
public:
    vector<pair<int, int>> getSkyline(vector<vector<int>>& LRH) {
        struct RH { 
            int R, H;
            bool operator()(RH& l, RH& r) { return l.H < r.H; } // lessthan
            RH() {};
            RH(int r, int h) : R(r), H(h) {}
        };
        priority_queue<RH, vector<RH>, RH> RHq;
        vector<pair<int, int>> result; int len = LRH.size();
        int x, y, i=0, Li=0, Ri=1, Hi=2;
        while (i<len || !RHq.empty()) {
            if (RHq.empty() || i<len && LRH[i][Li]<=RHq.top().R) {
                x = LRH[i][Li]; 
                while (i<len && LRH[i][Li]==x) { RHq.push(RH(LRH[i][Ri], LRH[i][Hi])); i++; }
            } else {
                x = RHq.top().R;
                while (!RHq.empty() && RHq.top().R<=x) { RHq.pop(); }
            }
            y = RHq.empty() ? 0 : RHq.top().H;
            if (result.empty() || result.back().second!=y) {
                result.push_back({x, y});
            }
        }
        return move(result);
    }
};
```


"
0217 Contains Duplicate;"https://leetcode.com/problems/contains-duplicate/description/

* algorithms
* Easy (50.88%)
* Total Accepted:    305.3K
* Total Submissions: 599.8K
* Testcase Example:  '[1,2,3,1]'

Given an array of integers, find if the array contains any duplicates.

Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

Example 1:


Input: [1,2,3,1]
Output: true

Example 2:


Input: [1,2,3,4]
Output: false

Example 3:


Input: [1,1,1,3,3,4,3,2,4,2]
Output: true







";"
用unordered_set即可。

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> tbl;
        for (auto n : nums) 
            if (!tbl.insert(n).second)return true;
        return false;
    }
};
```


"
0216 Combination Sum III;"https://leetcode.com/problems/combination-sum-iii/description/

* algorithms
* Medium (50.53%)
* Total Accepted:    113.9K
* Total Submissions: 225.4K
* Testcase Example:  '3\n7'


Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.

Note:


	All numbers will be positive integers.
	The solution set must not contain duplicate combinations.


Example 1:


Input: k = 3, n = 7
Output: [[1,2,4]]


Example 2:


Input: k = 3, n = 9
Output: [[1,2,6], [1,3,5], [2,3,4]]







";"
深搜，每个数字来或者不来，一遍过。

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> result; vector<int> path;
        static array<int, 9> nums = {1, 2, 3, 4, 5, 6, 7, 8, 9}; 
        combinationSum3(k, n, 0, nums, path, result);
        return move(result);
    }

    void combinationSum3(int k, int n, int i, array<int, 9> &nums, vector<int> &path, vector<vector<int>> &result) {
        if (path.size() == k) {
            int sum = 0; for (int x : path) sum += x;
            if (sum == n) result.push_back(path);
            return;
        }
        if (i >= 9) return;
        path.push_back(nums[i]);
        combinationSum3(k, n, i+1, nums, path, result);
        path.pop_back();
        combinationSum3(k, n, i+1, nums, path, result);
    }
};
```


"
0215 Kth Largest Element in an Array;"https://leetcode.com/problems/kth-largest-element-in-an-array/description/

* algorithms
* Medium (46.10%)
* Total Accepted:    329.2K
* Total Submissions: 713.6K
* Testcase Example:  '[3,2,1,5,6,4]\n2'

Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:


Input: [3,2,1,5,6,4] and k = 2
Output: 5


Example 2:


Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4

Note: 
You may assume k is always valid, 1 ≤ k ≤ array's length.






";"
* priority_queue默认是最大堆。
* 将less<int>改为greater<int>来获取最小堆。
* 维持堆中的个数为k个，由于较小的数字已经先出去了，那么top就是第k个数字。
* 假设第k大的数字是x，那么在数组中任意去k+1个数，肯定至少存在一个数字比x小。否则x就是第k+1大的数了。

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        if (nums.size() < k) return 0;
        priority_queue<int, vector<int>, greater<int>> q;
        for (int i=0; i<nums.size(); i++) {
            q.push(nums[i]); if (q.size() > k) q.pop();
        }
        return q.top();
    }
};
```


"
0214 Shortest Palindrome;"https://leetcode.com/problems/shortest-palindrome/description/

* algorithms
* Hard (27.11%)
* Total Accepted:    70.4K
* Total Submissions: 259.5K
* Testcase Example:  '""aacecaaa""'

Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.

Example 1:


Input: ""aacecaaa""
Output: ""aaacecaaa""


Example 2:


Input: ""abcd""
Output: ""dcbabcd""





";"
* 用了kmp计算prefix function的方法，计算每个字符位置的最大匹配前缀后缀的长度。
* 通过将字符串反转，中间加上分隔符，这样得到的最后的字符就是以s的首字符为起点的最大回文子串。
* 注意计算p的时候，如果j==0，此时ab[i]和ab[j]可能相等，也可能不等。如果相等最p[i]值应该是1，因为最少有一个字符的前后缀相等。所以，最后p[i]要判断下ab[i]==ab[j]。

```cpp
class Solution {
public:
    string shortestPalindrome(const string& s) {
        const string &a = s; 
        string b = s; reverse(begin(b), end(b));
        string ab = a + ""|"" + b; 
        int len = ab.length();
        vector<int> p(len, 0);
        for (int i=1; i<len; i++) {
            int j = p[i-1]; while (j>0 && ab[i]!=ab[j]) j = p[j-1];
            p[i] = j + (ab[i] == ab[j]);
        }
        return b.substr(0, b.length()-p.back()) + a;
    }
};
```


"
0213 House Robber II;"https://leetcode.com/problems/house-robber-ii/description/

* algorithms
* Medium (35.09%)
* Total Accepted:    107K
* Total Submissions: 305K
* Testcase Example:  '[2,3,2]'

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:


Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.


Example 2:


Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.






";"
连成圈之后，要么 1. front取，back不取 2. font不取，back取 3. front和back都不取。换个角度，我们可以分别计算[0, len-1)和[1,len)两个区间的最大rob，然后取较大者就是我们想要的了。

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int len = nums.size();
        if (len == 0) return 0;
        if (len == 1) return nums[0];
        if (len == 2) return max(nums[0], nums[1]);
        return max(rob(nums, 0, len-1), rob(nums, 1, len));
    }
    
    int rob(vector<int>& nums, int i, int j) {
        int a = 0, b = 0, c;
        for (;i < j; i++) c=a, a=b+nums[i], b=max(b,c);
        return max(a, b);
    }
};
```


"
0212 Word Search II;"https://leetcode.com/problems/word-search-ii/description/

* algorithms
* Hard (27.64%)
* Total Accepted:    100.3K
* Total Submissions: 362.5K
* Testcase Example:  '[[""o"",""a"",""a"",""n""],[""e"",""t"",""a"",""e""],[""i"",""h"",""k"",""r""],[""i"",""f"",""l"",""v""]]\n[""oath"",""pea"",""eat"",""rain""]'

Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, where ""adjacent"" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

Example:


Input: 
words = [""oath"",""pea"",""eat"",""rain""] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]

Output: [""eat"",""oath""]


Note:
You may assume that all inputs are consist of lowercase letters a-z.






";"
```cpp
class Solution {
public:
    struct TrieNode {
        char flag; TrieNode* next[26];
        TrieNode() { flag = 0; fill_n(next, 26, nullptr); }
        ~TrieNode() { for (auto p : next) if (p) delete p; }
    };
    
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        if (board.empty()) return vector<string>();
        TrieNode *root = buildTrie(words);
        vector<string> result; string word;
        for (int x=0; x<board.size(); x++) for (int y=0; y<board[0].size(); y++)
            findWords(board, x, y, root, word, result);
        delete root;
        return result;
    }
    
    void findWords(vector<vector<char>>& board, int x, int y, TrieNode* node, string& word, vector<string>& result) {
        if (board[x][y] == '*') return ;
        char c = board[x][y]; char index = c - 'a';
        node = node->next[index]; 
        if (node == nullptr) return ;
        board[x][y] = '*'; word.push_back(c);
        if (node->flag == 1) { result.push_back(word); node->flag = 0; };
        if (x-1 >= 0)              findWords(board, x-1, y,   node, word, result);
        if (x+1 < board.size())    findWords(board, x+1, y,   node, word, result);
        if (y-1 >= 0)              findWords(board, x,   y-1, node, word, result);
        if (y+1 < board[0].size()) findWords(board, x,   y+1, node, word, result);
        board[x][y] = c;   word.pop_back();
        return ; 
    }
    
    TrieNode *buildTrie(vector<string>& words) {
        TrieNode *root = new TrieNode();
        for (auto& word : words) {
            TrieNode *node = root;
            for (int i=0; i<word.size(); i++) {
                char index = word[i] - 'a';
                if (node->next[index] == nullptr) node->next[index] = new TrieNode();
                node = node->next[index];
            }
            node->flag = 1;
        }
        return root;
    }
};
```


"
0211 Add and Search Word - Data structure design;"https://leetcode.com/problems/add-and-search-word-data-structure-design/description/

* algorithms
* Medium (29.24%)
* Total Accepted:    105.5K
* Total Submissions: 360.7K
* Testcase Example:  '[""WordDictionary"",""addWord"",""addWord"",""addWord"",""search"",""search"",""search"",""search""]\n[[],[""bad""],[""dad""],[""mad""],[""pad""],[""bad""],["".ad""],[""b..""]]'

Design a data structure that supports the following two operations:


void addWord(word)
bool search(word)


search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

Example:


addWord(""bad"")
addWord(""dad"")
addWord(""mad"")
search(""pad"") -> false
search(""bad"") -> true
search("".ad"") -> true
search(""b.."") -> true


Note:
You may assume that all words are consist of lowercase letters a-z.






";"
* 用Trie树
* 注意当c == '.'时，循环当前p->next的每个节点，但是当p->next的节点都为空时，表示没有匹配的了，要在最后return false。

```cpp
class WordDictionary {
public:
    struct TrieNode {
        array<TrieNode*, 26> next = { NULL };
        bool flag = false;
    };

    TrieNode head;

    /** Initialize your data structure here. */
    WordDictionary() { }
    
    /** Adds a word into the data structure. */
    void addWord(const string& word) {
        TrieNode *p = &head;
        for (char c : word) {
            if (!p->next[c-'a']) 
                p->next[c-'a'] = new TrieNode();
            p = p->next[c-'a'];
        }
        p->flag = true;
    }
    
    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */
    bool search(const string& word) {
        return search(word, 0, &head);
    }

    bool search(const string& word, int i, TrieNode* p) {
        for (; i<word.length(); i++) {
            char c = word[i];
            if (c != '.') {
                p = p->next[c-'a'];
                if (!p) return false;
            } else {
                for (auto n : p->next) 
                    if (n && search(word, i+1, n)) return true;
                return false;
            }
        }
        return p->flag;
    }
};

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * bool param_2 = obj.search(word);
 */
```


"
0210 Course Schedule II;"https://leetcode.com/problems/course-schedule-ii/description/

* algorithms
* Medium (33.72%)
* Total Accepted:    132.1K
* Total Submissions: 391.6K
* Testcase Example:  '2\n[[1,0]]'

There are a total of n courses you have to take, labeled from 0 to n-1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

Example 1:


Input: 2, [[1,0]] 
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   
             course 0. So the correct course order is [0,1] .

Example 2:


Input: 4, [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3] or [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     
             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. 
             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .

Note:


	The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
	You may assume that there are no duplicate edges in the input prerequisites.







";"
拓扑排序，20ms。

```cpp
class Solution {
public:
    vector<int> findOrder(int n, vector<pair<int, int>>& prerequisites) {
        vector<int> result, indegree(n, 0); vector<vector<int>> graph(n);
        for (auto& preq : prerequisites) {
            graph[preq.second].push_back(preq.first);
            indegree[preq.first]++;
        }
        int count = 0;
        while (count != n) {
            int hold = count;
            for (int i=0; i<n; i++) {
                if (indegree[i] == 0) {
                    for (int j : graph[i]) indegree[j]--;
                    count++; result.push_back(i); indegree[i]=-1;
                }
            }
            if (hold == count) return {};
        }
        return result;
    }
};
```

换个思路，用gray记录当前未被访问的节点，16ms。

```cpp
class Solution {
public:
    vector<int> findOrder(int n, vector<pair<int, int>>& prerequisites) {
        vector<int> white, indegree(n, 0); vector<vector<int>> graph(n);
        for (auto& preq : prerequisites) {
            graph[preq.second].push_back(preq.first);
            indegree[preq.first]++;
        }
        int count = 0; vector<int> gray;
        for (int i=0; i<n; i++) if (indegree[i] == 0) gray.push_back(i);
        while (!gray.empty()) {
            int x = gray.back(); gray.pop_back();
            white.push_back(x);
            for (int i : graph[x]) if (--indegree[i] == 0) gray.push_back(i);
        }
        return white.size() == n ? white : vector<int>();
    }
};
```


"
0209 Minimum Size Subarray Sum;"https://leetcode.com/problems/minimum-size-subarray-sum/description/

* algorithms
* Medium (34.29%)
* Total Accepted:    164K
* Total Submissions: 478.2K
* Testcase Example:  '7\n[2,3,1,2,4,3]'

Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.

Example: 


Input: s = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: the subarray [4,3] has the minimal length under the problem constraint.

Follow up:

If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). 







";"
用两个指针i j进行计算，如果f[i,j]>=sum, 那么f[p,q]>=sum，当p<=i或q>=j。
* 当sum >= s时，计算当前的subarraySize，并删除最左边的子数组元素。
* 当sum <  s时，将子数组向右扩张一个元素。
* 然后增加result的大小比较，如果result为1直接返回即可，因为不可能比1还小的情况了。同时防止了i超过j的场景。
* 当j >= len时，表示此时没有更多元素可以进行相加了，直接返回即可。


```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int len = nums.size(); if (len == 0) return 0;
        int sum = nums[0], i = 0, j = 1, result = INT_MAX;
        while (true) {
            if (sum >= s) {
                if ((result = min(result, j-i)) == 1) return 1;
                sum -= nums[i++];
            } else {
                if (j >= len) return result == INT_MAX ? 0 : result;
                sum += nums[j++];
            }
        }
        return 0;
    }
};
```


"
0208 Implement Trie (Prefix Tree);"https://leetcode.com/problems/implement-trie-prefix-tree/description/

* algorithms
* Medium (36.87%)
* Total Accepted:    163.6K
* Total Submissions: 443.5K
* Testcase Example:  '[""Trie"",""insert"",""search"",""search"",""startsWith"",""insert"",""search""]\n[[],[""apple""],[""apple""],[""app""],[""app""],[""app""],[""app""]]'

Implement a trie with insert, search, and startsWith methods.

Example:


Trie trie = new Trie();

trie.insert(""apple"");
trie.search(""apple"");   // returns true
trie.search(""app"");     // returns false
trie.startsWith(""app""); // returns true
trie.insert(""app"");   
trie.search(""app"");     // returns true


Note:


	You may assume that all inputs are consist of lowercase letters a-z.
	All inputs are guaranteed to be non-empty strings.








";"
注意：

* next[26]是否存在下一个节点指针。
* flag表示当前节点是不是一个word的终止位置。

```cpp
class Trie {
public:
    /** Initialize your data structure here. */
    Trie() {}
    
    /** Inserts a word into the trie. */
    void insert(const string& word) {
        TrieNode *p = &head;
        for (char c : word) {
            auto node = p->next[c-'a'];
            if (node == NULL) p->next[c-'a'] = node = new TrieNode();
            p = node;
        }
        p->flag = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(const string& word) {
        TrieNode *p = &head; 
        for (char c : word) {
            p = p->next[c-'a'];
            if (!p) return false;
        }
        return p->flag;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(const string& prefix) {
        TrieNode *p = &head; 
        for (char c : prefix) {
            p = p->next[c-'a'];
            if (!p) return false;
        }
        return p != NULL;
    }

    struct TrieNode {
        array<TrieNode*, 26> next = { NULL };
        bool flag = false;
    };

    TrieNode head;
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * bool param_2 = obj.search(word);
 * bool param_3 = obj.startsWith(prefix);
 */
```


"
0207 Course Schedule;"https://leetcode.com/problems/course-schedule/description/

* algorithms
* Medium (36.75%)
* Total Accepted:    190.4K
* Total Submissions: 518K
* Testcase Example:  '2\n[[1,0]]'

There are a total of n courses you have to take, labeled from 0 to n-1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

Example 1:


Input: 2, [[1,0]] 
Output: true
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0. So it is possible.

Example 2:


Input: 2, [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0, and to take course 0 you should
             also have finished course 1. So it is impossible.


Note:


	The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
	You may assume that there are no duplicate edges in the input prerequisites.







";"
拓扑排序，60ms，注意在deps.erase之后，不能再继续当前的遍历了，引文deps的内容被改变了。

```cpp
class Solution {
public:
    bool canFinish(int n, vector<pair<int, int>>& prerequisites) {
        if (prerequisites.empty()) return true;
        unordered_map<int, vector<int>> deps; unordered_set<int> white;
        for (auto& req : prerequisites) 
            deps[req.first].push_back(req.second);
        for (int i=0; i<n; i++) 
            if (deps.find(i) == end(deps)) white.insert(i);
        while (!deps.empty()) {
            bool infinite = true;
            for (auto& dep : deps) {
                bool flag = true;
                for (auto i : dep.second) 
                    if (white.find(i) == end(white)) { flag = false; break; }
                if (flag) { 
                    infinite = false; white.insert(dep.first); deps.erase(dep.first); 
                    break; 
                }
            }
            if (infinite) return false;
        }
        return true;
    }
};
```

用BFS搜索一下，indegree表示每个节点的入度，12ms。

```cpp
class Solution {
public:
    bool canFinish(int n, vector<pair<int, int>>& prerequisites) {
        if (prerequisites.empty()) return true;
        vector<vector<int>> graph(n); vector<int> indegree(n, 0);
        for (auto preq : prerequisites) {
            graph[preq.second].push_back(preq.first);
            indegree[preq.first]++;
        }
        int count = 0;
        while (count != n) {
            int hold = count;
            for (int i=0; i<n; i++) {
                if (indegree[i] == 0) {
                    for (int j : graph[i]) indegree[j]--;
                    count++; indegree[i] = -1;
                }
            }
            if (hold == count) return false;
        }
        return true;
    }
};
```

调整为white、gray、black的思路。

```cpp
class Solution {
public:
    bool canFinish(int n, vector<pair<int, int>>& prerequisites) {
        if (prerequisites.empty()) return true;
        vector<vector<int>> graph(n); vector<int> indegree(n, 0);
        for (auto preq : prerequisites) {
            graph[preq.second].push_back(preq.first);
            indegree[preq.first]++;
        }
        int count = 0; vector<int> gray;
        for (int i=0; i<n; i++) if (indegree[i] == 0) gray.push_back(i);
        while (!gray.empty()) {
            int x = gray.back(); gray.pop_back(); count++;
            for (int i : graph[x]) if (--indegree[i] == 0) gray.push_back(i);
        }
        return count == n;
    }
};
```

因为是检测图中是否有环存在，所以反向也是等价的，fun fact。

```cpp
class Solution {
public:
    bool canFinish(int n, vector<pair<int, int>>& prerequisites) {
        if (prerequisites.empty()) return true;
        vector<vector<int>> graph(n); vector<int> indegree(n, 0);
        for (auto preq : prerequisites) {
            graph[preq.first].push_back(preq.second);
            indegree[preq.second]++;
        }
        int count = 0; vector<int> gray;
        for (int i=0; i<n; i++) if (indegree[i] == 0) gray.push_back(i);
        while (!gray.empty()) {
            int x = gray.back(); gray.pop_back(); count++;
            for (int i : graph[x]) if (--indegree[i] == 0) gray.push_back(i);
        }
        return count == n;
    }
};
```


"
0206 Reverse Linked List;"https://leetcode.com/problems/reverse-linked-list/description/

* algorithms
* Easy (52.88%)
* Total Accepted:    523K
* Total Submissions: 988.6K
* Testcase Example:  '[1,2,3,4,5]'

Reverse a singly linked list.

Example:


Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL


Follow up:

A linked list can be reversed either iteratively or recursively. Could you implement both?






";"
Iteratively

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head) return NULL;
        ListNode *a = NULL, *b = head, *c = b->next;
        b->next = a;
        while (c) {
            a = b; b = c; c = c->next;
            b->next = a;
        }
        return b;
    }
};
```

Recursively

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head) return NULL;
        ListNode *rear = NULL, *p = head;
        reverseList(p, head, rear);
        return head;
    }

    void reverseList(ListNode* p, ListNode*& head, ListNode*& rear) {
        if (p->next == NULL) {
            head = p; rear = p; return;
        }
        reverseList(p->next, head, rear);
        rear->next = p; rear = p; p->next = NULL;
    }
};
```


"
0205 Isomorphic Strings;"https://leetcode.com/problems/isomorphic-strings/description/

* algorithms
* Easy (36.76%)
* Total Accepted:    188.8K
* Total Submissions: 513.6K
* Testcase Example:  '""egg""\n""add""'

Given two strings s and t, determine if they are isomorphic.

Two strings are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

Example 1:


Input: s = ""egg"", t = ""add""
Output: true


Example 2:


Input: s = ""foo"", t = ""bar""
Output: false

Example 3:


Input: s = ""paper"", t = ""title""
Output: true

Note:
You may assume both s and t have the same length.






";"
```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int slen = s.length(), tlen = t.length();
        if (slen != tlen) return false;
        if (slen == 0   ) return true;
        unordered_map<char, char> s2t, t2s;
        for (int i=0; i<slen; i++) {
            auto a=s2t.find(s[i]), b=t2s.find(t[i]);
            if ((a!=end(s2t)) ^ (b!=end(t2s))) return false;
            if      (a == end(s2t)) s2t[s[i]]=t[i], t2s[t[i]]=s[i];
            else if (a->second!=t[i] || b->second!=s[i]) return false;
        }
        return true;
    }
};
```

用array，学到了聚合初始化的概念

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int slen = s.length(), tlen = t.length();
        if (slen != tlen) return false;
        if (slen == 0   ) return true;
        array<char, 256> s2t{0}, t2s{0};
        for (int i=0; i<slen; i++) {
            char a = s2t[s[i]], b = t2s[t[i]];
            if      (a != 0  ^  b != 0 ) return false;
            if      (a == 0  && b == 0 ) s2t[s[i]]=t[i], t2s[t[i]]=s[i];
            else if (a!=t[i] || b!=s[i]) return false;
        }
        return true;
    }
};
```


"
0204 Count Primes;"https://leetcode.com/problems/count-primes/description/

* algorithms
* Easy (28.29%)
* Total Accepted:    216K
* Total Submissions: 763K
* Testcase Example:  '10'

Count the number of prime numbers less than a non-negative number, n.

Example:


Input: 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.






";"
打表法，然后判断一个数是否是prime的时候，从2到sqrt(x)之间的质数都出一遍，就能判断了。

```cpp
class Solution {
public:
    int countPrimes(int n) {
        static vector<int> f = {2, 3, 5};
        if (n <= f.back()) for (int i=0; i<f.size(); i++) if (f[i] >= n) return i;
        for (int x=f.back()+1; x<n; x++) {
            bool flag = true; int up = sqrt(x);
            for (int i=0; f[i]<=up; i++) if (x%f[i] == 0) { flag = false; break; }
            if (flag) f.push_back(x);
        }
        return f.size();
    }
};
```

Sieve of Eratosthenes 一种用于查找质数的快速算法。

* 当发现x是质数时，从`x*x`开始标记，因为`[0..x)*x`的合数位置都被之前的质数给标记过了。
* 在`x*x<n`时候，就已经将f中所有合数给标记出来了。因为当`x*x>=n`时，标记的起始位置就已经超过n了。

```cpp
class Solution {
public:
    int countPrimes(int n) {
        if (n <= 2) return 0;
        vector<int> f(n, 1); f[0] = f[1] = 0;
        for (int x=2; x*x<n; x++) 
            if (f[x]) for (int i=x*x; i<n; i+=x) f[i] = 0;
        int result = 0; for (int i=0; i<n; i++) if (f[i]) result++;
        return result;
    }
};
```


"
0203 Remove Linked List Elements;"https://leetcode.com/problems/remove-linked-list-elements/description/

* algorithms
* Easy (35.30%)
* Total Accepted:    208.4K
* Total Submissions: 590.4K
* Testcase Example:  '[1,2,6,3,4,5,6]\n6'

Remove all elements from a linked list of integers that have value val.

Example:


Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5







";"
一遍过，注意用dummy节点，和判断p->next。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (!head) return NULL;
        ListNode dummy(0), *p = &dummy; dummy.next = head;
        while (p->next) {
            if (p->next->val == val) {
                auto tmp = p->next;
                p->next = tmp->next;
                delete tmp;
            } else {
                p = p->next;
            }
        }
        return dummy.next;
    }
};
```


"
0202 Happy Number;"https://leetcode.com/problems/happy-number/description/

* algorithms
* Easy (44.33%)
* Total Accepted:    215.2K
* Total Submissions: 485.4K
* Testcase Example:  '19'

Write an algorithm to determine if a number is ""happy"".

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example: 


Input: 19
Output: true
Explanation: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1






";"
用一个set记录重复的值

```cpp
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> tbl;
        while (n != 1) {
            int m = 0;
            while (n > 0) {
                int x = n % 10;
                n = n / 10;
                m = m + x*x;
            } 
            n = m;
            if (tbl.find(n) != end(tbl)) 
                return false;
            tbl.insert(n);
        }
        return true;
    }
};
```

看了discuss有一个思路，借鉴循环链表的思路，一个走一步，一个走两步，可以用常量的空间来找出循环。brilliant


"
0201 Bitwise AND of Numbers Range;"https://leetcode.com/problems/bitwise-and-of-numbers-range/description/

* algorithms
* Medium (35.57%)
* Total Accepted:    77.9K
* Total Submissions: 219K
* Testcase Example:  '5\n7'

Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

Example 1:


Input: [5,7]
Output: 4


Example 2:


Input: [0,1]
Output: 0





";"
找到从左到右m和n第一个不同的位，那么该位开始，只到右侧的数字，在加1的过程中，都会存在0变成1或者1变成0的情况。这时候，把这些位给变成0就可以了。

```cpp
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int len = 32, x = 0, result = 0;
        for (int i=len-1; i>=0; i--) {
            x = x + (1<<i);
            if ((m&x) != (n&x)) break;
            result = m & x;
        }
        return result;
    }
};
```

看discuss有一个更简单的方法，就是持续的把n的rightmost的1给消掉。

```cpp
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        while (m < n) n = n & (n-1);
        return n;
    }
};
```


"
0200 Number of Islands;"https://leetcode.com/problems/number-of-islands/description/

* algorithms
* Medium (40.36%)
* Total Accepted:    308.3K
* Total Submissions: 763.6K
* Testcase Example:  '[[""1"",""1"",""1"",""1"",""0""],[""1"",""1"",""0"",""1"",""0""],[""1"",""1"",""0"",""0"",""0""],[""0"",""0"",""0"",""0"",""0""]]'

Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:


Input:
11110
11010
11000
00000

Output: 1


Example 2:


Input:
11000
11000
00100
00011

Output: 3







";"
深度遍历标记法

* 注意pair的值可以用`tie(i,j) = foo()`取，还有个C++17的语法`auto [i,j] = foo`貌似leetcode不支持。

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size(), result = 0;
        for (int i=0; i<m; i++) for (int j=0; j<n; j++) {
            if (grid[i][j] == '0') continue;
            result++; mark(grid, i, j, m, n);
        }
        return result;
    }
    
    void mark(vector<vector<char>>& grid, int i, int j, int m, int n) {
        queue<pair<int,int>> q; q.push({i,j});
        do {
            tie(i, j) = q.front(); q.pop();
            if (grid[i][j] != '1') continue; 
            if (j>0  ) q.push({i  , j-1});
            if (i>0  ) q.push({i-1, j  });
            if (j<n-1) q.push({i  , j+1});
            if (i<m-1) q.push({i+1, j  });
            grid[i][j] = '0';
        } while(!q.empty());
    }
};
```




"
0199 Binary Tree Right Side View;"https://leetcode.com/problems/binary-tree-right-side-view/description/

* algorithms
* Medium (46.68%)
* Total Accepted:    152.5K
* Total Submissions: 326.7K
* Testcase Example:  '[1,2,3,null,5,null,4]'

Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

Example:


Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---






";"
level order traversel，加上一个获取最后一个节点的val。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result; queue<TreeNode*> curr;
        if (root) curr.push(root);
        while (!curr.empty()) {
            queue<TreeNode*> next;
            result.push_back(curr.back()->val);
            do {
                auto p = curr.front(); curr.pop();
                if (p->left ) next.push(p->left );
                if (p->right) next.push(p->right);
            } while (!curr.empty());
            swap(curr, next);
        }
        return move(result);
    }
};
```


"
0198 House Robber;"https://leetcode.com/problems/house-robber/description/

* algorithms
* Easy (40.79%)
* Total Accepted:    293K
* Total Submissions: 718.3K
* Testcase Example:  '[1,2,3,1]'

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:


Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.

Example 2:


Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.







";"
用深搜，超时了。

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int result = 0; if (nums.empty()) return result;
        rob(nums, 0, 0, result);
        return result;
    }
    
    void rob(vector<int>& nums, int p, int path, int& result) {
        if (p >= nums.size()) {
            result = max(result, path);
            return;
        }
        path += nums[p];
        rob(nums, p+2, path, result);
        path -= nums[p];
        rob(nums, p+1, path, result);
    }
};
```

用动态规划，f[i].first表示nums[i]取的情况，f[i].second表示nums[i]不取的情况。

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;
        int len = nums.size();
        vector<pair<int, int>> f(len, {0,0}); f[0] = {nums[0],0};
        for (int i=1; i<len; i++) {
            f[i].first  = f[i-1].second + nums[i];
            f[i].second = max(f[i-1].first, f[i-1].second);
        }
        return max(f.back().first, f.back().second);
    }
};
```

通过观察，我们可以只用常量的空间就可以了。

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;
        int len = nums.size(), a = nums[0], b = 0;
        for (int i=1; i<len; i++) {
            int tmp = a; a = b + nums[i]; b = max(tmp, b);
        }
        return max(a, b);
    }
};
```


"
0191 Number of 1 Bits;"https://leetcode.com/problems/number-of-1-bits/description/

* algorithms
* Easy (42.06%)
* Total Accepted:    243K
* Total Submissions: 577.5K
* Testcase Example:  '00000000000000000000000000001011'

Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the Hamming weight).

 

Example 1:


Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.


Example 2:


Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.


Example 3:


Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.

 

Note:


	Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
	In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3 above the input represents the signed integer -3.


 

Follow up:

If this function is called many times, how would you optimize it?






";"
```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        for (; n > 0; n = n>>1) (n&1) && (result+=1);
        return result;
    }
};
```


"
0190 Reverse Bits;"https://leetcode.com/problems/reverse-bits/description/

* algorithms
* Easy (30.26%)
* Total Accepted:    170.7K
* Total Submissions: 563.8K
* Testcase Example:  '00000010100101000001111010011100'

Reverse bits of a given 32 bits unsigned integer.

 

Example 1:


Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.


Example 2:


Input: 11111111111111111111111111111101
Output: 10111111111111111111111111111111
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.

 

Note:


	Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
	In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.


 

Follow up:

If this function is called many times, how would you optimize it?







";"
&的优先级比==号要低，注意加括号。

```cpp
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t result = 0;
        for (int i=0; i<32; i++) result = (result<<1) + (n>>i&1);
        return result;
    }
};
```


"
0189 Rotate Array;"https://leetcode.com/problems/rotate-array/description/

* algorithms
* Easy (29.03%)
* Total Accepted:    269.8K
* Total Submissions: 929K
* Testcase Example:  '[1,2,3,4,5,6,7]\n3'

Given an array, rotate the array to the right by k steps, where k is non-negative.

Example 1:


Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]


Example 2:


Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]


Note:


	Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
	Could you do it in-place with O(1) extra space?






";"
```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int len = nums.size();
        vector<int> tmp(len, 0);
        for (int i=0, j=k%len; i<len; i++, j=(i+k)%len) tmp[j] = nums[i];
        nums.swap(tmp);
    }
};
```


"
0188 Best Time to Buy and Sell Stock IV;"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/

* algorithms
* Hard (25.94%)
* Total Accepted:    80.9K
* Total Submissions: 311.8K
* Testcase Example:  '2\n[2,4,1]'

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

Example 1:


Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.


Example 2:


Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.







";"
* 类似123题的思路，只不过这里需要用一个数字来记录buy和sell的max money.
* 注意k最多只能是len-1，再多不可能了。

耗时900ms

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int len = prices.size(); if (len < 2) return 0; k = min(len-1, k);
        vector<int> f(2*k+1, 0); for (int i=0; i<2*k+1; i++) if (i&1==1) f[i]=INT_MIN;
        for (int price : prices) {
            for (int i=1; i<2*k+1; i++) {
                if (i&1==1) f[i] = max(f[i], f[i-1]-price);
                else        f[i] = max(f[i], f[i-1]+price);
            }
        }
        return f.back();
    }
};
```

看答案，可以有一些优化，当k大于len/2时，意味着我们可以主要赚钱就买。这次只要4ms。

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int len = prices.size(); if (len < 2) return 0;
        if (k > len/2) {
            int profit = 0; 
            for (int i=1; i<len; i++) 
                if (prices[i]>prices[i-1]) profit+=prices[i]-prices[i-1];
            return profit;
        }
        vector<int> f(2*k+1, 0); 
        for (int i=0; i<2*k+1; i++) if (i&1==1) f[i]=INT_MIN;
        for (int price : prices) for (int i=1; i<2*k+1; i++) 
            if (i&1==1) f[i] = max(f[i], f[i-1]-price);
            else        f[i] = max(f[i], f[i-1]+price);
        return f.back();
    }
};
```


"
0187 Repeated DNA Sequences;"https://leetcode.com/problems/repeated-dna-sequences/description/

* algorithms
* Medium (35.39%)
* Total Accepted:    118.7K
* Total Submissions: 335.3K
* Testcase Example:  '""AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT""'

All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: ""ACGAATTCCG"". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.

Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.

Example:


Input: s = ""AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT""

Output: [""AAAAACCCCC"", ""CCCCCAAAAA""]







";"
用hashmap记录子串的个数，然后把大于1的返回即可。

```cpp
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string& s) {
    	vector<string> result; if (s.empty()) return result;
        int len = s.length(); unordered_map<string, int> tbl;
        for (int i=0; i<=len-10; i++) tbl[s.substr(i, 10)]++;
        for (auto& ss : tbl) if (ss.second > 1) result.push_back(ss.first);
        return move(result);
    }
};
```

看了答案有一个非常机智的答案，A 0x41, C 0x43, G 0x47, T 0x54，他们的二进制后三位都不一样，也就是可以用30个位来表示子串。然后，用位操作就可以找打重复子串。能节省10倍的内存。

```cpp
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string& s) {
    	vector<string> result; if (s.empty()) return result;
        int n = 0, p = 0, len = s.length(); 
        while (p < 9) n = n << 3 | s[p++] & 7;
        unordered_map<int, int> tbl;
        while (p < len) 
            if (tbl[n = n << 3 & 0x3fffffff | s[p++] & 7]++ == 1) 
                result.push_back(s.substr(p-10, 10));
        return move(result);
    }
};
```

也可以将其当做四进制来计算，用一个26大小的数组，将A C G T映射到0 1 2 3，然后计算每个10字符串的大小，和上面的答案类似。


"
0179 Largest Number;"https://leetcode.com/problems/largest-number/description/

* algorithms
* Medium (25.27%)
* Total Accepted:    121.3K
* Total Submissions: 479.9K
* Testcase Example:  '[10,2]'

Given a list of non negative integers, arrange them such that they form the largest number.

Example 1:


Input: [10,2]
Output: ""210""

Example 2:


Input: [3,30,34,5,9]
Output: ""9534330""


Note: The result may be very large, so you need to return a string instead of an integer.






";"
注意点：

* 根据a+b和b+a的大小判断谁在前，谁在后。
* 使用do while是为了考虑n等于0的情况。

```cpp
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        if (nums.empty()) return ""0"";
        vector<string> ss;
        for (int n : nums) {
            string s; do { s.push_back(n%10+'0'), n=n/10; } while (n>0); 
            reverse(begin(s), end(s));
            ss.push_back(s);
        }
        sort(begin(ss), end(ss), [](string& a, string& b) {
            return a+b > b+a;
        });
        if (ss[0][0] == '0') return ""0""; 
        string result; for (string& s : ss) result.append(s);
        return move(result);
    }
};
```
"
0174 Dungeon Game;"https://leetcode.com/problems/dungeon-game/description/

* algorithms
* Hard (26.51%)
* Total Accepted:    62.3K
* Total Submissions: 235K
* Testcase Example:  '[[-2,-3,3],[-5,-10,1],[10,30,-5]]'

table.dungeon, .dungeon th, .dungeon td {
  border:3px solid black;
}

 .dungeon th, .dungeon td {
    text-align: center;
    height: 70px;
    width: 70px;
}

The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.

Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).

In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.

 

Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.

For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.


	
		
			-2 (K)
			-3
			3
		
		
			-5
			-10
			1
		
		
			10
			30
			-5 (P)
		
	


 

Note:


	The knight's health has no upper bound.
	Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.







";"
f[i][j]表示从f[i][j]到rightbottom需要的最少hp值，注意f[i][j]不能为负值，所以每次当发现f[i][j]为负值时就要纠正。

从左上向右下计算的问题在于，不能判断是以路劲最小hp值为判断依据，还是以当前的hp值大小为判断依据。

```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& D) {
        if (D.empty() || D[0].empty()) return 0;
        int m = D.size(), n = D[0].size();
        vector<vector<int>> f(m, vector<int>(n, 0));
        f[m-1][n-1] = max(-D[m-1][n-1], 0);
        for (int i=m-2; i>=0; i--) f[i][n-1] = max(f[i+1][n-1] - D[i][n-1], 0);
        for (int j=n-2; j>=0; j--) f[m-1][j] = max(f[m-1][j+1] - D[m-1][j], 0);
        for (int i=m-2; i>=0; i--) for (int j=n-2; j>=0; j--) {
            f[i][j] = min(f[i+1][j], f[i][j+1]) - D[i][j];
            f[i][j] = max(f[i][j], 0);
        }
        return f[0][0] + 1;
    }
};
```


"
0173 Binary Search Tree Iterator;"https://leetcode.com/problems/binary-search-tree-iterator/description/

* algorithms
* Medium (47.19%)
* Total Accepted:    188.3K
* Total Submissions: 398.8K
* Testcase Example:  '[""BSTIterator"",""next"",""next"",""hasNext"",""next"",""hasNext"",""next"",""hasNext"",""next"",""hasNext""]\n[[[7,3,15,null,null,9,20]],[null],[null],[null],[null],[null],[null],[null],[null],[null]]'

Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

 




Example:




BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false


 

Note:


	next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
	You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.







";"
emmm，我自己想出来的，比较难理解的一个办法。

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class BSTIterator {
private:
    stack<TreeNode*> s_;
    TreeNode * p_;
    
public:
    BSTIterator(TreeNode *root) {
        p_ = root;
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        if (!s_.empty() || p_ != NULL) return true;
        return false;
    }

    /** @return the next smallest number */
    int next() {
        if (p_) while (p_->left) s_.push(p_), p_ = p_->left;
        else    p_ = s_.top(), s_.pop();
        int val = p_->val; p_ = p_->right;
        return val;
    }
};

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = BSTIterator(root);
 * while (i.hasNext()) cout << i.next();
 */
```

看了discuss，别人的答案，感觉好理解很多。

```cpp
 /**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class BSTIterator {
private:
    stack<TreeNode*> s_;
    
public:
    BSTIterator(TreeNode *root) {
        for (auto p=root; p; p=p->left) s_.push(p);
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !s_.empty();
    }

    /** @return the next smallest number */
    int next() {
        auto n = s_.top(); s_.pop();
        for (auto p=n->right; p; p=p->left) s_.push(p);
        return n->val;
    }
};

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = BSTIterator(root);
 * while (i.hasNext()) cout << i.next();
 */
```


"
0172 Factorial Trailing Zeroes;"https://leetcode.com/problems/factorial-trailing-zeroes/description/

* algorithms
* Easy (37.26%)
* Total Accepted:    148.1K
* Total Submissions: 397.3K
* Testcase Example:  '3'

Given an integer n, return the number of trailing zeroes in n!.

Example 1:


Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.

Example 2:


Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.

Note: Your solution should be in logarithmic time complexity.






";"
10是由质数2和5相城得到的，只要计算[1, n]里有多少个5就可以了，因为2比如足够。

```cpp
class Solution {
public:
    int trailingZeroes(int n) {
        return n == 0 ? 0 : n/5 + trailingZeroes(n/5);
    }
};
```


"
0171 Excel Sheet Column Number;"https://leetcode.com/problems/excel-sheet-column-number/description/

* algorithms
* Easy (50.89%)
* Total Accepted:    208.4K
* Total Submissions: 409.5K
* Testcase Example:  '""A""'

Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:


    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...


Example 1:


Input: ""A""
Output: 1


Example 2:


Input: ""AB""
Output: 28


Example 3:


Input: ""ZY""
Output: 701






";"
根据168题反着来就好了，别忘了加1.

```cpp
class Solution {
public:
    int titleToNumber(string& s) {
        int n = 0;
        for (char ch : s) n = n * 26 + (ch - 'A') + 1;
        return n;
    }
};
```


"
0169 Majority Element;"https://leetcode.com/problems/majority-element/description/

* algorithms
* Easy (51.57%)
* Total Accepted:    351.9K
* Total Submissions: 682.1K
* Testcase Example:  '[3,2,3]'

Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

You may assume that the array is non-empty and the majority element always exist in the array.

Example 1:


Input: [3,2,3]
Output: 3

Example 2:


Input: [2,2,1,1,1,2,2]
Output: 2







";"
用一个map记录数字n的数量就可以了。

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int len = nums.size();
        unordered_map<int, int> tbl;
        for (auto n : nums) {
            tbl[n]++; if (tbl[n] > (len>>1)) return n;
        }
    }
};
```


"
0168 Excel Sheet Column Title;"https://leetcode.com/problems/excel-sheet-column-title/description/

* algorithms
* Easy (28.53%)
* Total Accepted:    164.2K
* Total Submissions: 575.4K
* Testcase Example:  '1'

Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:


    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
    ...


Example 1:


Input: 1
Output: ""A""


Example 2:


Input: 28
Output: ""AB""


Example 3:


Input: 701
Output: ""ZY""






";"
注意对应[A, Z]的是[1, 26]，而我们模上26得到的[0, 25]，所以为了能对齐，每次我们都需要n-1。

```cpp
class Solution {
public:
    string convertToTitle(int n) {
        string result;
        while (n > 0) {
            result.push_back((n-1) % 26 + 'A');
            n = (n-1) / 26;
        }
        reverse(begin(result), end(result));
        return move(result);
    }
};
```


"
0167 Two Sum II - Input array is sorted;"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/

* algorithms
* Easy (49.41%)
* Total Accepted:    216K
* Total Submissions: 437.1K
* Testcase Example:  '[2,7,11,15]\n9'

Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

Note:


	Your returned answers (both index1 and index2) are not zero-based.
	You may assume that each input would have exactly one solution and you may not use the same element twice.


Example:


Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.







";"
比two sum简单点，因为给的数已经排序好了。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int i = 0, j = nums.size()-1;
        while (i < j) {
            int sum = nums[i] + nums[j];
            if (sum == target) return {i+1, j+1};
            else if (sum > target) j--;
            else if (sum < target) i++;
        }
    }
};
```


"
0166 Fraction to Recurring Decimal;"https://leetcode.com/problems/fraction-to-recurring-decimal/description/

* algorithms
* Medium (19.20%)
* Total Accepted:    83.3K
* Total Submissions: 433.9K
* Testcase Example:  '1\n2'

Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

Example 1:


Input: numerator = 1, denominator = 2
Output: ""0.5""


Example 2:


Input: numerator = 2, denominator = 1
Output: ""2""

Example 3:


Input: numerator = 2, denominator = 3
Output: ""0.(6)""








";"
注意点：
* abs(INT_MIN) = INT_MIN，这是因为INT_MIN没有对应的正值，转成正值会越界。所以，要先转换成long整形。
* 注意numerator是0的情况，那样如果deminator是负值的话，会计算出""-0""
* map映射的是result.lengt()，因为当前length才可能是重复的开始

```cpp
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) return ""0"";
        long N = abs((long)numerator), D = abs((long)denominator), R = N % D;
        string result = ((numerator<0 ^ denominator<0) ? ""-"" : """") + to_string(N / D);
        if (R == 0) return result;
        result.push_back('.'); unordered_map<int, int> tbl;
        while (R != 0) {
            tbl[R] = result.length();
            R = R * 10;
            result.push_back(R / D + '0');
            R = R % D;
            if (tbl.find(R) != end(tbl)) {
                result.insert(tbl[R], ""("");
                result.push_back(')');
                return result;
            }
        }
        return result;
    }
};
```


"
0165 Compare Version Numbers;"https://leetcode.com/problems/compare-version-numbers/description/

* algorithms
* Medium (22.74%)
* Total Accepted:    127.7K
* Total Submissions: 561.1K
* Testcase Example:  '""0.1""\n""1.1""'

Compare two version numbers version1 and version2.
If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences.
For instance, 2.5 is not ""two and a half"" or ""half way to version three"", it is the fifth second-level revision of the second first-level revision.
You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.

 

Example 1:

Input: version1 = ""0.1"", version2 = ""1.1""
Output: -1

Example 2:

Input: version1 = ""1.0.1"", version2 = ""1""
Output: 1

Example 3:

Input: version1 = ""7.5.2.4"", version2 = ""7.5.3""
Output: -1

Example 4:

Input: version1 = ""1.01"", version2 = ""1.001""
Output: 0
Explanation: Ignoring leading zeroes, both “01” and “001"" represent the same number “1”

Example 5:

Input: version1 = ""1.0"", version2 = ""1.0.0""
Output: 0
Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to ""0""

 

Note:

Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes. 
Version strings do not start or end with dots, and they will not be two consecutive dots.






";"
注意点
* 当 `int n1=0; while ...`结束时，i指向的是'.'所在的位置，此时要'i++'，方便下轮计算，如果出国len1也没关系，反正我们是判断'i < len1'。
* 外层while循环条件是或的关系，因为只要有一个满足就可以继续比较了。

```cpp
class Solution {
public:
    int compareVersion(const string& v1, const string& v2) {
        int len1 = v1.length(), len2 = v2.length(), i = 0, j = 0;
        while (i<len1 || j<len2) {
            int n1=0; while (i<len1 && v1[i]!='.') n1 = n1*10 + v1[i++] - '0'; i++;
            int n2=0; while (j<len2 && v2[j]!='.') n2 = n2*10 + v2[j++] - '0'; j++;
            if (n1 >  n2) return 1;
            if (n1 <  n2) return -1;
        }
        return 0;
    }
};
```


"
0164 Maximum Gap;"https://leetcode.com/problems/maximum-gap/description/

* algorithms
* Hard (31.89%)
* Total Accepted:    66.5K
* Total Submissions: 208.5K
* Testcase Example:  '[3,6,9,1]'

Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

Return 0 if the array contains less than 2 elements.

Example 1:


Input: [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either
             (3,6) or (6,9) has the maximum difference 3.

Example 2:


Input: [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.

Note:


	You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.
	Try to solve it in linear time/space.







";"
桶排序，然后要注意的细节有：

* 计算gap的时候，用ceil是为了防止桶的范围不能覆盖到max的值。`realgap * (len - 1) ~= max;`
* 桶用了len个，而不是len-1个，也是为了防止桶的范围不能覆盖到max。 `gap * len  > max;`
* gap其实是平均的gap，区间中比如存在比其更大的gap，所以最后计算result的时候，没有判断`b.max - b.min`
* 可能存在空的桶，所以需要flag，来标记。
* 有可能所有的数字都是相等的，所以需要判断`if (gap) == 0`防止除0错误。

```cpp
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        if (nums.size() <= 1) return 0;
        struct Bucket { 
            int max; int min; bool flag;
            Bucket() { min=INT_MAX; max=INT_MIN; flag=false; }
        };
        int in=INT_MAX, ax=INT_MIN, len=nums.size();
        for (int n : nums) in = min(in, n), ax = max(ax, n);
        int gap = ceil((ax-in) * 1.0 / (len-1)); if (gap == 0) return 0;
        vector<Bucket> buckets(len);
        for (int n : nums) {
            Bucket& b = buckets[(n-in) / gap];
            b.max = max(n, b.max); b.min = min(n, b.min);
            b.flag = true;
        }
        int result = 0, prev = in;
        for (Bucket& b : buckets) {
            if (!b.flag) continue;
            result = max(result, b.min-prev);
            prev = b.max;
        }
        return result;
    }
};
```


"
0162 Find Peak Element;"https://leetcode.com/problems/find-peak-element/description/

* algorithms
* Medium (40.76%)
* Total Accepted:    219.5K
* Total Submissions: 538.3K
* Testcase Example:  '[1,2,3,1]'

A peak element is an element that is greater than its neighbors.

Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that nums[-1] = nums[n] = -∞.

Example 1:


Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.

Example 2:


Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5 
Explanation: Your function can return either index number 1 where the peak element is 2, 
             or index number 5 where the peak element is 6.


Note:

Your solution should be in logarithmic complexity.






";"
一遍过，类似二分的思路，如果右边有必当前值大的，那么右边就存在peak，同理左边也是，反正只要搜一边就可以了。如果两边都比当前小，那当前就是了。注意要判断索引的位置，同样如果当前是唯一的数字，那么当前就是peak。题目中的nums[i] != nums[i+1]条件很重要，不然就要用深搜了。

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int lo = 0, hi = nums.size(), len = nums.size(), mi;
        while (lo < hi) {
            mi = (lo + hi) >> 1;
            if (mi<=len-2 && nums[mi]<nums[mi+1]) {
                lo = mi+1;
            } else if (mi>=1 && nums[mi]<nums[mi-1]) {
                hi = mi;
            }  else {
                return mi;
            }
        }
    }
};
```


"
0160 Intersection of Two Linked Lists;"https://leetcode.com/problems/intersection-of-two-linked-lists/description/

* algorithms
* Easy (32.40%)
* Total Accepted:    276.2K
* Total Submissions: 852.1K
* Testcase Example:  '8\n[4,1,8,4,5]\n[5,0,1,8,4,5]\n2\n3'

Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:


begin to intersect at node c1.

 

Example 1:



Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
Output: Reference of the node with value = 8
Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.

 

Example 2:



Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Reference of the node with value = 2
Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.


 

Example 3:



Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Output: null
Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.


 

Notes:


	If the two linked lists have no intersection at all, return null.
	The linked lists must retain their original structure after the function returns.
	You may assume there are no cycles anywhere in the entire linked structure.
	Your code should preferably run in O(n) time and use only O(1) memory.







";"
一遍过，计算二者的长度，然后根据尾部是否相等来判断是否存在交叉节点，最后根据m-n的差值对齐位置，在通过p == q就能找到交叉节点了。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p = headA, *q = headB;
        int m = 0; while (p) p = p->next, m++;
        int n = 0; while (q) q = q->next, n++;
        if (p != q) return NULL;
        p = headA, q = headB;
        if (m < n) swap(p, q), swap(m, n);
        for (int i=0; i<m-n; i++) p = p->next;
        while (p != q) p = p->next, q = q->next;
        return p;
    }
};
```
"
0155 Min Stack;"https://leetcode.com/problems/min-stack/description/

* algorithms
* Easy (35.74%)
* Total Accepted:    272K
* Total Submissions: 760.5K
* Testcase Example:  '[""MinStack"",""push"",""push"",""push"",""getMin"",""pop"",""top"",""getMin""]\n[[],[-2],[0],[-3],[],[],[],[]]'


Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.


push(x) -- Push element x onto stack.


pop() -- Removes the element on top of the stack.


top() -- Get the top element.


getMin() -- Retrieve the minimum element in the stack.




Example:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.







";"
```cpp
/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
class MinStack {
    stack<int> s, ms;
public:
    /** initialize your data structure here. */
    MinStack() {
        
    }
    
    void push(int x) {
        s.push(x);
        if (ms.empty() || x <= ms.top()) ms.push(x);
    }
    
    void pop() {
        if (s.top() == ms.top()) ms.pop();
        s.pop();
    }
    
    int top() {
        return s.top();
    }
    
    int getMin() {
        return ms.top();
    }
};
```


"
0154 Find Minimum in Rotated Sorted Array II;"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/

* algorithms
* Hard (38.99%)
* Total Accepted:    122.1K
* Total Submissions: 313.1K
* Testcase Example:  '[1,3,5]'

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

The array may contain duplicates.

Example 1:


Input: [1,3,5]
Output: 1

Example 2:


Input: [2,2,2,0,1]
Output: 0

Note:


	This is a follow up problem to Find Minimum in Rotated Sorted Array.
	Would allow duplicates affect the run-time complexity? How and why?







";"
一遍过，类似153的思路，进行搜索，唯一要注意的是如果nums[mi] == nums[lo]是无法判断当前是在前半部分还是后半部分的，这时把lo++就行了，发展nums[mi] == nums[lo]，不用担心把最小值给排除在外了。

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1, mi;
        while (lo < hi) {
            if (nums[lo] < nums[hi]) break;
            mi = (lo + hi) >> 1;
            if (nums[mi] == nums[lo]) {
                lo++;
            } else if (nums[mi] > nums[lo]) {
                lo = mi+1;
            } else {
                hi = mi;
            }
        }
        return nums[lo];
    }
};
```


"
0153 Find Minimum in Rotated Sorted Array;"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/

* algorithms
* Medium (42.49%)
* Total Accepted:    261.6K
* Total Submissions: 615.6K
* Testcase Example:  '[3,4,5,1,2]'

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

You may assume no duplicate exists in the array.

Example 1:


Input: [3,4,5,1,2] 
Output: 1


Example 2:


Input: [4,5,6,7,0,1,2]
Output: 0







";"
每次折半查找都会有三种情况，第一[lo, hi]是顺序的，那么直接去nums[lo]即可。第二当前处于前半部分，那么最小值在[mi+1, hi]中，第三当前处于后半部分，那么最小值存在在[lo, mi]当中，注意这时是不能排除mi的，因为可能mi就是最小值。这也是为什么边界用闭闭区间的原因。其实用开闭区间也可以的，只是要判断`while (lo < hi-1)`。

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        if (nums.empty()) return 0;
        int lo = 0, hi = nums.size()-1, mi = 0;
        while (lo < hi) {
            if (nums[lo] < nums[hi]) break;
            mi = (lo + hi) >> 1;
            if (nums[mi] >= nums[lo]) {
                lo = mi+1;
            } else {
                hi = mi;
            }
        }
        return nums[lo];
    }
};
```


"
0152 Maximum Product Subarray;"https://leetcode.com/problems/maximum-product-subarray/description/

* algorithms
* Medium (28.58%)
* Total Accepted:    191.7K
* Total Submissions: 670.5K
* Testcase Example:  '[2,3,-2,4]'

Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:


Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.


Example 2:


Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.







";"
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int mx = 1, mn = 1, result = INT_MIN;
        for (auto n : nums) {
            int a = mx, b = mn;
            mx = max(max(a*n, b*n), n);
            mn = min(min(a*n, b*n), n);
            result = max(mx, result);
        }
        return result;
    }
};
```


"
0151 Reverse Words in a String;"https://leetcode.com/problems/reverse-words-in-a-string/description/

* algorithms
* Medium (15.94%)
* Total Accepted:    260.2K
* Total Submissions: 1.6M
* Testcase Example:  '""the sky is blue""'

Given an input string, reverse the string word by word.

 

Example 1:


Input: ""the sky is blue""
Output: ""blue is sky the""


Example 2:


Input: ""  hello world!  ""
Output: ""world! hello""
Explanation: Your reversed string should not contain leading or trailing spaces.


Example 3:


Input: ""a good   example""
Output: ""example good a""
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.


 

Note:


	A word is defined as a sequence of non-space characters.
	Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.
	You need to reduce multiple spaces between two words to a single space in the reversed string.


 

Follow up:

For C programmers, try to solve it in-place in O(1) extra space.





";"
```cpp
class Solution {
public:
    void reverseWords(string &s) {
        if (s.length() == 0) return ;
        s.push_back(' ');
        int l=0, r=0; char pre = ' '; char cur;
        for (int i=0; i<s.length(); i++) {
        	cur = s[i];
        	if (cur != ' ') {
        		if (pre == ' ') l = r;
        		s[r++] = cur;
        	} else if (pre != ' ') {
        		reverse(s.begin()+l, s.begin()+r);
        		s[r++] = ' ';
        	}
        	pre = cur;
        }
        if (r >= 1) r--;
        s.erase(r, s.length()-r);
        reverse(s.begin(), s.end());
    }
};
```


"
0150 Evaluate Reverse Polish Notation;"https://leetcode.com/problems/evaluate-reverse-polish-notation/description/

* algorithms
* Medium (31.40%)
* Total Accepted:    151.1K
* Total Submissions: 481K
* Testcase Example:  '[""2"",""1"",""+"",""3"",""*""]'

Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:


	Division between two integers should truncate toward zero.
	The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.


Example 1:


Input: [""2"", ""1"", ""+"", ""3"", ""*""]
Output: 9
Explanation: ((2 + 1) * 3) = 9


Example 2:


Input: [""4"", ""13"", ""5"", ""/"", ""+""]
Output: 6
Explanation: (4 + (13 / 5)) = 6


Example 3:


Input: [""10"", ""6"", ""9"", ""3"", ""+"", ""-11"", ""*"", ""/"", ""*"", ""17"", ""+"", ""5"", ""+""]
Output: 22
Explanation: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22







";"
注意a和b的顺序，是b先出栈，a后出栈。注意存在""-11""这种数字。

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        if (tokens.empty()) return 0;
        stack<int> s;
        for (string& token : tokens) {
            char ch = token[0];
            if (token.length() > 1 || isdigit(ch)) {
                int i = 0; if (ch == '-') i = 1;
                int n = 0; for (;i<token.length(); i++) n = n*10 + token[i]-'0';
                if (ch == '-') n = -n;
                s.push(n);
                continue;
            }
            int b = s.top(); s.pop();
            int a = s.top(); s.pop();
            int c;
            switch(ch) {
                case '+': c = a + b; break;
                case '-': c = a - b; break;
                case '*': c = a * b; break;
                case '/': c = a / b; break;
            }
            s.push(c);
        }
        return s.top();
    }
};
```


"
0149 Max Points on a Line;"https://leetcode.com/problems/max-points-on-a-line/description/

* algorithms
* Hard (15.56%)
* Total Accepted:    113.4K
* Total Submissions: 728.4K
* Testcase Example:  '[[1,1],[2,2],[3,3]]'

Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.

Example 1:


Input: [[1,1],[2,2],[3,3]]
Output: 3
Explanation:
^
|
|        o
|     o
|  o  
+------------->
0  1  2  3  4


Example 2:


Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
Explanation:
^
|
|  o
|     o        o
|        o
|  o        o
+------------------->
0  1  2  3  4  5  6







";"
```cpp
/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
class Solution {
public:
    int maxPoints(vector<Point>& points) {
        if (points.size() <= 2) return points.size();
        unordered_map<double, int> slopes; int len = points.size();
        int result = 0;
        for (int i=0; i<len-1; i++) {
            slopes.clear(); int samept = 0, maxpt = 1;
            for (int j=i+1; j<len; j++) {
                double slope = 0;
                if      (points[i].x != points[j].x) slope = (points[i].y-points[j].y)*1.0/(points[i].x-points[j].x);
                else if (points[i].y != points[j].y) slope = std::numeric_limits<double>::infinity();
                else                                 { samept++; continue; }
                int count = slopes[slope]; count = count==0 ? 2 : count+1; slopes[slope] = count;
                if (count > maxpt) maxpt = count;
            }
            if (result < maxpt+samept) result = maxpt+samept;
        }
        return result;
    }
};
```


"
0148 Sort List;"https://leetcode.com/problems/sort-list/description/

* algorithms
* Medium (34.02%)
* Total Accepted:    171.4K
* Total Submissions: 503.5K
* Testcase Example:  '[4,2,1,3]'

Sort a linked list in O(n log n) time using constant space complexity.

Example 1:


Input: 4->2->1->3
Output: 1->2->3->4


Example 2:


Input: -1->5->3->4->0
Output: -1->0->3->4->5






";"
quicksort，list版本的快排，用的算法导论的版本，不过将尾部取x值改成从第一个位置取x值。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        sortList(head, NULL);
        return head;
    }

    void sortList(ListNode *head, ListNode *rear) {
        if (head == rear || head->next == rear) return;
        int x = head->val; auto q = head;
        for (auto p = head; p != rear; p = p->next) {
            if (p->val < x) {
                q = q->next;
                swap(p->val, q->val);
            }
        }
        swap(head->val, q->val);
        sortList(head   , q   );
        sortList(q->next, rear);
    }
};
```

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *sortList(ListNode *head) {
        ListNode *mi = head, *hi = head;
        int n = 0;
        while (hi != NULL && hi->next != NULL) {
            n++;
            mi = mi->next;
            hi = hi->next->next;
        }
        
        // less than one node
        if (n == 0) 
            return head;
            
        if (n == 1) 
            mi = head;
        
        ListNode *lo = head;
        hi = mi->next;
        mi->next = NULL;
        lo = sortList(lo);
        hi = sortList(hi);
        
        ListNode dummy(0);
        ListNode *rt = &dummy;
        ListNode *it = rt;
        while (lo != NULL && hi != NULL) {
            if (lo->val < hi->val) {
                it->next = lo;
                lo = lo->next;
            } else {
                it->next = hi;
                hi = hi->next;
            }
            it = it->next;
        }
        
        if (lo) 
            it->next = lo;
        else if (hi)
            it->next = hi;
        
        head = rt->next;
    }
};
```


"
0147 Insertion Sort List;"https://leetcode.com/problems/insertion-sort-list/description/

* algorithms
* Medium (36.44%)
* Total Accepted:    142.2K
* Total Submissions: 390K
* Testcase Example:  '[4,2,1,3]'

Sort a linked list using insertion sort.





A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.
With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list
 




Algorithm of Insertion Sort:


	Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.
	At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.
	It repeats until no input elements remain.



Example 1:


Input: 4->2->1->3
Output: 1->2->3->4


Example 2:


Input: -1->5->3->4->0
Output: -1->0->3->4->5








";"
用链表实现插入排序，要注意用`p->next`和`q->next`，因为需要移动节点。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode dummy(0); dummy.next = head;
        auto q = head, p = &dummy;
        while (q->next) {
            for (p = &dummy; p->next != q->next; p = p->next) 
                if (p->next->val > q->next->val) break;
            if (p->next == q->next) { q = q->next; continue; }
            auto tmp = q->next; q->next = q->next->next;
            tmp->next = p->next; p->next = tmp;
        }
        return dummy.next;
    }
};
```


"
0146 LRU Cache;"https://leetcode.com/problems/lru-cache/description/

* algorithms
* Hard (24.11%)
* Total Accepted:    265.3K
* Total Submissions: 1.1M
* Testcase Example:  '[""LRUCache"",""put"",""put"",""get"",""put"",""get"",""put"",""get"",""get"",""get""]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]'


Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.



get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.


Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4







";"
```cpp
class LRUCache {
public:
    LRUCache(int capacity) {
        this->capacity = capacity;
    }
    
    int get(int key) {
        auto it = tbl_.find(key);
        if (it == end(tbl_)) return -1;
        lst_.splice(lst_.begin(), lst_, it->second);
        return it->second->val;
    }
    
    void put(int key, int val) {
        auto it = tbl_.find(key);
        if (it == end(tbl_)) {
            if (lst_.size() >= capacity) {
                tbl_.erase(lst_.back().key);
                lst_.pop_back();
            }
            lst_.emplace_front(key, val);
            tbl_.insert({key, lst_.begin()});
        } else {
            it->second->val = val;
            lst_.splice(lst_.begin(), lst_, it->second);
            tbl_[key] = lst_.begin();
        }
    }
private:
    struct Node {
        int key, val;
        Node(int k, int v) : key(k), val(v) {}
    };
    list<Node> lst_;
    unordered_map<int, list<Node>::iterator> tbl_;
    int capacity;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```


"
0145 Binary Tree Postorder Traversal;"https://leetcode.com/problems/binary-tree-postorder-traversal/description/

* algorithms
* Hard (46.99%)
* Total Accepted:    238.3K
* Total Submissions: 507.1K
* Testcase Example:  '[1,null,2,3]'

Given a binary tree, return the postorder traversal of its nodes' values.

Example:


Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]


Follow up: Recursive solution is trivial, could you do it iteratively?






";"
```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void postorderTraversal(TreeNode *node, vector<int>& result) {
        if (!node) return;
        postorderTraversal(node->left , result);
        postorderTraversal(node->right, result);
        result.push_back(node->val);
    }
    
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> result; if (!root) return result;
        postorderTraversal(root, &result);
        return result;
    }
};
```


"
0144 Binary Tree Preorder Traversal;"https://leetcode.com/problems/binary-tree-preorder-traversal/description/

* algorithms
* Medium (50.32%)
* Total Accepted:    308.4K
* Total Submissions: 612.7K
* Testcase Example:  '[1,null,2,3]'

Given a binary tree, return the preorder traversal of its nodes' values.

Example:


Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]


Follow up: Recursive solution is trivial, could you do it iteratively?







";"
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode *> s; vector<int> result; auto p = root;
        while (!s.empty() || !p) {
            if (p) {
                result.push_back(p->val);
                s.push(p);
                p = p->left;
            } else {
                p = s.top(); 
                p = p->right;
                s.pop();
            }
        }
        return result;
    }
};
```


"
0143 Reorder List;"https://leetcode.com/problems/reorder-list/description/

* algorithms
* Medium (29.87%)
* Total Accepted:    143.8K
* Total Submissions: 481.5K
* Testcase Example:  '[1,2,3,4]'

Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You may not modify the values in the list's nodes, only nodes itself may be changed.

Example 1:


Given 1->2->3->4, reorder it to 1->4->2->3.

Example 2:


Given 1->2->3->4->5, reorder it to 1->5->2->4->3.







";"
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        // len.
        int len=0; ListNode *p1=head, *p2=head;
        while (p1 != nullptr) { p1 = p1->next; len++; }
        if (len <= 2) return ;
        // spilt.
        int mid = (len+1) / 2;
        p1 = head;
        for (int i=0; i<mid-1; i++) p1 = p1->next;
        p2 = p1->next; p1->next = nullptr;
        // reverse.
        if (len-mid > 1) {
            p1 = p2; p2 = p1->next; p1->next = nullptr; ListNode *p3 = p2->next;
            while (p3 != nullptr) { p2->next = p1; p1 = p2; p2 = p3; p3 = p3->next; }
            p2->next = p1;
        }
        // merge.
        p1 = head;
        ListNode dummy(0), *p = &dummy; p->next = nullptr;
        for (int i=0; i<len-mid; ++i) { 
            p->next = p1; p1 = p1->next; p = p->next; 
            p->next = p2; p2 = p2->next; p = p->next;
        }
        p->next = p1;
    }
};
```


"
0142 Linked List Cycle II;"https://leetcode.com/problems/linked-list-cycle-ii/description/

* algorithms
* Medium (30.98%)
* Total Accepted:    197.7K
* Total Submissions: 637.9K
* Testcase Example:  '[3,2,0,-4]\n1'

Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

Note: Do not modify the linked list.

 

Example 1:


Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.




Example 2:


Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.




Example 3:


Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.




 

Follow up:
Can you solve it without using extra space?






";"
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head) return NULL;
        auto p = head, q = head;
        while (1) {
            if (!p->next || !q->next || !q->next->next) return NULL;
            p = p->next; q = q->next->next;
            if (p == q) break;
        }
        int n = 1; p = p->next; while (p != q) { p = p->next; n++; } 
        p = q = head;
        for (int i=0; i<n; i++) q = q->next;
        while (p != q) { p = p->next; q = q->next; }
        return p;
    }
};
```

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head) 
            return NULL;
            
        ListNode *p1 = head, *p2 = head;
        
        while (true) {
            if (p1)
                p1 = p1->next;
            
            if (p2 && p2->next) 
                p2 = p2->next->next;
            
            if (p2 == NULL || p2->next == NULL || p1 == NULL) 
                return NULL; // No Cycle;
            
            if (p1 == p2) 
                break;
        }
        
        int n = 1;
        p1 = p1->next;
        while (p1 != p2) {
            p1 = p1->next;
            n++;
        }
        
        p1 = head; p2 = head;
        for (int i=0; i<n; i++) {
            p1 = p1->next;
        }
        
        while (p1 != p2) {
            p1 = p1->next;
            p2 = p2->next;
        }
        
        return p1;
    }
};
```


"
0141 Linked List Cycle;"https://leetcode.com/problems/linked-list-cycle/description/

* algorithms
* Easy (35.83%)
* Total Accepted:    366.8K
* Total Submissions: 1M
* Testcase Example:  '[3,2,0,-4]\n1'

Given a linked list, determine if it has a cycle in it.

To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

 


Example 1:


Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.






Example 2:


Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the first node.






Example 3:


Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.





 

Follow up:

Can you solve it using O(1) (i.e. constant) memory?







";"
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head) return false;
        auto p = head, q = head;
        while (1) {
            if (!p->next || !q->next || !q->next->next) return false;
            p = p->next; q = q->next->next;
            if (p == q) return true;
        }
    }
};
```

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (head == NULL) {
            return false;
        }
        
        ListNode *iter = head, *double_iter = head;
        
        while (true) {
            if (iter->next) {
                iter = iter->next;
            } else {
                return false;
            }
            
            if (double_iter->next && double_iter->next->next) {
                double_iter = double_iter->next->next;
            } else {
                return false;
            }
            
            if (iter == double_iter) {
                return true;
            }
        }
    }
};
```


"
0140 Word Break II;"https://leetcode.com/problems/word-break-ii/description/

* algorithms
* Hard (26.70%)
* Total Accepted:    148.7K
* Total Submissions: 556.7K
* Testcase Example:  '""catsanddog""\n[""cat"",""cats"",""and"",""sand"",""dog""]'

Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.

Note:


	The same word in the dictionary may be reused multiple times in the segmentation.
	You may assume the dictionary does not contain duplicate words.


Example 1:


Input:
s = ""catsanddog""
wordDict = [""cat"", ""cats"", ""and"", ""sand"", ""dog""]
Output:
[
  ""cats and dog"",
  ""cat sand dog""
]


Example 2:


Input:
s = ""pineapplepenapple""
wordDict = [""apple"", ""pen"", ""applepen"", ""pine"", ""pineapple""]
Output:
[
  ""pine apple pen apple"",
  ""pineapple pen apple"",
  ""pine applepen apple""
]
Explanation: Note that you are allowed to reuse a dictionary word.


Example 3:


Input:
s = ""catsandog""
wordDict = [""cats"", ""dog"", ""sand"", ""and"", ""cat""]
Output:
[]







";"
```cpp
class Solution {
public:
    vector<string> wordBreak(string &s, unordered_set<string>& dict) {
        TrieNode root, *node;
        for (auto &word : dict) {
            node = &root;
            for (auto c=word.rbegin(); c!=word.rend(); c++) {
                int i = *c - 'a';
                if (node->next[i] == nullptr) node->next[i] = new TrieNode();
                node = node->next[i];
            }
            node->flag = 1;
        }
        
        int len = s.length(); vector<vector<int>> next(len, vector<int>());
        for (int h=len-1; h>=0; h--) {
            node = &root;
            if (h==len-1 || !next[h+1].empty()) for (int l=h; l>=0; l--) {
                int i = s[l] - 'a';
                if (node->next[i] == nullptr) break;
                node = node->next[i];
                if (node->flag == 1) next[l].push_back(h);
            }
        }
        
        vector<string> result; string path;
        buildSentences(s, next, 0, path, result);
        return move(result);
    }
    
    void buildSentences(string &s, vector<vector<int>>& next, int l, string& path, vector<string>& result) {
        if (l == s.length()) { path.pop_back(); result.push_back(move(path)); return ; }
        for (auto h : next[l]) {
            string newp = path; newp.append(s.substr(l,h-l+1)); newp.push_back(' ');
            buildSentences(s, next, h+1, newp, result);
        }
    }
    
    struct TrieNode {
        int flag; TrieNode *next[26];
        TrieNode() { flag = 0; fill_n(next, 26, nullptr); }
        ~TrieNode() { for (auto p : next) if (p) delete p; } 
    };
};
```
"
0139 Word Break;"https://leetcode.com/problems/word-break/description/

* algorithms
* Medium (34.40%)
* Total Accepted:    306.1K
* Total Submissions: 889.5K
* Testcase Example:  '""leetcode""\n[""leet"",""code""]'

Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:


	The same word in the dictionary may be reused multiple times in the segmentation.
	You may assume the dictionary does not contain duplicate words.


Example 1:


Input: s = ""leetcode"", wordDict = [""leet"", ""code""]
Output: true
Explanation: Return true because ""leetcode"" can be segmented as ""leet code"".


Example 2:


Input: s = ""applepenapple"", wordDict = [""apple"", ""pen""]
Output: true
Explanation: Return true because ""applepenapple"" can be segmented as ""apple pen apple"".
             Note that you are allowed to reuse a dictionary word.


Example 3:


Input: s = ""catsandog"", wordDict = [""cats"", ""dog"", ""sand"", ""and"", ""cat""]
Output: false







";"
```cpp
class Solution {
public:
    bool wordBreak(string &s, unordered_set<string>& dict) {
        TrieNode root, *node;
        for (auto& word : dict) {
            node = &root;
            for (auto c : word) {
                char i = c - 'a';
                if (node->next[i] == nullptr) node->next[i] = new TrieNode;
                node = node->next[i];
            }
            node->flag = 1;
        }
        
        int len = s.length(); vector<vector<int>> prev(len, vector<int>());
        for (int l=0; l<len; l++) {
            node = &root;
            if (l==0 || !prev[l-1].empty()) for (int h=l; h<len; h++) {
                char i = s[h] - 'a';
                if (node->next[i] == nullptr) break;
                node = node->next[i];
                if (node->flag == 1) {
                    prev[h].push_back(l);
                    if (h==len-1) return true;
                }
            }
        }
        
        return false;
    }
    
    struct TrieNode {
        int flag; TrieNode* next[26];
        TrieNode() { flag = 0; fill_n(next, 26, nullptr); }
        ~TrieNode() { for(auto node : next) if (node) delete node; }
    };
};
```


"
0138 Copy List with Random Pointer;"https://leetcode.com/problems/copy-list-with-random-pointer/description/

* algorithms
* Medium (25.83%)
* Total Accepted:    225.3K
* Total Submissions: 872K
* Testcase Example:  '{""$id"":""1"",""next"":{""$id"":""2"",""next"":null,""random"":{""$ref"":""2""},""val"":2},""random"":{""$ref"":""2""},""val"":1}'

A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

Return a deep copy of the list.

 

Example 1:




Input:
{""$id"":""1"",""next"":{""$id"":""2"",""next"":null,""random"":{""$ref"":""2""},""val"":2},""random"":{""$ref"":""2""},""val"":1}

Explanation:
Node 1's value is 1, both of its next and random pointer points to Node 2.
Node 2's value is 2, its next pointer points to null and its random pointer points to itself.


 

Note:


	You must return the copy of the given head as a reference to the cloned list.







";"
跟cloneGraph那题有点类似。还有个思路是穿插节点 A -> B -> A -> B -> ...这种的，然后将random指针设置正确，在分割链表。

```cpp
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        unordered_map<RandomListNode*, RandomListNode*> tbl;
        auto it = end(tbl); RandomListNode dummy(0); auto p = head, q = &dummy;
        while (p) {
            it = tbl.find(p);
            if (it != end(tbl)) q->next = it->second;
            else                tbl[p] = q->next = new RandomListNode(p->label);
            q = q->next;
            if (!p->random) { p = p->next; continue; }
            it = tbl.find(p->random);
            if (it != end(tbl)) q->random = it->second;
            else                tbl[p->random] = q->random = new RandomListNode(p->random->label);
            p = p->next;
        }
        return dummy.next;
    }
};
```


"
0137 Single Number II;"https://leetcode.com/problems/single-number-ii/description/

* algorithms
* Medium (45.19%)
* Total Accepted:    158.7K
* Total Submissions: 351.2K
* Testcase Example:  '[2,2,3,2]'

Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:


Input: [2,2,3,2]
Output: 3


Example 2:


Input: [0,1,0,1,0,1,99]
Output: 99






";"
```cpp
class Solution {
public:
    int singleNumber(int A[], int n) {
        int ones = 0, twos = 0, threes = 0;
        
        for (int i=0; i<n; i++) {
            twos = twos | (ones & A[i]);
            ones = ones ^ A[i];
            threes = ones & twos;
            
            ones = ones & (~threes);
            twos = twos & (~threes);
        }
        
        return ones;
    }
};
```


"
0136 Single Number;"https://leetcode.com/problems/single-number/description/

* algorithms
* Easy (59.09%)
* Total Accepted:    421.8K
* Total Submissions: 713.5K
* Testcase Example:  '[2,2,1]'

Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:


Input: [2,2,1]
Output: 1


Example 2:


Input: [4,1,2,1,2]
Output: 4








";"
```cpp
#include <map>

using namespace std;

typedef map<int, int> iimap;
typedef map<int, int>::iterator ITER;

class Solution {
public:
    int singleNumber(int A[], int n) {
        // IMPORTANT: Please reset any member data you declared, as
        // the same Solution instance will be reused for each test case.
       int x = 0;
       for (int i=0; i<n; i++) {
           x ^= A[i];
       }
       return x;
    }
};
```



"
0135 Candy;"https://leetcode.com/problems/candy/description/

* algorithms
* Hard (27.76%)
* Total Accepted:    97.2K
* Total Submissions: 350.2K
* Testcase Example:  '[1,0,2]'

There are N children standing in a line. Each child is assigned a rating value.

You are giving candies to these children subjected to the following requirements:


	Each child must have at least one candy.
	Children with a higher rating get more candies than their neighbors.


What is the minimum candies you must give?

Example 1:


Input: [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.


Example 2:


Input: [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
             The third child gets 1 candy because it satisfies the above two conditions.







";"
1384ms，感觉用深搜即慢又复杂，emmm。。。还是看看别人的思路吧。不过居然被我硬搜出来了，不容易啊。

```cpp
class Solution {
public:
    int candy(vector<int>& R) {
        int _ = 0, sum = 0;
        candy(R, 0, R.size(), _, _, sum);
        return sum;
    }

    void candy(vector<int>& R, int lo, int hi, int& l, int& r, int& sum) {
        if (hi-lo == 0) { l = 0; r = 0; sum = 0; return; }
        if (hi-lo == 1) { l = 1; r = 1; sum = 1; return; }
        int mi=lo; for (int i=lo; i<hi; i++) if (R[i] > R[mi]) mi = i;
        int lsum=0, rsum=0, num=1, ll, lr, rl, rr;
        candy(R, lo  , mi, ll, lr, lsum);
        candy(R, mi+1, hi, rl, rr, rsum);
        if (mi-1>=lo && R[mi]>R[mi-1]) num = max(num, lr + 1);
        if (mi+1< hi && R[mi]>R[mi+1]) num = max(num, rl + 1);
        l = ll, r = rr;
        if (mi == lo  ) l = num;
        if (mi == hi-1) r = num;
        sum = lsum + num + rsum;
    }
};
```

现在ltor遍历一遍，保证左边ok，在rtol遍历一遍，保证右边ok，emmm...，fair simple.

```cpp
class Solution {
public:
    int candy(vector<int>& R) {
        int N = R.size(); vector<int> nums(N, 1);
        for (int i=1; i<N; i++) 
            if (R[i] > R[i-1]) nums[i] = nums[i-1] + 1;
        for (int i=N-2; i>=0; i--) 
            if (R[i] > R[i+1]) nums[i] = max(nums[i+1]+1, nums[i]);
        int sum = 0; for (auto n : nums) sum += n;
        return sum;
    }
};
```


"
0134 Gas Station;"https://leetcode.com/problems/gas-station/description/

* algorithms
* Medium (32.95%)
* Total Accepted:    133.6K
* Total Submissions: 405.3K
* Testcase Example:  '[1,2,3,4,5]\n[3,4,5,1,2]'

There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.

Note:


	If there exists a solution, it is guaranteed to be unique.
	Both input arrays are non-empty and have the same length.
	Each element in the input arrays is a non-negative integer.


Example 1:


Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.


Example 2:


Input: 
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.







";"
遍历，考察细节的，边界要注意要，尤其是`j<=N`和 `if (j>N) return i;`

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int N = gas.size();
        for (int i=0, j, tank; i<N; i++) {
            for (j=0, tank=0; j<=N; j++) {
                int curr = (j+i) % N;
                tank += gas[curr]; tank -= cost[curr];
                if (tank < 0) break;
            }
            if (j > N) return i;
        }
        return -1;
    }
};
```


"
0133 Clone Graph;"https://leetcode.com/problems/clone-graph/description/

* algorithms
* Medium (25.31%)
* Total Accepted:    200.9K
* Total Submissions: 793.2K
* Testcase Example:  '{""$id"":""1"",""neighbors"":[{""$id"":""2"",""neighbors"":[{""$ref"":""1""},{""$id"":""3"",""neighbors"":[{""$ref"":""2""},{""$id"":""4"",""neighbors"":[{""$ref"":""3""},{""$ref"":""1""}],""val"":4}],""val"":3}],""val"":2},{""$ref"":""4""}],""val"":1}'

Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.

 

Example:




Input:
{""$id"":""1"",""neighbors"":[{""$id"":""2"",""neighbors"":[{""$ref"":""1""},{""$id"":""3"",""neighbors"":[{""$ref"":""2""},{""$id"":""4"",""neighbors"":[{""$ref"":""3""},{""$ref"":""1""}],""val"":4}],""val"":3}],""val"":2},{""$ref"":""4""}],""val"":1}

Explanation:
Node 1's value is 1, and it has two neighbors: Node 2 and 4.
Node 2's value is 2, and it has two neighbors: Node 1 and 3.
Node 3's value is 3, and it has two neighbors: Node 2 and 4.
Node 4's value is 4, and it has two neighbors: Node 1 and 3.


 

Note:


	The number of nodes will be between 1 and 100.
	The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.
	Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.
	You must return the copy of the given node as a reference to the cloned graph.







";"
深搜，然后用一个map记录已经克隆过的节点，并做一个映射。

```cpp
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
typedef unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> UndirectedGraphNodeMap;

class Solution {
public:
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        if (!node) return NULL;
        UndirectedGraphNodeMap tbl;
        return cloneGraph(node, tbl);
    }
    
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node, UndirectedGraphNodeMap& tbl) {
        auto it = tbl.find(node);
        if (it != end(tbl)) return it->second;
        UndirectedGraphNode *clone = new UndirectedGraphNode(node->label);
        tbl[node] = clone;
        for (auto neighbor : node->neighbors) 
            clone->neighbors.push_back(cloneGraph(neighbor, tbl));
        return clone;
    }
};
```


"
0132 Palindrome Partitioning II;"https://leetcode.com/problems/palindrome-partitioning-ii/description/

* algorithms
* Hard (26.75%)
* Total Accepted:    97.6K
* Total Submissions: 364.6K
* Testcase Example:  '""aab""'

Given a string s, partition s such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of s.

Example:


Input: ""aab""
Output: 1
Explanation: The palindrome partitioning [""aa"",""b""] could be produced using 1 cut.







";"
两次dp，第一次计算回文子串，每次计算出来一个回文子串，就更新mincut[h]。

```cpp
class Solution {
public:
    int minCut(string& s) {
        const int len = s.length(); int cut[len]; vector<vector<int>> f(len, vector<int>(len, 0));
        for (int i=0; i<len; i++) cut[i] = i;
        for (int h=0; h<len; h++) for (int l=0; l<=h; l++) {
            f[l][h] = s[l]==s[h] && (h-l<2 || f[l+1][h-1]);
            if (f[l][h]) cut[h] = l==0 ? 0 : min(cut[h], cut[l-1]+1);
        }
        return cut[len-1];
    }
};
```


"
0131 Palindrome Partitioning;"https://leetcode.com/problems/palindrome-partitioning/description/

* algorithms
* Medium (39.67%)
* Total Accepted:    153.1K
* Total Submissions: 385.7K
* Testcase Example:  '""aab""'

Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:


Input: ""aab""
Output:
[
  [""aa"",""b""],
  [""a"",""a"",""b""]
]








";"
先dp算出所有的回文子串，然后再深搜即可。

```cpp
class Solution {
public:
    vector<vector<string>> partition(string& s) {
        const int N = s.length();
        vector<vector<int>> f(N, vector<int>(N, 0));
        for (int j=0; j<N; j++) for (int i=0; i<=j; i++) {
            f[i][j] = s[i] == s[j] && ((j-i<=2) || f[i+1][j-1]);
        }
        vector<vector<string>> result; vector<string> path;
        partition(s, f, 0, path, result);
        return move(result);
    }

    void partition(string& s, vector<vector<int>>& f, int i, vector<string>& path, vector<vector<string>>& result) {
        if (i == s.length()) { result.push_back(path); return; } 
        for (int j=i; j<s.length(); j++) {
            if (!f[i][j]) continue;
            path.push_back(s.substr(i, j-i+1));
            partition(s, f, j+1, path, result);
            path.pop_back();
        }
    }
};
```


"
0130 Surrounded Regions;"https://leetcode.com/problems/surrounded-regions/description/

* algorithms
* Medium (22.15%)
* Total Accepted:    134.9K
* Total Submissions: 608.6K
* Testcase Example:  '[[""X"",""X"",""X"",""X""],[""X"",""O"",""O"",""X""],[""X"",""X"",""O"",""X""],[""X"",""O"",""X"",""X""]]'

Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

Example:


X X X X
X O O X
X X O X
X O X X


After running your function, the board should be:


X X X X
X X X X
X X X X
X O X X


Explanation:

Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.






";"
```cpp
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        if (board.size() <= 0) return ;
        int h = board.size(); int w = board[0].size();
        for (int i=0; i<w; i++) { BFS(board, 0, i); BFS(board, h-1, i  ); }
        for (int i=0; i<h; i++) { BFS(board, i, 0); BFS(board, i  , w-1); }
        for (int i=0; i<h; i++) for (int j=0; j<w; j++) {
            if      (board[i][j] == 'O') board[i][j] = 'X';
            else if (board[i][j] == '.') board[i][j] = 'O';
        }
    }
    
    void BFS(vector<vector<char>> &board, int i, int j) {
        queue<pair<int, int>> q;
        q.push({i, j});
        while (!q.empty()) {
            auto cur = q.front(); q.pop();
            int i = cur.first, j = cur.second;
            if (board[i][j] == 'O') board[i][j] = '.'; else continue ;
            if (i >= 1)                q.push({i-1, j  });
            if (j >= 1)                q.push({i  , j-1});
            if (i+1 < board.size())    q.push({i+1, j  });
            if (j+1 < board[0].size()) q.push({i  , j+1});
        }
    }
};
```


"
0129 Sum Root to Leaf Numbers;"https://leetcode.com/problems/sum-root-to-leaf-numbers/description/

* algorithms
* Medium (41.48%)
* Total Accepted:    173.2K
* Total Submissions: 417.5K
* Testcase Example:  '[1,2,3]'

Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

Note: A leaf is a node with no children.

Example:


Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.

Example 2:


Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.






";"
```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void sumNumbers(TreeNode *node, int num, int& sum) {
        num = num * 10 + node->val ;
        if (!node->left && !node->right) { sum += num; return; }
        if (node->left ) sumNumbers(node->left , num, sum);
        if (node->right) sumNumbers(node->right, num, sum);
    }
    
    int sumNumbers(TreeNode *root) {
        int sum = 0;
        if (root) sumNumbers(root, 0, sum);
        return sum;
    }
};
```


"
0128 Longest Consecutive Sequence;"https://leetcode.com/problems/longest-consecutive-sequence/description/

* algorithms
* Hard (40.94%)
* Total Accepted:    192.3K
* Total Submissions: 469.5K
* Testcase Example:  '[100,4,200,1,3,2]'

Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

Example:


Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.







";"
思路：下一个连续数字一定出现在边界，每次当前连续区间的边界的数值。上界下界和当前，当前是为了防止上界下界至少有一个不存在的情况，这样当前就是边界了。注意map的insert和operator[]的区别。

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int, int> tbl; int result = 0;
        for (int n : nums) {
            int up = 0, lo = 0; auto it = end(tbl);
            if (tbl.find(n  ) != end(tbl)) continue;
            if ((it = tbl.find(n+1)) != end(tbl)) up = it->second;
            if ((it = tbl.find(n-1)) != end(tbl)) lo = it->second;
            int sum = lo + up + 1;
            result = max(sum, result);
            // tbl.insert({{n+up, sum}, {n, sum}, {n-lo, sum}}); // Wrong Answer.
            tbl[n+up] = tbl[n] = tbl[n-lo] = sum;
        }
        return result;
    }
};
```


"
0127 Word Ladder;"https://leetcode.com/problems/word-ladder/description/

* algorithms
* Medium (23.03%)
* Total Accepted:    234K
* Total Submissions: 1M
* Testcase Example:  '""hit""\n""cog""\n[""hot"",""dot"",""dog"",""lot"",""log"",""cog""]'

Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:


	Only one letter can be changed at a time.
	Each transformed word must exist in the word list. Note that beginWord is not a transformed word.


Note:


	Return 0 if there is no such transformation sequence.
	All words have the same length.
	All words contain only lowercase alphabetic characters.
	You may assume no duplicates in the word list.
	You may assume beginWord and endWord are non-empty and are not the same.


Example 1:


Input:
beginWord = ""hit"",
endWord = ""cog"",
wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]

Output: 5

Explanation: As one shortest transformation is ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> ""cog"",
return its length 5.


Example 2:


Input:
beginWord = ""hit""
endWord = ""cog""
wordList = [""hot"",""dot"",""dog"",""lot"",""log""]

Output: 0

Explanation: The endWord ""cog"" is not in wordList, therefore no possible transformation.










";"
```cpp
class Solution {
public:
    int ladderLength(string& start, string& end, unordered_set<string>& words) {
        unordered_set<string> visited, curr, next;
        visited.insert(start), curr.insert(start);
        int depth = 1;
        while (!curr.empty()) {
            depth++;
            for (auto word : curr) {
                for (int i=0; i<word.size(); i++) for (char c='a'; c<='z'; c++) {
                    if (word[i] == c) continue;
                    swap(word[i], c);
                    if (word == end) return depth;
                    if (words.find(word)!=words.end() && visited.find(word)==visited.end()) next.insert(word);
                    swap(word[i], c);
                }
            }
            for (auto& word : next) visited.insert(word);
            curr.clear(); swap(curr, next);
        }
        return 0;
    }
};
```


"
0126 Word Ladder II;"https://leetcode.com/problems/word-ladder-ii/description/

* algorithms
* Hard (17.04%)
* Total Accepted:    111.1K
* Total Submissions: 651.5K
* Testcase Example:  '""hit""\n""cog""\n[""hot"",""dot"",""dog"",""lot"",""log"",""cog""]'

Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:


	Only one letter can be changed at a time
	Each transformed word must exist in the word list. Note that beginWord is not a transformed word.


Note:


	Return an empty list if there is no such transformation sequence.
	All words have the same length.
	All words contain only lowercase alphabetic characters.
	You may assume no duplicates in the word list.
	You may assume beginWord and endWord are non-empty and are not the same.


Example 1:


Input:
beginWord = ""hit"",
endWord = ""cog"",
wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]

Output:
[
  [""hit"",""hot"",""dot"",""dog"",""cog""],
  [""hit"",""hot"",""lot"",""log"",""cog""]
]


Example 2:


Input:
beginWord = ""hit""
endWord = ""cog""
wordList = [""hot"",""dot"",""dog"",""lot"",""log""]

Output: []

Explanation: The endWord ""cog"" is not in wordList, therefore no possible transformation.










";"
```cpp
class Solution {
public:
    vector<vector<string>> findLadders(string &start, string &end, unordered_set<string> &dict) {
        unordered_map<string, vector<string>> parent;
        unordered_set<string> curr, next, visited;
        int len = start.length(); 
        bool found = false;
        
        curr.insert(start); visited.insert(start);
        
        while (!curr.empty()) {
            for (auto& word : curr) {
                string w = word;
                for (int i=0; i<len; i++) for (char ch='a'; ch<='z'; ch++) {
                    if (ch == w[i]) continue;
                    swap(w[i], ch);
                    if (dict.find(w)!=dict.end() && visited.find(w)==visited.end()) {
                        next.insert(w);
                        parent[w].push_back(word);
                        if (w == end) found = true;
                    }
                    swap(w[i], ch);
                }
            }
            if (found) break;
            for (auto& word : next) visited.insert(word);
            curr.clear(); swap(curr, next);
        }
        
        vector<vector<string>> result; vector<string> path;
        genPath(start, end, parent, path, result);
        return result;
    }
    
    void genPath(string& target, string& word, unordered_map<string, vector<string>> &parent, 
                 vector<string> &path, vector<vector<string>> &result) {
        path.push_back(word);
        if (word == target) {
            result.push_back(path);
            reverse(result.back().begin(), result.back().end());
        }
        for (auto& w : parent[word]) genPath(target, w, parent, path, result);
        path.pop_back();
    }
};
```


"
0125 Valid Palindrome;"https://leetcode.com/problems/valid-palindrome/description/

* algorithms
* Easy (30.27%)
* Total Accepted:    325K
* Total Submissions: 1.1M
* Testcase Example:  '""A man, a plan, a canal: Panama""'

Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

Note: For the purpose of this problem, we define empty string as valid palindrome.

Example 1:


Input: ""A man, a plan, a canal: Panama""
Output: true


Example 2:


Input: ""race a car""
Output: false







";"
emmm, 提交错误次数有点多。最后看答案，才知道题目理解错了，`...,,,`这种不包含字符的，返回true。

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        int i = 0, j = s.length()-1;
        while (i < j) {
            while (i<j && !isalnum(s[i])) i++;
            while (i<j && !isalnum(s[j])) j--;
            if (tolower(s[i++]) != tolower(s[j--])) return false;
        }
        return true;
    }
};
```


"
0124 Binary Tree Maximum Path Sum;"https://leetcode.com/problems/binary-tree-maximum-path-sum/description/

* algorithms
* Hard (29.34%)
* Total Accepted:    174.6K
* Total Submissions: 595K
* Testcase Example:  '[1,2,3]'

Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:


Input: [1,2,3]

       1
      / \
     2   3

Output: 6


Example 2:


Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42








";"
分别计算左右子树的最大值和最大尾值，注意需要llast和rlast大于0才会更新last值，小于等于0的值，对于last值没有贡献。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        if (!root) return 0;
        int maxsum = 0, last = 0; 
        maxPathSum(root, maxsum, last);
        return maxsum;
    }

    void maxPathSum(TreeNode *node, int& maxsum, int& last) {
        if (!node) return;
        int nval = node->val;
        int lmax = INT_MIN, llast = 0;
        maxPathSum(node->left , lmax, llast);
        int rmax = INT_MIN, rlast = 0;
        maxPathSum(node->right, rmax, rlast);
        last = node->val; 
        if (llast > 0) last = max(llast+nval, last);
        if (rlast > 0) last = max(rlast+nval, last);
        maxsum = max({lmax, rmax, last, llast+nval+rlast}); 
    }
};
```

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        int maxsum = INT_MIN;
        DFS(root, maxsum);
        return maxsum;
    }
    
    int DFS(TreeNode *root, int& maxsum) {
        if (!root) return 0;
        int sum = root->val;
        int l = DFS(root->left, maxsum);
        int r = DFS(root->right, maxsum);
        if (l>0) sum += l;
        if (r>0) sum += r;
        maxsum = max(sum, maxsum);
        return max(l, r) > 0 ? max(l,r)+root->val : root->val;
    }
};
```


"
0123 Best Time to Buy and Sell Stock III;"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/

* algorithms
* Hard (32.97%)
* Total Accepted:    139.4K
* Total Submissions: 422.6K
* Testcase Example:  '[3,3,5,0,0,3,1,4]'

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:


Input: [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.

Example 2:


Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.


Example 3:


Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.






";"
ltor[i]表示prices[0, i)的最大profit，rtol[i]表示prices[i, n)的最大profit。然后计算两者之和即可。时间O(n)，空间O(n)。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size(), profit = 0;
        if (len == 0) return profit;
        vector<int> ltor(len+1, 0), rtol(len+1, 0);
        profit = 0;
        for (int i=1, buy=prices[0]; i<len; i++) {
            if (buy < prices[i]) profit = max(prices[i] - buy, profit);
            else                 buy = prices[i];
            ltor[i+1] = profit;
        }
        profit = 0;
        for (int i=len-2, sell=prices[len-1]; i>=0; i--) {
            if (sell > prices[i]) profit = max(sell - prices[i], profit);
            else                  sell = prices[i];
            rtol[i] = profit;
        }
        int result = 0;
        for (int i=0; i<len; i++) result = max(result, ltor[i] + rtol[i]);
        return result;
    }
};
```

discuss里的思路，初始为0，a表示[0, i) buy一股最多剩余的钱数，b表示[0, i) buy sell一股最多剩余的钱数，c表示[0, i) buy sell buy一股最多剩余的钱数，d表示[0, i) buy sell buy sell剩余最多的钱数。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size(), a=INT_MIN, b=0, c=INT_MIN, d=0;
        for (int i=0; i<len; i++) {
            d = max(d, c+prices[i]);
            c = max(c, b-prices[i]);
            b = max(b, a+prices[i]);
            a = max(a, 0-prices[i]);
        }
        return d;
    }
};
```


"
0122 Best Time to Buy and Sell Stock II;"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/

* algorithms
* Easy (50.96%)
* Total Accepted:    295.2K
* Total Submissions: 579K
* Testcase Example:  '[7,1,5,3,6,4]'

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:


Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.


Example 2:


Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.


Example 3:


Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.







";"
因为可以多个transaction，所以赚钱就卖就可以，贪心。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) return 0;
        int buy = prices[0], profit = 0;
        for (int i=0; i<prices.size(); i++) {
            if (buy < prices[i]) profit += prices[i] - buy;
            buy = prices[i];
        }
        return profit;
    }
};
```

```cpp
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int len = prices.size();
        int i = 2;
        if (i > len) {
            return 0;
        } 
        
        int hold = 0, cur = 0, pre = 0;
        int max_profit = 0;
        
        pre = prices[0];
        cur = prices[1];
        hold = pre;
        
        while (true) {
             while (pre >= cur) {
                if (i >= len) {
                    return max_profit;
                }
                pre = cur;
                cur = prices[i];
                i = i + 1;
                hold = pre;
             }
            
            while (pre <= cur) {
                if (i >= len) {
                    max_profit = max_profit + cur - hold;
                    return max_profit;
                }
                pre = cur;
                cur = prices[i];
                i = i + 1;
            }
            
            max_profit = max_profit + pre - hold;
        }
        
        return max_profit;
    }
};
```


"
0121 Best Time to Buy and Sell Stock;"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/

* algorithms
* Easy (46.29%)
* Total Accepted:    443.4K
* Total Submissions: 957.5K
* Testcase Example:  '[7,1,5,3,6,4]'

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:


Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.


Example 2:


Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.







";"
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) return 0;
        int buy = prices[0], profit = 0;
        for (int i=1; i<prices.size(); i++) {
            if (prices[i] > buy) profit = max(prices[i]-buy, profit);
            else                 buy    = prices[i];
        }
        return profit;
    }
};
```

4年前的答案

```cpp
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        if (prices.empty()) {
            return 0;
        }
        
        int min_price = prices[0], max_price = 0;
        int max_profit = 0;
        
        for (int i=0; i<prices.size(); i++) {
            if (prices[i] < min_price) {
                min_price = prices[i];
                max_price = min_price;
            }
            
            if (max_profit == 0) {
                if (i+1 < prices.size() && prices[i] < prices[i+1]) {
                    max_price = prices[i+1];
                    max_profit = prices[i+1] - prices[i];
                }
            }
            
            if (prices[i] > max_price) {
                max_price = prices[i];
                int new_profit = max_price - min_price;
                if (new_profit > max_profit) {
                    max_profit = new_profit;
                }
            }
        }
        
        return max_profit;
    }
};
```


"
0120 Triangle;"https://leetcode.com/problems/triangle/description/

* algorithms
* Medium (38.39%)
* Total Accepted:    170.4K
* Total Submissions: 443.8K
* Testcase Example:  '[[2],[3,4],[6,5,7],[4,1,8,3]]'

Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle


[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]


The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:

Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.







";"
深搜

超时了。

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if (triangle.empty()) return 0;
        vector<int> path; int result = INT_MAX;
        DFS(triangle, 0, 0, path, result);
        return result;
    }
    
    void DFS(vector<vector<int>>& triangle, int i, int j, vector<int>& path, int& result) {
        if (i == triangle.size()) {
            int sum = 0; for (auto n : path) sum += n;
            result = min(sum, result);
            return;
        }
        path.push_back(triangle[i][j]);
        DFS(triangle, i+1, j  , path, result);
        DFS(triangle, i+1, j+1, path, result);
        path.pop_back();
    }
};
```

自底向上就可以用贪心算法来做了，每次找level+1层相邻节点中较小的一个与level的节点相加，来计算level层所有的最小值。

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        vector<int> nums(triangle.back().size()+1, 0);
        for (int i=triangle.size()-1; i>=0; i--) for (int j=0; j<triangle[i].size(); j++) {
            nums[j] = min(nums[j], nums[j+1]) + triangle[i][j];
        }
        return nums[0];
    }
};
```
"
0119 Pascal's Triangle II;"https://leetcode.com/problems/pascals-triangle-ii/description/

* algorithms
* Easy (42.15%)
* Total Accepted:    186.8K
* Total Submissions: 443.1K
* Testcase Example:  '3'

Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.

Note that the row index starts from 0.


In Pascal's triangle, each number is the sum of the two numbers directly above it.

Example:


Input: 3
Output: [1,3,3,1]


Follow up:

Could you optimize your algorithm to use only O(k) extra space?






";"
```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> last = {1}; 
        for (int i=0; i<rowIndex; i++) {
            vector<int> curr(last.size()+1, 1);
            for (int j=1; j<curr.size()-1; j++) {
                curr[j] = last[j-1] + last[j];
            }
            swap(last, curr);
        }
        return move(last);
    }
};
```

```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> pascal;
        pascal.assign(rowIndex+1, 0);
        
        int hold_previous = 0;
        
        pascal[0] = 1;

        for (int i=1; i<=rowIndex; i++) {
            hold_previous = 1;
            for (int j=1; j<=i; j++) {
                int previous = hold_previous;
                hold_previous = pascal[j];
                pascal[j] = previous + pascal[j];
            }
        }
        
        return pascal;
    }
};
```


"
0118 Pascal's Triangle;"https://leetcode.com/problems/pascals-triangle/description/

* algorithms
* Easy (44.65%)
* Total Accepted:    230.5K
* Total Submissions: 516.1K
* Testcase Example:  '5'

Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.


In Pascal's triangle, each number is the sum of the two numbers directly above it.

Example:


Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]







";"
beat 12.3%, 4ms

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> result; if (numRows == 0) return result;
        result.push_back({1});
        for (int i=1; i<numRows; i++) {
            vector<int>& last = result.back();
            vector<int> curr(last.size()+1, 1);
            for (int j=1; j<curr.size()-1; j++) {
                curr[j] = last[j-1] + last[j];
            }
            result.push_back(move(curr));
        }
        return move(result);
    }
};
```

beat 100%, 0ms
```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> result; if (numRows == 0) return result;
        result.push_back({1});
        for (int i=1; i<numRows; i++) {
            vector<int>& last = result.back();
            vector<int> curr(last.size()+1, 1);
            for (int j=1; j<curr.size()-1; j++) {
                curr[j] = last[j-1] + last[j];
            }
            result.push_back(move(curr));
        }
        return move(result);
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int> > generate(int numRows) {
        vector<vector<int> > vvi;
        vvi.assign(numRows, vector<int>());
            
        for (int i=0; i<numRows; i++) {
            vector<int> vi;
            vi.assign(i+1, 0);
                
            vi[0] = 1;
            for (int j=1; j<i; j++) {
                vi[j] = vvi[i-1][j-1] + vvi[i-1][j];
            }
            vi[i] = 1;
                
            vvi[i].swap(vi);
        }
            
        return vvi;
    }
};
```


"
0117 Populating Next Right Pointers in Each Node II;"https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/

* algorithms
* Medium (33.53%)
* Total Accepted:    171K
* Total Submissions: 509.8K
* Testcase Example:  '{""$id"":""1"",""left"":{""$id"":""2"",""left"":{""$id"":""3"",""left"":null,""next"":null,""right"":null,""val"":4},""next"":null,""right"":{""$id"":""4"",""left"":null,""next"":null,""right"":null,""val"":5},""val"":2},""next"":null,""right"":{""$id"":""5"",""left"":null,""next"":null,""right"":{""$id"":""6"",""left"":null,""next"":null,""right"":null,""val"":7},""val"":3},""val"":1}'

Given a binary tree


struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}


Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

 

Example:




Input: {""$id"":""1"",""left"":{""$id"":""2"",""left"":{""$id"":""3"",""left"":null,""next"":null,""right"":null,""val"":4},""next"":null,""right"":{""$id"":""4"",""left"":null,""next"":null,""right"":null,""val"":5},""val"":2},""next"":null,""right"":{""$id"":""5"",""left"":null,""next"":null,""right"":{""$id"":""6"",""left"":null,""next"":null,""right"":null,""val"":7},""val"":3},""val"":1}

Output: {""$id"":""1"",""left"":{""$id"":""2"",""left"":{""$id"":""3"",""left"":null,""next"":{""$id"":""4"",""left"":null,""next"":{""$id"":""5"",""left"":null,""next"":null,""right"":null,""val"":7},""right"":null,""val"":5},""right"":null,""val"":4},""next"":{""$id"":""6"",""left"":null,""next"":null,""right"":{""$ref"":""5""},""val"":3},""right"":{""$ref"":""4""},""val"":2},""next"":null,""right"":{""$ref"":""6""},""val"":1}

Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.


 

Note:


	You may only use constant extra space.
	Recursive approach is fine, implicit stack space does not count as extra space for this problem.






";"
思路：p节点遍历当前层，记录下一层链表的prev节点，然后记录下一层遇到的第一个非空节点next。

```cpp
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (!root) return;
        TreeLinkNode *prev = NULL, *p = root, *next = NULL;
        while (true) {
            while (p) {
                if (p->left) {
                    if (!next) next = p->left;
                    if (prev)  prev->next = p->left;
                    if (p->right) prev = p->left->next = p->right;
                    else          prev = p->left;
                } else if (p->right) {
                    if (!next) next = p->right;
                    if (prev)  prev->next = p->right;
                    prev = p->right;
                }
                p = p->next; 
            }
            if (!next) return;
            p = next; prev = NULL; next = NULL;
        }
    }
};
```

将right节点的处理统一，能更简单一点。

```cpp
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (!root) return;
        TreeLinkNode *prev = NULL, *p = root, *next = NULL;
        while (true) {
            while (p) {
                if (p->left) {
                    if (!next) next = p->left;
                    if (prev)  prev->next = p->left;
                    prev = p->left;
                }
                if (p->right) {
                    if (!next) next = p->right;
                    if (prev)  prev->next = p->right;
                    prev = p->right;
                }
                p = p->next; 
            }
            if (!next) return;
            p = next; prev = NULL; next = NULL;
        }
    }
};
```

```cpp
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        queue<TreeLinkNode*> node_queue;
        
        if (root) node_queue.push(root);
        
        while (!node_queue.empty()) {
            TreeLinkNode *hold_node = node_queue.front();
            node_queue.pop();
            int i=node_queue.size();
            if (hold_node->left) node_queue.push(hold_node->left);
            if (hold_node->right) node_queue.push(hold_node->right);
            for (; i>0; i--) {
                TreeLinkNode *node = node_queue.front();
                node_queue.pop();
                hold_node->next = node;
                if (node->left) node_queue.push(node->left);
                if (node->right) node_queue.push(node->right);
                hold_node = node;
            }
        }
    }
};
```


"
0116 Populating Next Right Pointers in Each Node;"https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/

* algorithms
* Medium (36.83%)
* Total Accepted:    228.4K
* Total Submissions: 619.9K
* Testcase Example:  '{""$id"":""1"",""left"":{""$id"":""2"",""left"":{""$id"":""3"",""left"":null,""next"":null,""right"":null,""val"":4},""next"":null,""right"":{""$id"":""4"",""left"":null,""next"":null,""right"":null,""val"":5},""val"":2},""next"":null,""right"":{""$id"":""5"",""left"":{""$id"":""6"",""left"":null,""next"":null,""right"":null,""val"":6},""next"":null,""right"":{""$id"":""7"",""left"":null,""next"":null,""right"":null,""val"":7},""val"":3},""val"":1}'

You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:


struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}


Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

 

Example:




Input: {""$id"":""1"",""left"":{""$id"":""2"",""left"":{""$id"":""3"",""left"":null,""next"":null,""right"":null,""val"":4},""next"":null,""right"":{""$id"":""4"",""left"":null,""next"":null,""right"":null,""val"":5},""val"":2},""next"":null,""right"":{""$id"":""5"",""left"":{""$id"":""6"",""left"":null,""next"":null,""right"":null,""val"":6},""next"":null,""right"":{""$id"":""7"",""left"":null,""next"":null,""right"":null,""val"":7},""val"":3},""val"":1}

Output: {""$id"":""1"",""left"":{""$id"":""2"",""left"":{""$id"":""3"",""left"":null,""next"":{""$id"":""4"",""left"":null,""next"":{""$id"":""5"",""left"":null,""next"":{""$id"":""6"",""left"":null,""next"":null,""right"":null,""val"":7},""right"":null,""val"":6},""right"":null,""val"":5},""right"":null,""val"":4},""next"":{""$id"":""7"",""left"":{""$ref"":""5""},""next"":null,""right"":{""$ref"":""6""},""val"":3},""right"":{""$ref"":""4""},""val"":2},""next"":null,""right"":{""$ref"":""7""},""val"":1}

Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.


 

Note:


	You may only use constant extra space.
	Recursive approach is fine, implicit stack space does not count as extra space for this problem.







";"
思路：注意要判断 `while (curr->left)`，因为当前level已经connect完成了。可以依托于next节点进行逐层遍历，所以可以按照题目的要求用常量空间。

```cpp
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (!root) return;
        TreeLinkNode *prev = NULL, *curr = root, *left = NULL;
        while (curr->left) {
            left = curr->left;
            while (curr) {
                if (prev) prev->right->next = curr->left;
                curr->left->next = curr->right;
                prev = curr; curr = curr->next;
            }
            curr = left; prev = NULL;
        }
    }
};
```

4年前的答案

```cpp
#include <queue>

typedef std::queue<TreeLinkNode*> TreeLinkNodeQueue;

/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connectImpl(TreeLinkNodeQueue * que, int level) {
        if (level == 0) {
            TreeLinkNode* node = static_cast<TreeLinkNode*>(que->front());
            que->pop();
            node->next = NULL;
            if (node->left && node->right) {
                que->push(node->left); que->push(node->right);
                connectImpl(que, level+1);
            }
            return;
        }
        
        int num = 1 << level;
        TreeLinkNode* pre = static_cast<TreeLinkNode*>(que->front());
        que->pop();
        if (pre->left && pre->right) {
            que->push(pre->left); que->push(pre->right);
        }
        
        for (int i=1; i<num; i++) {
            TreeLinkNode* cur = static_cast<TreeLinkNode*>(que->front());
            que->pop();
            pre->next = cur;
            if (cur->left && cur->right) {
                que->push(cur->left); que->push(cur->right);
            }
            pre = cur;
            cur = NULL;
        }
        
        if (que->empty()) {
            return;
        }
        
        connectImpl(que, level+1);
    }
    
    void connect(TreeLinkNode *root) {
        if (root == NULL) {
            return;
        }
        
        TreeLinkNodeQueue que;
        que.push(root);
        
        connectImpl(&que, 0);
    }
};
```


"
0115 Distinct Subsequences;"https://leetcode.com/problems/distinct-subsequences/description/

* algorithms
* Hard (34.55%)
* Total Accepted:    101.2K
* Total Submissions: 292.9K
* Testcase Example:  '""rabbbit""\n""rabbit""'

Given a string S and a string T, count the number of distinct subsequences of S which equals T.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, ""ACE"" is a subsequence of ""ABCDE"" while ""AEC"" is not).

Example 1:


Input: S = ""rabbbit"", T = ""rabbit""
Output: 3
Explanation:

As shown below, there are 3 ways you can generate ""rabbit"" from S.
(The caret symbol ^ means the chosen letters)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^


Example 2:


Input: S = ""babgbag"", T = ""bag""
Output: 5
Explanation:

As shown below, there are 5 ways you can generate ""bag"" from S.
(The caret symbol ^ means the chosen letters)

babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^







";"
思路：f[i+1,j+1] 表示 s[0...i] t[0...j] 的有多少distinct subsequences，所以
 * 当s[i] == t[j]时，f[i+1,j+1] = f[i,j+1] + f[i,j]。
 * 当s[i] != t[j]时，f[i+1,j+1] = f[i,j+1]

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.length(), n = t.length();
        vector<vector<int>> f(m+1, vector<int>(n+1, 0));
        for (int i=0; i<m; i++) 
            if (s[i] == t[0]) f[i+1][1] = f[i][1] + 1; 
            else              f[i+1][1] = f[i][1];
        for (int i=1; i<m; i++) for (int j=1; j<n; j++) {
            if (s[i] == t[j]) f[i+1][j+1] = f[i][j];
            f[i+1][j+1] += f[i][j+1];
        }
        return f.back().back();
    }
};
```


"
0114 Flatten Binary Tree to Linked List;"https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/

* algorithms
* Medium (41.18%)
* Total Accepted:    221.4K
* Total Submissions: 537.5K
* Testcase Example:  '[1,2,5,3,4,null,6]'

Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:


    1
   / \
  2   5
 / \   \
3   4   6


The flattened tree should look like:


1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6







";"
注意要将`node->left = NULL;`

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* node) {
        if (!node) return;
        flatten(node->left); flatten(node->right);
        if (!node->left) return;
        auto p = node->left; while (p->right) p = p->right;
        auto tmp    = node->right;
        node->right = node->left;
        p->right    = tmp;
        node->left  = NULL;
    }
};
```


"
0113 Path Sum II;"https://leetcode.com/problems/path-sum-ii/description/

* algorithms
* Medium (39.50%)
* Total Accepted:    214.7K
* Total Submissions: 543.5K
* Testcase Example:  '[5,4,8,11,null,13,4,7,2,null,null,5,1]\n22'

Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,


      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1


Return:


[
   [5,4,11,2],
   [5,8,4,5]
]







";"
思路深度优先遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        vector<vector<int>> result; vector<int> path;
        pathSum(root, sum, path, result);
        return result;
    }
    
    void pathSum(TreeNode *node, int sum, vector<int>& path, vector<vector<int>>& result) {
        if (!node) return;
        path.push_back(node->val);
        if (!node->left && !node->right) {
            if (node->val == sum) result.push_back(path); path.pop_back();
            return;
        }
        pathSum(node->left , sum - node->val, path, result);
        pathSum(node->right, sum - node->val, path, result);
        path.pop_back();
    }
};
```


"
0112 Path Sum;"https://leetcode.com/problems/path-sum/description/

* algorithms
* Easy (37.07%)
* Total Accepted:    288.6K
* Total Submissions: 778.2K
* Testcase Example:  '[5,4,8,11,null,13,4,7,2,null,null,null,1]\n22'

Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,


      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1


return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.






";"
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (!root) return false;
        if (!root->left && !root->right) 
            if (sum - root->val == 0) return true; else return false;
        if (hasPathSum(root->left , sum-root->val)) return true;
        if (hasPathSum(root->right, sum-root->val)) return true;
        return false;
    }
};
```

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if (!root) return false;
        
        if (root->left || root->right) { // is not a leaf.
            if (root->left && hasPathSum(root->left, sum - root->val)) return true;
            if (root->right && hasPathSum(root->right, sum - root->val)) return true;
        } else { //  is a leaf.
            if (sum - root->val == 0)
                return true; 
        }
        
        return false;
    }
};
```


"
0111 Minimum Depth of Binary Tree;"https://leetcode.com/problems/minimum-depth-of-binary-tree/description/

* algorithms
* Easy (34.88%)
* Total Accepted:    275.8K
* Total Submissions: 790.6K
* Testcase Example:  '[3,9,20,null,null,15,7]'

Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],


    3
   / \
  9  20
    /  \
   15   7

return its minimum depth = 2.







";"
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        queue<TreeNode*> q({root}); int depth = 0;
        while (!q.empty()) {
            queue<TreeNode*> p; depth++;
            while (!q.empty()) {
                TreeNode *n = q.front(); q.pop();
                if (!n->left && !n->right) return depth;
                if (n->left ) p.push(n->left ); 
                if (n->right) p.push(n->right);
            }
            q.swap(p);
        }
        return depth;
    }
};
```

4YA 

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void minDepthImpl(TreeNode *root, int depth, int *shorted_depth) {
        if (!(root->left || root->right)) {
            if (depth < *shorted_depth)
                *shorted_depth = depth;
            return ;
        }
        
        if (root->left)
            minDepthImpl(root->left, depth+1, shorted_depth);
        if (root->right)
            minDepthImpl(root->right, depth+1, shorted_depth);
    }
    
    int minDepth(TreeNode *root) {
        if (!root)
            return 0;
        int shorted_depth = INT_MAX;
        minDepthImpl(root, 1, &shorted_depth);
        return shorted_depth;
    }
};
```


"
0110 Balanced Binary Tree;"https://leetcode.com/problems/balanced-binary-tree/description/

* algorithms
* Easy (40.41%)
* Total Accepted:    297K
* Total Submissions: 734.9K
* Testcase Example:  '[3,9,20,null,null,15,7]'

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:


a binary tree in which the depth of the two subtrees of every node never differ by more than 1.


Example 1:

Given the following tree [3,9,20,null,null,15,7]:


    3
   / \
  9  20
    /  \
   15   7

Return true.

Example 2:

Given the following tree [1,2,2,3,3,null,null,4,4]:


       1
      / \
     2   2
    / \
   3   3
  / \
 4   4


Return false.







";"
深度遍历左右子节点

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        int d = 0; return DFS(root, d);
    }
    
    bool DFS(TreeNode* root, int& d) {
        if (!root) { d++; return true; }
        int ld = 0, rd = 0;
        if (!DFS(root->left , ld)) return false;
        if (!DFS(root->right, rd)) return false;
        d = max(ld, rd) + 1;
        return abs(ld - rd) <= 1;
    }
};
```

4YA

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isBalancedImpl(TreeNode *root, int *depth) {
        if (!root) {
            *depth = 0;
            return true;
        }
        
        int left_depth = 0;
        if (!isBalancedImpl(root->left, &left_depth)) {
            return false;
        }
        
        int right_depth = 0;
        if (!isBalancedImpl(root->right, &right_depth)) {
            return false;
        }
        
        if (left_depth > right_depth) {
            if (left_depth - right_depth > 1) {
                return false;
            } else {
                *depth = left_depth + 1;
                return true;
            }
        } else {
            if (right_depth - left_depth > 1) {
                return false;
            } else {
                *depth = right_depth + 1;
                return true;
            }
        }
    }

    bool isBalanced(TreeNode *root) {
        int depth;
        return isBalancedImpl(root, &depth);
    }
};
```



"
0109 Convert Sorted List to Binary Search Tree;"https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/

* algorithms
* Medium (39.64%)
* Total Accepted:    165.3K
* Total Submissions: 416.8K
* Testcase Example:  '[-10,-3,0,5,9]'

Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:


Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5







";"
思路，跟108题类似，不过数组操作，换成了链表操作。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        int len=0; for (auto p=head; p; p=p->next) len++;
        return DFS(head, len);
    }
    
    TreeNode* DFS(ListNode *head, int len) {
        if (len <= 0) return NULL;
        if (len == 1) return new TreeNode(head->val);
        int mi = len / 2;
        ListNode* p = head; for (int i=0; i<mi; i++) p = p->next;
        TreeNode *n = new TreeNode(p->val);
        n->left  = DFS(head   , mi);
        n->right = DFS(p->next, len-mi-1);
        return n;
    }
};
```


"
0108 Convert Sorted Array to Binary Search Tree;"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/

* algorithms
* Easy (49.34%)
* Total Accepted:    240.2K
* Total Submissions: 486.7K
* Testcase Example:  '[-10,-3,0,5,9]'

Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:


Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5







";"
深度遍历，计算mi，将数组分成两部分，然后分别计算左右子节点的区间。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return DFS(nums, 0, nums.size());
    }
    
    TreeNode* DFS(vector<int>& nums, int lo, int hi) {
        if (lo   >= hi) return NULL;
        if (lo+1 == hi) return new TreeNode(nums[lo]);
        int mi = (hi - lo) / 2 + lo;
        TreeNode* n = new TreeNode(nums[mi]);
        n->left  = DFS(nums, lo  , mi);
        n->right = DFS(nums, mi+1, hi);
        return n;
    }
};
```

4年前的答案

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *sortedArrayToBSTImpl(vector<int> &num, int lo, int hi) {
        if (lo >= hi) {
            return NULL;
        }
        
        int mi = lo + (hi - lo) / 2;
        
        TreeNode* node = new TreeNode(num[mi]);
        node->left = sortedArrayToBSTImpl(num, lo, mi);
        node->right = sortedArrayToBSTImpl(num, mi+1, hi);
        
        return node;
    }
    
    TreeNode *sortedArrayToBST(vector<int> &num) {
        return sortedArrayToBSTImpl(num, 0, num.size());
    }
};
```


"
0107 Binary Tree Level Order Traversal II;"https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/

* algorithms
* Easy (45.71%)
* Total Accepted:    210.8K
* Total Submissions: 461K
* Testcase Example:  '[3,9,20,null,null,15,7]'

Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).


For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7



return its bottom-up level order traversal as:

[
  [15,7],
  [9,20],
  [3]
]







";"
层序遍历，最后反转。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> q({root}); vector<vector<int>> result;
        while (!q.empty()) {
            queue<TreeNode*> p; vector<int> level;
            while (!q.empty()) {
                auto n = q.front(); q.pop();
                if (!n) continue;
                level.push_back(n->val);
                p.push(n->left); p.push(n->right);
            }
            q.swap(p);
            if (!level.empty()) result.push_back(level);
        }
        reverse(begin(result), end(result));
        return move(result);
    }
};
```

4年前的答案，递归求解。

```cpp
#include <stack>
#include <queue>

using namespace std;

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void levelOrderBottomImpl(queue<TreeNode*> *que, vector<vector<int> > *vvi) {
        if (que->empty()) {
            return ;
        }
        
        int size = que->size();
        vector<int> vi;
        
        for (int i=0; i<size; i++) {
            TreeNode *node = que->front();
            que->pop();
            vi.push_back(node->val);
            if (node->left) que->push(node->left);
            if (node->right) que->push(node->right);
        }
        
        levelOrderBottomImpl(que, vvi);
        
        vvi->push_back(vector<int>());
        (*vvi)[vvi->size()-1].swap(vi);
        
        return ;
    }

    vector<vector<int> > levelOrderBottom(TreeNode *root) {
        vector<vector<int> > vvi;
        queue<TreeNode*> que;
        
        if (root) {
            que.push(root);
            levelOrderBottomImpl(&que, &vvi);
        }
        
        return vvi;
    }
};
```


"
0106 Construct Binary Tree from Inorder and Postorder Traversal;"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/

* algorithms
* Medium (38.03%)
* Total Accepted:    142K
* Total Submissions: 373.2K
* Testcase Example:  '[9,3,15,20,7]\n[9,15,7,20,3]'

Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given


inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]

Return the following binary tree:


    3
   / \
  9  20
    /  \
   15   7








";"
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int len = inorder.size(), i = len-1;
        return DFS(inorder, 0, len, postorder, i);
    }

    TreeNode* DFS(vector<int>& inorder, int lo, int hi, vector<int>& postorder, int& i) {
        if (lo   >= hi) return NULL;
        if (lo+1 == hi) return new TreeNode(postorder[i--]);
        TreeNode *n = new TreeNode(postorder[i--]);
        int mi; for (mi=lo; mi<hi; mi++) if (inorder[mi] == n->val) break;
        n->right = DFS(inorder, mi+1, hi, postorder, i);
        n->left  = DFS(inorder, lo  , mi, postorder, i);
        return n;
    }
};
```


"
0105 Construct Binary Tree from Preorder and Inorder Traversal;"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/

* algorithms
* Medium (39.56%)
* Total Accepted:    202.6K
* Total Submissions: 511.8K
* Testcase Example:  '[3,9,20,15,7]\n[9,3,15,20,7]'

Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given


preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]

Return the following binary tree:


    3
   / \
  9  20
    /  \
   15   7






";"
思路：前序确定当前节点，中序确定左右子树。深度优先遍历即可。注意第一行消费了一个节点，i别忘记加1。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int i = 0, len = inorder.size();
        return DFS(preorder, i, inorder, 0, len);
    }
    
    TreeNode* DFS(vector<int>& preorder, int& i, vector<int>& inorder, int lo, int hi) {
        if (lo   >= hi) return NULL;
        if (lo+1 == hi) return new TreeNode(preorder[i++]);
        TreeNode *n = new TreeNode(preorder[i++]);
        int mi; for (mi=lo; mi<hi; mi++) if (inorder[mi] == n->val) break;
        n->left  = DFS(preorder, i, inorder, lo  , mi);
        n->right = DFS(preorder, i, inorder, mi+1, hi);
        return n;
    }
};
```


"
0104 Maximum Depth of Binary Tree;"https://leetcode.com/problems/maximum-depth-of-binary-tree/description/

* algorithms
* Easy (59.27%)
* Total Accepted:    460.3K
* Total Submissions: 776.3K
* Testcase Example:  '[3,9,20,null,null,15,7]'

Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],


    3
   / \
  9  20
    /  \
   15   7

return its depth = 3.






";"
层序遍历，记录深度。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> q({root});
        int depth = 0; bool flag = false;
        while (!q.empty()) {
            queue<TreeNode*> p;
            while (!q.empty()) {
                auto n = q.front(); q.pop();
                if (n) flag = true; else continue;
                p.push(n->left); p.push(n->right);
            }
            q.swap(p);
            if (flag) depth++; flag = false;
        }
        return depth;
    }
};
```

4年前的答案。

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    int RecursiveFindMaxDepth(TreeNode *parent) {
        
        int leftMaxDepth = 0, rightMaxDepth = 0;
        
        if (parent->left != NULL) {
            leftMaxDepth = RecursiveFindMaxDepth(parent->left);
        }
        
        if (parent->right != NULL) {
            rightMaxDepth = RecursiveFindMaxDepth(parent->right);
        } 
        
        return rightMaxDepth > leftMaxDepth ? rightMaxDepth + 1 : leftMaxDepth + 1;
    }
    
    int maxDepth(TreeNode *root) {
        // IMPORTANT: Please reset any member data you declared, as
        // the same Solution instance will be reused for each test case.
        if (root == NULL)
            return 0;
            
        return RecursiveFindMaxDepth(root);
    }
};
```


"
0103 Binary Tree Zigzag Level Order Traversal;"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/

* algorithms
* Medium (40.52%)
* Total Accepted:    197.5K
* Total Submissions: 487K
* Testcase Example:  '[3,9,20,null,null,15,7]'

Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).


For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7



return its zigzag level order traversal as:

[
  [3],
  [20,9],
  [15,7]
]







";"
层序遍历，然后交替将当前层反转。效率不太高，4ms，beat 30.43%。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        queue<TreeNode *> q({root}); bool flag = false;
        vector<vector<int>> result;
        while (!q.empty()) {
            queue<TreeNode *> p; vector<int> level;
            while (!q.empty()) {
                TreeNode *n = q.front(); q.pop();
                if (!n) continue;
                level.push_back(n->val);
                p.push(n->left); p.push(n->right);
            }
            q.swap(p);
            if (level.empty()) continue;
            result.push_back(level);
            if (flag) reverse(begin(result.back()), end(result.back()));
            flag = !flag;
        }
        return move(result);
    }
};
```

用栈代替队列，还是4ms，不知道还有什么提高效率的方法。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        stack<TreeNode*> q({root}); bool flag = true;
        vector<vector<int>> result;
        while (!q.empty()) {
            stack<TreeNode*> p; vector<int> level;
            while (!q.empty()) {
                TreeNode *n = q.top(); q.pop();
                if (!n) continue;
                level.push_back(n->val);
                if (flag) p.push(n->left ), p.push(n->right);
                else      p.push(n->right), p.push(n->left );
            }
            q.swap(p); flag = !flag;
            if (!level.empty()) result.push_back(level);
        }
        return move(result);
    }
};
```


"
0102 Binary Tree Level Order Traversal;"https://leetcode.com/problems/binary-tree-level-order-traversal/description/

* algorithms
* Medium (47.12%)
* Total Accepted:    340.2K
* Total Submissions: 721.8K
* Testcase Example:  '[3,9,20,null,null,15,7]'

Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).


For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7



return its level order traversal as:

[
  [3],
  [9,20],
  [15,7]
]







";"
思路：用queue记录下一层的nodes。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode *> q({root}); vector<vector<int>> result;
        while (!q.empty()) {
            queue<TreeNode *> p; vector<int> level;
            while (!q.empty()) {
                TreeNode *n = q.front(); q.pop();
                if (!n) continue;
                level.push_back(n->val);
                p.push(n->left); p.push(n->right);
            }
            if (!level.empty()) result.push_back(level);
            q.swap(p);
        }
        return move(result);
    }
};
```

4年前的答案

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode *root) {
        vector<vector<int> > levels;
        queue<TreeNode*> node_queue;
        
        if (root) node_queue.push(root);
        
        while (!node_queue.empty()) {
            vector<int> level;
            for (int i=node_queue.size(); i>0; i--) {
                TreeNode *node = node_queue.front();
                level.push_back(node->val);
                if (node->left) node_queue.push(node->left);
                if (node->right) node_queue.push(node->right);
                node_queue.pop();
            }
            levels.push_back(vector<int>());
            levels[levels.size()-1].swap(level);
        }
        
        return levels;
    }
};
```


"
0101 Symmetric Tree;"https://leetcode.com/problems/symmetric-tree/description/

* algorithms
* Easy (42.76%)
* Total Accepted:    363.1K
* Total Submissions: 849.1K
* Testcase Example:  '[1,2,2,3,4,4,3]'

Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).


For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3



But the following [1,2,2,null,3,null,3]  is not:

    1
   / \
  2   2
   \   \
   3    3




Note:
Bonus points if you could solve it both recursively and iteratively.






";"
recursive version，注意`if (!a != !b) ...`是先对节点取反转换成bool，然后用`!=`比较，等价于做异或操作，逻辑上是如果a和b中一方是NULl另一方非空，则...。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        return isSymmetric(root->left, root->right);
    }
    
    bool isSymmetric(TreeNode *a, TreeNode *b) {
        if (!a && !b) return true;
        if (!a != !b) return false;
        if (a->val != b->val) return false;
        return isSymmetric(a->right, b->left ) 
            && isSymmetric(a->left , b->right);
    }
};
```

iterative version，神奇的发现stl的queue<Type\*>是可以存放NULL值的。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        queue<TreeNode *> p({root->left}), q({root->right});
        while (!p.empty() && !q.empty()) {
            TreeNode *a = p.front(), *b = q.front(); p.pop(); q.pop(); 
            if (!a && !b) continue;
            if (!a != !b) return false;
            if (a->val != b->val) return false;
            p.push(a->left ); q.push(b->right);
            p.push(a->right); q.push(b->left );
        } 
        return true;
    }
};
```

4 years前的答案。

```cpp
#include <queue>

typedef std::queue<TreeNode*> TreeNodeQueue;

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetricImpl(TreeNodeQueue *leftQueue, TreeNodeQueue *rightQueue) {
        if (leftQueue->size() != rightQueue->size()) {
            return false;
        }
        
        int n = leftQueue->size();
        if (n == 0) {
            return true;
        }
        for (int i=0; i<n; i++) {
            TreeNode* leftNode = leftQueue->front(); TreeNode* rightNode = rightQueue->front();
            leftQueue->pop();
            rightQueue->pop();
            if (leftNode->val == rightNode->val) {
                if (leftNode->left && rightNode->right) {
                    if (leftNode->left->val != rightNode->right->val) {
                        return false;
                    }
                    leftQueue->push(leftNode->left);
                    rightQueue->push(rightNode->right);
                } else if (leftNode->left || rightNode->right) {
                    return false;
                }
                
                if (leftNode->right && rightNode->left) {
                    if (leftNode->right->val != rightNode->left->val) {
                        return false;
                    }
                    leftQueue->push(leftNode->right);
                    rightQueue->push(rightNode->left);
                } else if (leftNode->right || rightNode->left) {
                    return false;
                }
            } else {
                return false;
            }
        }
        
        return isSymmetricImpl(leftQueue, rightQueue);
    }
    
    bool isSymmetric(TreeNode *root) {
        if (!root) {
            return true;
        }
        TreeNodeQueue leftQueue, rightQueue;
        
        if (root->left && root->right && (root->left->val == root->right->val)) {
            leftQueue.push(root->left); rightQueue.push(root->right);
            return isSymmetricImpl(&leftQueue, &rightQueue);
        } else if (!root->left && !root->right) {
            return true;
        } 
        
        return false;
    }
};
```



"
0100 Same Tree;"https://leetcode.com/problems/same-tree/description/

* algorithms
* Easy (49.44%)
* Total Accepted:    351.7K
* Total Submissions: 711.1K
* Testcase Example:  '[1,2,3]\n[1,2,3]'

Given two binary trees, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

Example 1:


Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true


Example 2:


Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false


Example 3:


Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false







";"
思路1：迭代的方式，注意这一行 `if (!a  != !b) return false;`，直接比较会导致比较两者的指针`a`和`b`。所以，先用`!`转换为bool值再比较。由于前面已经判断力 `if (!a && !b)` 所以这里也可以把 `if (!a != !b` 换成 `if (!a || !b)`，效果是一样的。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* a, TreeNode* b) {
        queue<TreeNode*> p({a}), q({b});
        while (!p.empty() && !q.empty()) {
            a = p.front(); b = q.front(); p.pop(); q.pop();
            if (!a && !b) continue;
            if (!a != !b) return false;
            if (a->val != b->val) return false;
            p.push(a->left ); q.push(b->left );
            p.push(a->right); q.push(b->right);
        }
        return true;
    }
};
```

思路2：递归求解，简单多了。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* a, TreeNode* b) {
        if (!a && !b) return true;
        if (!a || !b) return false;
        if (a->val != b->val) return false;
        bool left  = isSameTree(a->left , b->left );
        bool right = isSameTree(a->right, b->right);
        return left && right;
    }
};
```
"
0099 Recover Binary Search Tree;"https://leetcode.com/problems/recover-binary-search-tree/description/

* algorithms
* Hard (33.91%)
* Total Accepted:    111.6K
* Total Submissions: 329.1K
* Testcase Example:  '[1,3,null,null,2]'

Two elements of a binary search tree (BST) are swapped by mistake.

Recover the tree without changing its structure.

Example 1:


Input: [1,3,null,null,2]

   1
  /
 3
  \
   2

Output: [3,1,null,null,2]

   3
  /
 1
  \
   2


Example 2:


Input: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

Output: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3


Follow up:


	A solution using O(n) space is pretty straight forward.
	Could you devise a constant space solution?







";"
思路：用morrisTraversal进行遍历，然后找出节点中的逆序，区分相邻和不相邻的情况，再交换回来。下面是我能想到的最简洁的方式了。

当节点出现逆序时，
    - 如果是相邻的情况，那么prev是第一个错误节点，curr是第二个错误节点。
    - 如果是不相邻的情况，那么第一次逆序prev是第一个错误节点，第二次逆序curr是第二个错误节点。通过first是不是为空来判断是第一次还是第二次逆序。
            

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode *prev = NULL, *first = NULL, *second = NULL;
        morrisTraversal(root, [&](TreeNode *curr) {
            if (prev && prev->val > curr->val) {
                if (!first) first  = prev; 
                second = curr;
            }
            prev = curr;
        });
        swap(first->val, second->val);
    }
    
    void morrisTraversal(TreeNode *root, function<void(TreeNode*)> iterator) {
        TreeNode *prev, *curr = root;
        while (curr) {
            if (!curr->left) {
                iterator(curr);
                curr = curr->right;
            } else {
                prev = curr->left;
                while (prev->right && prev->right != curr) prev = prev->right;
                if (!prev->right) {
                    prev->right = curr;
                    curr = curr->left;
                } else {
                    iterator(curr);
                    prev->right = NULL;
                    curr = curr->right;
                }
            }   
        }
    }
};
```


"
0098 Validate Binary Search Tree;"https://leetcode.com/problems/validate-binary-search-tree/description/

* algorithms
* Medium (25.26%)
* Total Accepted:    362.7K
* Total Submissions: 1.4M
* Testcase Example:  '[2,1,3]'

Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:


	The left subtree of a node contains only nodes with keys less than the node's key.
	The right subtree of a node contains only nodes with keys greater than the node's key.
	Both the left and right subtrees must also be binary search trees.


Example 1:


Input:
    2
   / \
  1   3
Output: true


Example 2:


    5
   / \
  1   4
     / \
    3   6
Output: false
Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
             is 5 but its right child's value is 4.







";"
思路：需要每个节点满足 L < P < R，同时要注意R子树中的最小节点需要比P大，L子树中的最大节点需要比P小。

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) return true;
        int min = INT_MAX, max = INT_MIN;
        return dfs(root, min, max);
    }
    
    bool dfs(TreeNode *node, int& min, int& max) {
        int lmax=INT_MIN, lmin=INT_MAX, rmax=INT_MIN, rmin=INT_MAX; bool result;
        if (node->left) {
            result = node->left->val < node->val && dfs(node->left, lmin, lmax);
            if (!result || lmax >= node->val) return false;
        }
        if (node->right) {
            result = node->right->val > node->val && dfs(node->right, rmin, rmax);
            if (!result || rmin <= node->val) return false;
        }
        max = std::max(node->val, rmax); 
        min = std::min(node->val, lmin);
        return true;
    }
};
```


"
0097 Interleaving String;"https://leetcode.com/problems/interleaving-string/description/

* algorithms
* Hard (27.33%)
* Total Accepted:    104.8K
* Total Submissions: 383.5K
* Testcase Example:  '""aabcc""\n""dbbca""\n""aadbbcbcac""'

Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

Example 1:


Input: s1 = ""aabcc"", s2 = ""dbbca"", s3 = ""aadbbcbcac""
Output: true


Example 2:


Input: s1 = ""aabcc"", s2 = ""dbbca"", s3 = ""aadbbbaccc""
Output: false







";"
思路：动态规划，f[i][j]表示s1[i,len1]和s2[j,len2]能否interleave字符串s3[i+j,len3]。所以，`f[i][j] = (f[i+1][j]&&s1[i]==s3[i+j]) || (f[i][j+1]&&s2[j]==s3[i+j])`。

```cpp
class Solution {
public:
    bool isInterleave(string& s1, string& s2, string& s3) {
        const size_t len1=s1.length(), len2=s2.length(), len3=s3.length();
        if (len1+len2 != len3) return false;
        vector<vector<int>> f(len1+1, vector<int>(len2+1, 0));
        f[len1][len2] = 1;
        for (int i=len1; i>=0; --i) for (int j=len2; j>=0; --j) {
            int k = i + j;
            f[i][j] = (i<len1&&s1[i]==s3[k]&&f[i+1][j]) || (j<len2&&s2[j]==s3[k]&&f[i][j+1]) || f[i][j];
        }
        return f[0][0];
    }
};
```


"
0096 Unique Binary Search Trees;"https://leetcode.com/problems/unique-binary-search-trees/description/

* algorithms
* Medium (45.17%)
* Total Accepted:    186.4K
* Total Submissions: 412.4K
* Testcase Example:  '3'

Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?

Example:


Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3








";"
思路：一遍过，感觉越来越顺手了，f[n]表示第n个数的BST数，已知`f[0] == 1, f[1] == 1, f[2] == 3`, 推 `f[3] = f[0]*f[2] + f[1]*f[1] + f[2]*f[0]`，再推 `f[4] = f[0]*f[3] + f[1]*f[2] + f[2]*f[1] + f[3]*f[0]`。就是分别把左子树的所有可能乘以右子树的所有可能，再遍历左子树和右子树的各种节点数组合即可。

```cpp
class Solution {
public:
    int numTrees(int n) {
        static vector<int> f = {1, 1, 2};
        for (int i=f.size(); i<=n; i++) {
            f.push_back(0); 
            for (int j=0; j<i; j++) f.back() += f[j]*f[i-1-j];
        }
        return f[n];
    }
};
```


"
0095 Unique Binary Search Trees II;"https://leetcode.com/problems/unique-binary-search-trees-ii/description/

* algorithms
* Medium (34.84%)
* Total Accepted:    129.2K
* Total Submissions: 370.7K
* Testcase Example:  '3'

Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.

Example:


Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST's shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3







";"
思路：分别生成左右子树，然后和当前节点进行组合，left * 1 * right，这里利用了题目没有说明不能复用节点的这一点。所以，其实很多结果的左右子树是重复利用的，这样做其实有瑕疵。应该还有一种做法是，枚举生成左右子树的数组，然后每次生成新树时，进行拷贝。最后根据数组生成树才对。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        vector<TreeNode*> result; if (n == 0) return result;
        vector<int> nums; for (int i=1; i<=n; i++) nums.push_back(i);
        dfs(nums, 0, n, result);
        return move(result);
    }

    void dfs(const vector<int> &nums, int begin, int len, vector<TreeNode*> &result) {
        if (len == 0) { result.push_back(new TreeNode(      0    )); return; }
        if (len == 1) { result.push_back(new TreeNode(nums[begin])); return; }
        for (int i=0; i<len; i++) {
            vector<TreeNode*> left, right;
            dfs(nums, begin    , i      , left );
            dfs(nums, begin+i+1, len-1-i, right);
            for (auto l : left) for (auto r : right) {
                auto n = new TreeNode(nums[begin+i]);
                (l->val) && (n->left =l); 
                (r->val) && (n->right=r);
                result.push_back(n);
            }
        }
    }
};
```


"
0094 Binary Tree Inorder Traversal;"https://leetcode.com/problems/binary-tree-inorder-traversal/description/

* algorithms
* Medium (55.15%)
* Total Accepted:    414.9K
* Total Submissions: 751.9K
* Testcase Example:  '[1,null,2,3]'

Given a binary tree, return the inorder traversal of its nodes' values.

Example:


Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]

Follow up: Recursive solution is trivial, could you do it iteratively?






";"
递归遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result; if (root == NULL) return result;
        inorderTraversal(root, result);
        return move(result);
    }
    
    void inorderTraversal(TreeNode *node, vector<int> &result) {
        if (!node) return;
        inorderTraversal(node->left , result);
        result.push_back(node->val);
        inorderTraversal(node->right, result);
    }
};
```


循环遍历，利用栈，先遍历完左子节点，压入当前值，用p记录右子节点。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result; if (root == NULL) return result;
        stack<TreeNode*> s; TreeNode *p = root, *t;
        while (!s.empty() || p != NULL) {
            while (p) { s.push(p); p = p->left; }
            t = s.top(); result.push_back(t->val); s.pop();
            p = t->right;
        }
        return move(result);
    }
};
```

Morris遍历，参考：https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result; 
        morrisTravesal(root, result);
        return move(result);
    }
    
    void morrisTravesal(TreeNode *root, vector<int> &result) {
        TreeNode *prev, *curr = root;
        while (curr) {
            if (!curr->left) {      // curr's left is null, so it can be push to the result.
                result.push_back(curr->val);
                curr = curr->right;
            } else {               
                // before curr go to left, find a way back, or we back from a rightmost index.
                prev = curr->left; while (prev->right && prev->right != curr) prev = prev->right;
                if (!prev->right) { // make a index form the rightmost to curr.
                    prev->right = curr; 
                    curr = curr->left; 
                } else {            // prev->right == curr, means curr was just backed from a rightmost, recover the index.
                    result.push_back(curr->val);
                    prev->right = NULL;
                    curr = curr->right;
                }
            }
        }
    }
};
```


"
0093 Restore IP Addresses;"https://leetcode.com/problems/restore-ip-addresses/description/

* algorithms
* Medium (30.75%)
* Total Accepted:    130.9K
* Total Submissions: 425.6K
* Testcase Example:  '""25525511135""'

Given a string containing only digits, restore it by returning all possible valid IP address combinations.

Example:


Input: ""25525511135""
Output: [""255.255.11.135"", ""255.255.111.35""]







";"
思路：深搜，具体看代码。需要注意 1.每个component必须小于255 2.component连续两次出现0则无效 3.剪枝：当剩余的字符数比剩余的component最大可能长度还多则无效，可以防止非常长的字符串导致搜索变慢的情况。 

```cpp
class Solution {
public:
    vector<string> restoreIpAddresses(string& s) {
        vector<string> result, ip;
        dfs(s, ip, 0, result);
        return move(result);
    }
    
    void dfs(string& s, vector<string>& ip, int l, vector<string>& result) {
        int n=0, h=l, len=s.length();
        if (l==len || (len-l)>(4-ip.size())*3) return ;
        if (ip.size() == 3) {
            while (h<len) { n = n*10 + s[h++] - '0'; if (n == 0) break; }
            if (h!=len || n>255) return ;
            string ss; for (int i=0; i<3; i++) ss.append(ip[i]).push_back('.'); ss.append(s.substr(l));
            result.push_back(move(ss));
            return ;
        }
        while (h < len) {
            n = n * 10 + s[h] - '0';
            if (n > 255) return ;
            ip.push_back(s.substr(l, h-l+1)); dfs(s, ip, h+1, result); ip.pop_back();
            if (n == 0) return ;
            h++;
        }
    }
};
```



"
0092 Reverse Linked List II;"https://leetcode.com/problems/reverse-linked-list-ii/description/

* algorithms
* Medium (34.10%)
* Total Accepted:    180.4K
* Total Submissions: 528.8K
* Testcase Example:  '[1,2,3,4,5]\n2\n4'

Reverse a linked list from position m to n. Do it in one-pass.

Note: 1 ≤ m ≤ n ≤ length of list.

Example:


Input: 1->2->3->4->5->NULL, m = 2, n = 4
Output: 1->4->3->2->5->NULL








";"
思路：细节题，用p q标记截断位置，用a b c进行反转，最后将p q赋值为相应的值，注意结束状态时 a b c 的位置，是 `p->next = a; q->next = b` 而不是 `p->next = b; q->next = c`。因为每次反转后，都会移动a b c到下一个位置。


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if (m == n) return head;
        ListNode dummy(0), *p = &dummy, *q; dummy.next = head;
        for (int i=0; i<m-1; i++) p = p->next; q = p->next;
        ListNode *a=q,  *b=a->next, *c=b->next;
        for (int i=0; i<n-m; i++) {
            b->next = a; a = b; b = c; 
            if (c) c = c->next;
        }
        p->next = a; q->next = b;
        return dummy.next;
    }
};
```


"
0091 Decode Ways;"https://leetcode.com/problems/decode-ways/description/

* algorithms
* Medium (21.91%)
* Total Accepted:    240K
* Total Submissions: 1.1M
* Testcase Example:  '""12""'

A message containing letters from A-Z is being encoded to numbers using the following mapping:


'A' -> 1
'B' -> 2
...
'Z' -> 26


Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:


Input: ""12""
Output: 2
Explanation: It could be decoded as ""AB"" (1 2) or ""L"" (12).


Example 2:


Input: ""226""
Output: 3
Explanation: It could be decoded as ""BZ"" (2 26), ""VF"" (22 6), or ""BBF"" (2 2 6).






";"
思路：f[i] = f[i-1] + f[i-2]，也可以写成c = b + a，只要s[i]不为0，b就可以和s[i]组合。而a则需要s[i-1]s[i]组成的数字小于26。
* 使用a b b的形式，而不使用a b c的形式，可以避免判断返回b还是c。

```cpp
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s[0] == '0') return 0; 
        int a=1, b=1;
        for (int i=1; i<s.length(); i++) {
            int tmp = b;
            if (s[i] == '0')                             b = 0;
            if (s[i-1]=='1' || (s[i-1]=='2'&&s[i]<='6')) b += a;
            a = tmp;
        }
        return b;
    }
};
```


"
0090 Subsets II;"https://leetcode.com/problems/subsets-ii/description/

* algorithms
* Medium (41.50%)
* Total Accepted:    189.9K
* Total Submissions: 457.4K
* Testcase Example:  '[1,2,2]'

Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:


Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]







";"
思路：

```py
        1       2        2
[-,-,-] [-,-,-] [-,-,-]  [-,-,-]
                         [-,-,2] # 用先空后压的方式，保证对重复数字的去重。
                [-,2,-]  [-,2,-] # 当前是2，且上一次压入的是2，剪枝
                         [-,2,2]
        [1,-,-] [1,-,-]  [1,-,-]
                         [1,-,2] # 用先空后压的方式，保证对重复数字的去重。
                [1,2,-]  [1,2,-] # 当前是2，且上一次压入的是2，剪枝
                         [1,2,2]
```

通过 `path.back != nums[i]` 来保证一旦出现了一个重复字符，后续必须全部出现重复字符 即 `[a, a, a] [-, a, a] [-, -, a]`，从而避免类似`[a, -, -], [a, -, a] ...` 这类情况。保证子集的重复字符的唯一性。

```cpp
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> result; vector<int> path;
        sort(begin(nums), end(nums));
        dfs(nums, 0, path, result);
        return move(result);
    }

    void dfs(vector<int> &nums, int p, vector<int> &path, vector<vector<int>> &result) {
        if (p == nums.size()) { result.push_back(path); return; }
        if (path.empty() || path.back()!=nums[p]) dfs(nums, p+1, path, result);
        path.push_back(nums[p]);
        dfs(nums, p+1, path, result);
        path.pop_back();
    }
};
```


"
0089 Gray Code;"https://leetcode.com/problems/gray-code/description/

* algorithms
* Medium (44.98%)
* Total Accepted:    127.3K
* Total Submissions: 283K
* Testcase Example:  '2'

The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

Example 1:


Input: 2
Output: [0,1,3,2]
Explanation:
00 - 0
01 - 1
11 - 3
10 - 2

For a given n, a gray code sequence may not be uniquely defined.
For example, [0,2,3,1] is also a valid gray code sequence.

00 - 0
10 - 2
11 - 3
01 - 1


Example 2:


Input: 0
Output: [0]
Explanation: We define the gray code sequence to begin with 0.
             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.
             Therefore, for n = 0 the gray code sequence is [0].








";"
思路：[] -> [0, 1] -> [00, 01, 11, 10] -> [000, 001, 011, 010, 110, 111, 101, 100]

把当前数组倒序并首位插入1，然后追加到result中。

```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> r = {0};
        for (int i=0; i<n; i++) {
            int j = r.size() - 1;
            while (j >= 0) r.push_back(r[j--] + (1<<i));
        }
        return move(r);
    }
};
```


"
0088 Merge Sorted Array;"https://leetcode.com/problems/merge-sorted-array/description/

* algorithms
* Easy (34.91%)
* Total Accepted:    332.8K
* Total Submissions: 953.1K
* Testcase Example:  '[1,2,3,0,0,0]\n3\n[2,5,6]\n3'

Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:


	The number of elements initialized in nums1 and nums2 are m and n respectively.
	You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.


Example:


Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]








";"
思路：从最后的数值往前merge，这样可以保证数据有地方存放数据，而且大小正合适。

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m-1, j=n-1, k = nums1.size()-1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        while (j >= 0) nums1[k--] = nums2[j--];
    }
};
```


"
0087 Scramble String;"https://leetcode.com/problems/scramble-string/description/

* algorithms
* Hard (31.12%)
* Total Accepted:    86.6K
* Total Submissions: 278.1K
* Testcase Example:  '""great""\n""rgeat""'

Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of s1 = ""great"":


    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t


To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node ""gr"" and swap its two children, it produces a scrambled string ""rgeat"".


    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t


We say that ""rgeat"" is a scrambled string of ""great"".

Similarly, if we continue to swap the children of nodes ""eat"" and ""at"", it produces a scrambled string ""rgtae"".


    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a


We say that ""rgtae"" is a scrambled string of ""great"".

Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.

Example 1:


Input: s1 = ""great"", s2 = ""rgeat""
Output: true


Example 2:


Input: s1 = ""abcde"", s2 = ""caebd""
Output: false






";"
思路：分治，great按照位置2分成gr和eat后，gr和eat与s2的两部分刚好也能形成scramble，所以遍历位置，递归求解子串就可以了。由于可以反转，所以每个位置需要搜索两次，一次[0,i) [i,n), 一次[0, n-i) [n-i, n)。i1和i2表示s1和s2的起始位置，l表示子串的长度。

中间t[26]是用来判断字符串的各个字符数是不是相等的，可以加速判断，否则会超时。

```cpp
class Solution {
public:
    bool isScramble(string s1, string s2) {
        return dfs(s1, s2, 0, 0, s1.length());
    }

    bool dfs(const string &s1, const string &s2, int i1, int i2, int l) {
        if (l==1 && s1[i1]==s2[i2]) return true;
        int t[26] = {0};
        for (int i=0; i<l ; i++) { t[s1[i1+i]-'a']++; t[s2[i2+i]-'a']--; }
        for (int i=0; i<26; i++) if (t[i] != 0) return false;
        for (int i=1; i<l ; i++) {
            if (dfs(s1, s2, i1, i2    , i) && dfs(s1, s2, i1+i, i2+i, l-i)) return true;
            if (dfs(s1, s2, i1, i2+l-i, i) && dfs(s1, s2, i1+i, i2  , l-i)) return true;
        }
        return false;
    }
};
```


"
0086 Partition List;"https://leetcode.com/problems/partition-list/description/

* algorithms
* Medium (36.37%)
* Total Accepted:    153.8K
* Total Submissions: 422.8K
* Testcase Example:  '[1,4,3,2,5,2]\n3'

Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

Example:


Input: head = 1->4->3->2->5->2, x = 3
Output: 1->2->2->4->3->5







";"
思路：i的左边(不包括i)是已经处理完成的节点，j->next的右边（包括j）都是还未处理的节点，要分成三种情况，

* val小于x且i和j不指向同一个节点，则将j->next节点移动插入到i->next
* val小于x且i和j指向同一个节点，直接移动i和j到下一个节点即可。
* val大于x，则j移动到下一个节点。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode dummy(INT_MAX), *i=&dummy, *j=&dummy; dummy.next = head;
        while (j->next) {
            if (j->next->val < x && i != j) {
                auto t = j->next; j->next = j->next->next;
                t->next = i->next; i->next = t; i = i->next;
            } else if (j->next->val < x && i == j) {
                i = i->next; j = j->next;
            } else {
                j = j->next;
            }
        }
        return dummy.next;
    }
};
```


"
0085 Maximal Rectangle;"https://leetcode.com/problems/maximal-rectangle/description/

* algorithms
* Hard (32.44%)
* Total Accepted:    112.4K
* Total Submissions: 346.5K
* Testcase Example:  '[[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]]'

Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

Example:


Input:
[
  [""1"",""0"",""1"",""0"",""0""],
  [""1"",""0"",""1"",""1"",""1""],
  [""1"",""1"",""1"",""1"",""1""],
  [""1"",""0"",""0"",""1"",""0""]
]
Output: 6







";"
思路：接上一题，按行遍历，每行用数组f存储每列1的高度，然后计算最大直方图面积。

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if (matrix.empty()) return 0;
        const int ROW=matrix.size(), COL=matrix[0].size();
        vector<int> f(COL, 0); int j=0, result=0; stack<int> s;
        for (int i=0; i<ROW; ++i) {
            for (j=0; j<COL; ++j) matrix[i][j]=='1' ? f[j]++ : f[j]=0;
            j = 0;
            while (j<COL || !s.empty()) {
                if (j<COL && (s.empty() || f[s.top()]<=f[j])) {
                    s.push(j++);
                } else {
                    int h = f[s.top()]; s.pop();
                    int l = s.empty() ? 0 : s.top() + 1;
                    result = max(result, h*(j-l));
                }
            }
        }
        return result;
    }
};
```


"
0084 Largest Rectangle in Histogram;"https://leetcode.com/problems/largest-rectangle-in-histogram/description/

* algorithms
* Hard (30.30%)
* Total Accepted:    159.7K
* Total Submissions: 527K
* Testcase Example:  '[2,1,5,6,2,3]'

Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

 


Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].

 


The largest rectangle is shown in the shaded area, which has area = 10 unit.

 

Example:


Input: [2,1,5,6,2,3]
Output: 10








";"
思路：使用栈，遍历数组，如果比top大则压入并继续遍历，如果比top小，则弹出top计算面积直到top比当前元素小时为止。

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> s; int i=0; int result=0, len=heights.size();
        while (i<len || !s.empty()) {
            if (i<len && (s.empty()||heights[s.top()]<=heights[i])) s.push(i++);
            else {
                int h = heights[s.top()]; s.pop();
                int l = s.empty() ? 0 : s.top()+1;
                result = max(result, (i-l)*h);
            }
        }
        return result;
    }
};
```


"
0083 Remove Duplicates from Sorted List;"https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/

* algorithms
* Easy (41.94%)
* Total Accepted:    303.9K
* Total Submissions: 724.6K
* Testcase Example:  '[1,1,2]'

Given a sorted linked list, delete all duplicates such that each element appear only once.

Example 1:


Input: 1->1->2
Output: 1->2


Example 2:


Input: 1->1->2->3->3
Output: 1->2->3







";"
思路：比较简单，判断当前和下一个数据是否相等，相等的话移除下一个节点就可以了。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode *p = head;
        while (p) {
            if (p->next && p->val == p->next->val) {
                auto t = p->next;
                p->next = p->next->next;
                delete t;
            } else {
                p = p->next;
            }
        }
        return head;
    }
};
```


"
0082 Remove Duplicates from Sorted List II;"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/

* algorithms
* Medium (32.23%)
* Total Accepted:    169.7K
* Total Submissions: 526.4K
* Testcase Example:  '[1,2,3,3,4,4,5]'

Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

Example 1:


Input: 1->2->3->3->4->4->5
Output: 1->2->5


Example 2:


Input: 1->1->1->2->3
Output: 2->3







";"
思路：定义一个全局long类型变量n，如果n和当前不相等则追加，如果发现i和i->next重复，则更新n。注意j要指向结果的最后一个数字，否则最后截断时，会多出来额外的数字。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode dummy(0); dummy.next = head; 
        auto j = &dummy; long n = LONG_MAX;
        for (auto i=head; i; i=i->next) {
            if (i->next && i->val==i->next->val) { 
                n = i->val; 
            } else if (i->val != n) { 
                j = j->next; j->val = i->val; 
            }
        }
        auto p = j->next; while (p) { auto t=p; p=p->next; delete t; }
        j->next = NULL;
        return dummy.next;
    }
};
```


"
0081 Search in Rotated Sorted Array II;"https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/

* algorithms
* Medium (32.50%)
* Total Accepted:    159K
* Total Submissions: 489.1K
* Testcase Example:  '[2,5,6,0,0,1,2]\n0'

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).

You are given a target value to search. If found in the array return true, otherwise return false.

Example 1:


Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true


Example 2:


Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false

Follow up:


	This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.
	Would this affect the run-time complexity? How and why?








";"
思路：

1 第一个if保证当发现target时，准确返回
2 第二个if保证 lo mi hi 所在的数据各不相等，后面就可以用 `nums[mi] < nums[lo]` 判断mi在pivot后半部分，`nums[mi] >= nums[lo]` 判断mi在pivot的前半部分。同事，由于第一个if，可以保证 `nums[lo] nums[hi]` 不等于 `target`，可以安全执行`lo++ hi--`。
3 当target > nums[mi]时，正常是向后搜索，except (mi处于pivot的后半部分 and target应处于pivot的前半部分)。
4 当target < nums[mi]时，正常是向前搜索，except (mi处于pivot的前半部分 and target应处于pivot的后半部分)。

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int lo=0, hi=nums.size();
        while (lo < hi) {
            int mi = (lo + hi) / 2;
            if (nums[mi] == target) {
                return true;
            } else if (nums[lo] == nums[mi] && nums[mi] == nums[hi-1]) {
                ++lo; --hi;
            } else if (target > nums[mi]) {
                if (target >= nums[lo] && nums[mi] < nums[lo]) hi = mi; else lo = mi+1;
            } else if (target < nums[mi]) {
                if (target < nums[lo] && nums[mi] >= nums[lo]) lo = mi+1; else hi = mi;
            }
        }
        return false;
    }
};
```


"
0080 Remove Duplicates from Sorted Array II;"https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/

* algorithms
* Medium (39.56%)
* Total Accepted:    189.4K
* Total Submissions: 478.6K
* Testcase Example:  '[1,1,1,2,2,3]'

Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:


Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.

Example 2:


Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.


Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:


// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}








";"
思路：挺直观的一道题，用p索引处理后数据，用i索引处理前数据，用count来计数即可。

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& N) {
        int p=1, count=1, len=N.size();
        if (len == 0) return 0;
        for (int i=1; i<len; i++) {
            (N[i]!=N[i-1]) && (count=1);
            (N[i]==N[i-1]) && (count++);
            if (count <= 2) N[p++] = N[i];
        }
        return p;
    }
};
```
"
0079 Word Search;"https://leetcode.com/problems/word-search/description/

* algorithms
* Medium (30.44%)
* Total Accepted:    254.4K
* Total Submissions: 835.5K
* Testcase Example:  '[[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]]\n""ABCCED""'

Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where ""adjacent"" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:


board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = ""ABCCED"", return true.
Given word = ""SEE"", return true.
Given word = ""ABCB"", return false.







";"
```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if (board.empty()) return false;
        for (int x=0; x<board.size(); x++) for (int y=0; y<board[0].size(); y++)
            if (dfs(board, x, y, word, 0)) return true;
        return false;
    }
    
    bool dfs(vector<vector<char>>& board, int x, int y, string& word, int i) {
        if (board[x][y] != word[i]) return false;
        if (i == word.size()-1)     return true;
        char c = board[x][y]; board[x][y] = '*'; bool result = false;
        if (x-1 >= 0)              result = result || dfs(board, x-1, y,   word, i+1);
        if (x+1 < board.size())    result = result || dfs(board, x+1, y,   word, i+1);
        if (y-1 >= 0)              result = result || dfs(board, x,   y-1, word, i+1);
        if (y+1 < board[0].size()) result = result || dfs(board, x,   y+1, word, i+1);
        board[x][y] = c;
        return result;
    }
};
```

非递归求解

```cpp
class Solution {
public:
    int ladderLength(string& start, string& end, unordered_set<string>& words) {
        unordered_set<string> visited, curr, next;
        visited.insert(start), curr.insert(start);
        int depth = 1;
        while (!curr.empty()) {
            depth++;
            for (auto word : curr) {
                for (int i=0; i<word.size(); i++) for (char c='a'; c<='z'; c++) {
                    if (word[i] == c) continue;
                    swap(word[i], c);
                    if (word == end) return depth;
                    if (words.find(word)!=words.end() && visited.find(word)==visited.end()) 
                        next.insert(word);
                    swap(word[i], c);
                }
            }
            for (auto& word : next) visited.insert(word);
            curr.clear(); swap(curr, next);
        }
        return 0;
    }
};
```


"
0078 Subsets;"https://leetcode.com/problems/subsets/description/

* algorithms
* Medium (51.11%)
* Total Accepted:    333.7K
* Total Submissions: 652.6K
* Testcase Example:  '[1,2,3]'

Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:


Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]






";"
思路：可以用dfs，也可以用位操作算法，应该子集的索引刚好和 1 2 3 4 .. n 的二进制表示法中的1的个数相同。


```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        const int len = nums.size(); vector<vector<int>> result;
        for (int i=0; i<(1<<len); i++) {
            vector<int> subset; subset.reserve(len);
            for (int j=0; j<len; j++) if (i & (1<<j)) subset.push_back(nums[j]);
            result.push_back(move(subset));
        }
        return move(result);
    }
};
```



"
0077 Combinations;"https://leetcode.com/problems/combinations/description/

* algorithms
* Medium (46.11%)
* Total Accepted:    187.1K
* Total Submissions: 405.6K
* Testcase Example:  '4\n2'

Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

Example:


Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]








";"
思路：用深搜，可以比较轻易的搜出来，就是效率比较低，over 32.4%   

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> result; vector<int> path;
        dfs(n, k, 1, path, result);
        return move(result);
    }
    
    void dfs(int n, int k, int p, vector<int> &path, vector<vector<int>> &result) {
        if (path.size() == k) { result.push_back(path); return; }
        if (p > n) return;

        dfs(n, k, p+1, path, result);
        
        path.push_back(p);
        dfs(n, k, p+1, path, result);
        path.pop_back();
    }
};
```


"
0076 Minimum Window Substring;"https://leetcode.com/problems/minimum-window-substring/description/

* algorithms
* Hard (29.90%)
* Total Accepted:    213.9K
* Total Submissions: 715.1K
* Testcase Example:  '""ADOBECODEBANC""\n""ABC""'

Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

Example:


Input: S = ""ADOBECODEBANC"", T = ""ABC""
Output: ""BANC""


Note:


	If there is no such window in S that covers all characters in T, return the empty string """".
	If there is such window, you are guaranteed that there will always be only one unique minimum window in S.






";"
思路：双指针，先移动i直到t中的字符全部在s[l,i]中出现，在移动l使得s[l,i]满足条件的同时i-l最小，计数使用数组。

```cpp
class Solution {
public:
    string minWindow(string& s, string& t) {
        int S[256], T[256], l=0, count=0, minl=0, minh=INT_MAX;
        fill_n(S, 256, 0); fill_n(T, 256, 0);
        for (auto c : t) T[c]++;
        for (int i=0; i<s.length(); i++) {
            S[s[i]]++;
            if (S[s[i]] <= T[s[i]]) count++;
            if (count == t.length()) {
                while (S[s[l]] > T[s[l]]) S[s[l++]]--;
                if (minh-minl > i-l) { minh = i; minl = l; }
                S[s[l++]]--; count--;
            }
        }
        if (minh == INT_MAX) return """";
        return move(s.substr(minl, minh-minl+1));
    }
};
```


"
0075 Sort Colors;"https://leetcode.com/problems/sort-colors/description/

* algorithms
* Medium (41.38%)
* Total Accepted:    294.1K
* Total Submissions: 710.6K
* Testcase Example:  '[2,0,2,1,1,0]'

Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note: You are not suppose to use the library's sort function for this problem.

Example:


Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

Follow up:


	A rather straight forward solution is a two-pass algorithm using counting sort.
	First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
	Could you come up with a one-pass algorithm using only constant space?







";"
思路：题目的Follow up，要单趟排序还是挺难的，和《算法导论》里的快排思路挺类似的，区别是这个有三类。不过理解了，就简单了。也就是[0,l)表示0的存放区间，(h, len-1]表示2的存放区间。i从头到尾的扫描，每次遇到就要将元素放置到正确的位置上。要注意 循环条件 `i<=h`的判断，和向后交换时`i--`保持i的位置不动。

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        const int len = nums.size();
        int l=0, h=len-1;
        for (int i=0; i<=h; i++) {
            if      (nums[i] == 0) swap(nums[i], nums[l++]);
            else if (nums[i] == 2) swap(nums[i--], nums[h--]);
        }
    }
};
```


"
0074 Search a 2D Matrix;"https://leetcode.com/problems/search-a-2d-matrix/description/

* algorithms
* Medium (34.68%)
* Total Accepted:    208.2K
* Total Submissions: 600.3K
* Testcase Example:  '[[1,3,5,7],[10,11,16,20],[23,30,34,50]]\n3'

Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:


	Integers in each row are sorted from left to right.
	The first integer of each row is greater than the last integer of the previous row.


Example 1:


Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true


Example 2:


Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false






";"
思路：先顺着第一列查找，再查找对应的行，可以用binary_search提一下速。有时间的话，也可以考虑自己手撸一个二分查找。

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& M, int T) {
        const int m = M.size();    if (m == 0) return false;
        const int n = M[0].size(); if (n == 0) return false;
        int i = 0;
        for (i=0; i<m; i++) if (M[i].front()<=T && T<=M[i].back()) break;
        if (i == m) return false;
        return binary_search(begin(M[i]), end(M[i]), T);
    }
};
```


"
0073 Set Matrix Zeroes;"https://leetcode.com/problems/set-matrix-zeroes/description/

* algorithms
* Medium (39.00%)
* Total Accepted:    192.1K
* Total Submissions: 492.4K
* Testcase Example:  '[[1,1,1],[1,0,1],[1,1,1]]'

Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Example 1:


Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]


Example 2:


Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]


Follow up:


	A straight forward solution using O(mn) space is probably a bad idea.
	A simple improvement uses O(m + n) space, but still not the best solution.
	Could you devise a constant space solution?







";"
链接：https://leetcode.com/problems/set-matrix-zeroes/description/

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& M) {
        const int m = M.size(); if (m == 0) return;
        const int n = M[0].size();
        int r0 = 1, c0 = 1;
        for (int i=0; i<m; i++) if (!M[i][0]) c0 = 0;
        for (int j=0; j<n; j++) if (!M[0][j]) r0 = 0;
        
        for (int i=1; i<m; i++) for (int j=1; j<n; j++) 
            if (!M[i][j]) M[i][0] = M[0][j] = 0;
        
        for (int i=1; i<m; i++) for (int j=1; j<n; j++)
            if (!M[i][0] || !M[0][j]) M[i][j] = 0;
        
        if (!c0) for (int i=0; i<m; i++) M[i][0] = 0;
        if (!r0) for (int j=0; j<n; j++) M[0][j] = 0;
    }
};
```


"
0072 Edit Distance;"https://leetcode.com/problems/edit-distance/description/

* algorithms
* Hard (36.50%)
* Total Accepted:    159.3K
* Total Submissions: 436.3K
* Testcase Example:  '""horse""\n""ros""'

Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:


	Insert a character
	Delete a character
	Replace a character


Example 1:


Input: word1 = ""horse"", word2 = ""ros""
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')


Example 2:


Input: word1 = ""intention"", word2 = ""execution""
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')







";"
思路：动态规划，`dp[i][j]`表示`src[0, i-1]`与`tar[0, j-1]`的编辑举例，

如果`src[i-1]`等于`tar[j-1]`，那么`dp[i][j] == dp[i-1][j-1]`，因为无需额外的编辑操作。

如果`src[i-1] != tar[j-1]`，那么有三种编辑可能，

1 一是在`dp[i-1][j-1]`基础上通过替换`src[i-1]`为`tar[j-1]`得来，
2 二是在`dp[i][j-1]`基础上从`src[i-1]`的位置插入一个字符得来，
3 三是从`dp[i-1][j]`基础上通过删除`src[i-1]`位置的一个字符得来。所以，取三种可能的最小值并加上一步编辑距离。

另外，初始化`dp[i][0]`表示目标字符串为空的情况，那么只要删除src中的i个字符即可，操作步骤为i。`dp[0][j]`表示源字符串为空，那么添加j个字符即可，操作步骤数为j。

最后，其实每步计算，只需要左方 右方和上方的dp值即可，可以把二维表简化为单行来计算，可以把空间从O(mn)减少到O(n)。

```cpp
class Solution {
public:
    int minDistance(const string &src, const string &tar) {
        int m=src.size(), n=tar.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        for (int i=1; i<m+1; i++) dp[i][0] = i;
        for (int j=1; j<n+1; j++) dp[0][j] = j;
        for (int i=1; i<m+1; i++) for (int j=1; j<n+1; j++) {
            if (src[i-1] == tar[j-1]) { 
                dp[i][j] = dp[i-1][j-1]; 
            } else {
                dp[i][j] = min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]}) + 1;
            }
        }
        return dp[m][n];
    }
};
```


"
0071 Simplify Path;"https://leetcode.com/problems/simplify-path/description/

* algorithms
* Medium (28.17%)
* Total Accepted:    141.9K
* Total Submissions: 503.7K
* Testcase Example:  '""/home/""'

Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.

In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix

Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.

 

Example 1:


Input: ""/home/""
Output: ""/home""
Explanation: Note that there is no trailing slash after the last directory name.


Example 2:


Input: ""/../""
Output: ""/""
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.


Example 3:


Input: ""/home//foo/""
Output: ""/home/foo""
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.


Example 4:


Input: ""/a/./b/../../c/""
Output: ""/c""


Example 5:


Input: ""/a/../../b/../c//.//""
Output: ""/c""


Example 6:


Input: ""/a//b////c/d//././/..""
Output: ""/a/b/c""







";"
思路：将每个有效的component存储再数组中，过程中移除空目录，处理特殊的目录如""..""和"".""，注意vector为空时，pop_back会报异常。注意if和elseif的匹配问题，这题必须要加上大括号，想想为什么。

```cpp
class Solution {
public:
    string simplifyPath(string& path) {
        const int len = path.length(); int l=1, h=1; vector<string> p;
        if (len==0 || path[0]!='/') return """";
        while (l < len) {
            while (h<len && path[h]!='/') h++;
            string tmp = path.substr(l, h-l);
            if      (tmp == "".."")       { if (!p.empty()) p.pop_back(); }
            else if (tmp!=""."" && h-l>0) { p.push_back(move(tmp)); }
            l = ++h;
        }
        if (p.empty()) return ""/"";
        string result;
        for (auto& s : p) { result.push_back('/'); result.append(s); }
        return move(result);
    }
};
```

```cpp
class Solution {
public:
    string simplifyPath(string& path) {
        const int len = path.length(); int l=1, h=1; vector<string> p;
        if (len==0 || path[0]!='/') return """";
        while (l < len) {
            while (h<len && path[h]!='/') h++;
            string tmp = path.substr(l, h-l);
            if      (tmp == "".."") { if (!p.empty()) p.pop_back(); }
            else if (tmp == ""."" ) { /* do nothing */              }
            else if (h - l > 0  ) { p.push_back(move(tmp));       }
            l = ++h;
        }
        if (p.empty()) return ""/"";
        string result;
        for (auto& s : p) { result.append(""/"").append(s); }
        return move(result);
    }
};
```


"
0070 Climbing Stairs;"https://leetcode.com/problems/climbing-stairs/description/

* algorithms
* Easy (43.51%)
* Total Accepted:    361.4K
* Total Submissions: 830.6K
* Testcase Example:  '2'

You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

Example 1:


Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps


Example 2:


Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step







";"
思路：f(n) = f(n-1) + f(n-2)，第n步的可能性等于第n-1步加上第n-2步。以此内推即可。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 2) return n;
        int a = 3, b = 2, c  = 1;
        for (int i = 3; i <= n; i++) {
            a = b + c; c = b; b = a;
        }
        return a;
    }
};
```


"
0069 Sqrt(x);"https://leetcode.com/problems/sqrtx/description/

* algorithms
* Easy (30.73%)
* Total Accepted:    333.8K
* Total Submissions: 1.1M
* Testcase Example:  '4'

Implement int sqrt(int x).

Compute and return the square root of x, where x is guaranteed to be a non-negative integer.

Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.

Example 1:


Input: 4
Output: 2


Example 2:


Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since 
             the decimal part is truncated, 2 is returned.







";"
思路：这题比较简单，注意nxn不溢出就可以了。

```cpp
class Solution {
public:
    int mySqrt(int x) {
        for (long n = 0; n <= (x/2+2); n++) if (n * n > x) return n-1;
        return 0;
    }
};
```


"
0068 Text Justification;"https://leetcode.com/problems/text-justification/description/

* algorithms
* Hard (22.51%)
* Total Accepted:    90.3K
* Total Submissions: 400.9K
* Testcase Example:  '[""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""]\n16'

Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

Note:


	A word is defined as a character sequence consisting of non-space characters only.
	Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
	The input array words contains at least one word.


Example 1:


Input:
words = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""]
maxWidth = 16
Output:
[
   ""This    is    an"",
   ""example  of text"",
   ""justification.  ""
]


Example 2:


Input:
words = [""What"",""must"",""be"",""acknowledgment"",""shall"",""be""]
maxWidth = 16
Output:
[
  ""What   must   be"",
  ""acknowledgment  "",
  ""shall be        ""
]
Explanation: Note that the last line is ""shall be    "" instead of ""shall     be"",
             because the last line must be left-justified instead of fully-justified.
             Note that the second line is also left-justified becase it contains only one word.


Example 3:


Input:
words = [""Science"",""is"",""what"",""we"",""understand"",""well"",""enough"",""to"",""explain"",
         ""to"",""a"",""computer."",""Art"",""is"",""everything"",""else"",""we"",""do""]
maxWidth = 20
Output:
[
  ""Science  is  what we"",
  ""understand      well"",
  ""enough to explain to"",
  ""a  computer.  Art is"",
  ""everything  else  we"",
  ""do                  ""
]







";"
思路：逐行处理，先计算出当前行最大包含的单词，然后计算总空格数，分别处理 单个单词 最后一行 常规 等三种情况。其中 单个单词 和 最后一行 的处理不能交换，是因为什么呢？

```cpp
class Solution {
public:
    vector<string> fullJustify(const vector<string>& S, const int W) {
        vector<string> result; int p = 0;
        while (p < S.size()) {
            result.push_back(nextJustifyLine(S, p, W));
        }
        return result;
    }
    
    string nextJustifyLine(const vector<string> &S, int &p, const int W) {
        string line; vector<string> w; int Nw = 0; line.reserve(W);
        while (p < S.size() && (Nw + S[p].length() + w.size() <= W)) {
            w.push_back(S[p]); Nw += S[p].length(); p++;
        }
        const int Ns = W - Nw, Np = w.size() - 1; // num of spaces and num of pos.
        if (w.size() == 1) {
            line.append(w[0]).append(Ns, ' ');
        } else if (p == S.size()) {            // last line.
            for (int i=0; i<=w.size()-2; i++) 
                line.append(w[i]).push_back(' ');
            line.append(w.back()).append(Ns-Np, ' ');
        } else {
            for (int i=0; i<=w.size()-2; i++) 
                line.append(w[i]).append(Ns / Np + (i < Ns%Np ? 1 : 0), ' ');
            line.append(w.back());
        }
        return move(line);
    }
};
```


"
0067 Add Binary;"https://leetcode.com/problems/add-binary/description/

* algorithms
* Easy (38.02%)
* Total Accepted:    278.6K
* Total Submissions: 732.7K
* Testcase Example:  '""11""\n""1""'

Given two binary strings, return their sum (also a binary string).

The input strings are both non-empty and contains only characters 1 or 0.

Example 1:


Input: a = ""11"", b = ""1""
Output: ""100""

Example 2:


Input: a = ""1010"", b = ""1011""
Output: ""10101""






";"
思路：从后依次往前加，注意carry即可。

```cpp
class Solution {
public:
    string addBinary(const string &a, const string &b) {
        int alen=a.length(), blen=b.length(), len=max(alen, blen), carry=0;
        if (len == 0) return """";
        string c(len, '0');
        for (int i=0; i<len; i++) {
            (i < alen) && (carry += a[alen-i-1]-'0');
            (i < blen) && (carry += b[blen-i-1]-'0');
            c[len-i-1] = carry % 2 + '0';
            carry = carry / 2;
        }
        if (carry != 0) c.insert(begin(c), carry+'0');
        return move(c);
    }
};
```


"
0066 Plus One;"https://leetcode.com/problems/plus-one/description/

* algorithms
* Easy (40.71%)
* Total Accepted:    357.1K
* Total Submissions: 877.2K
* Testcase Example:  '[1,2,3]'

Given a non-empty array of digits representing a non-negative integer, plus one to the integer.

The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.

You may assume the integer does not contain any leading zero, except the number 0 itself.

Example 1:


Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.


Example 2:


Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.






";"
思路：加1，逐一计算carry，比较简单，一遍过。

```cpp
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        const int len = digits.size();
        if (len == 0) return vector<int>();
        int carry = 0; digits[len-1] += 1;
        for (int i=len-1; i>=0; i--) {
            digits[i] += carry;
            carry = digits[i] / 10;
            digits[i] %= 10;
        }
        if (carry != 0) {
            digits.insert(begin(digits), carry);
        }
        return digits;
    }
};
```


"
0065 Valid Number;"https://leetcode.com/problems/valid-number/description/

* algorithms
* Hard (13.80%)
* Total Accepted:    115.3K
* Total Submissions: 835.4K
* Testcase Example:  '""0""'

Validate if a given string can be interpreted as a decimal number.

Some examples:
""0"" => true
"" 0.1 "" => true
""abc"" => false
""1 a"" => false
""2e10"" => true
"" -90e3   "" => true
"" 1e"" => false
""e3"" => false
"" 6e-1"" => true
"" 99e2.5 "" => false
""53.5e93"" => true
"" --6 "" => false
""-+3"" => false
""95a54e53"" => false

Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:


	Numbers 0-9
	Exponent - ""e""
	Positive/negative sign - ""+""/""-""
	Decimal point - "".""


Of course, the context of these characters also matters in the input.

Update (2015-02-10):
The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.






";"
思路：用状态机，transition的条件为输入字符的类型，状态为0到9，其中0表示开始，99表示成功结束。每行表示从当前状态（行下标）遇到对应的条件跳转到的下一个状态，-1表示无效终止。其他思路，一个完整的数字包括+123.123e+123，其中符号部分是可选的，第一个123和第二个123必须出现一个，最后的e部分也是可选的。

```cpp
class Solution {
public:
    bool isNumber(const string &s) {
        enum ConditionType {
            INVALID, SPACE, SIGN, DIGIT, DOT, EXPONENT, ENDSTR, NUMINPUTS
        };
        int next[][NUMINPUTS] = {
            -1,       0,     1,    2,     3,  -1,       -1, // 0
            -1,      -1,    -1,    2,     3,  -1,       -1, // 1
            -1,       9,    -1,    2,     4,   5,       99, // 2
            -1,      -1,    -1,    6,    -1,  -1,       -1, // 3
            -1,       9,    -1,    6,    -1,   5,       99, // 4
            -1,      -1,     7,    8,    -1,  -1,       -1, // 5
            -1,       9,    -1,    6,    -1,   5,       99, // 6
            -1,      -1,    -1,    8,    -1,  -1,       -1, // 7
            -1,       9,    -1,    8,    -1,  -1,       99, // 8
            -1,       9,    -1,   -1,    -1,  -1,       99, // 9
        };
        int state = 0, condition;
        for (auto ch : s) {
            if (isspace(ch))                 condition = SPACE;
            else if (isdigit(ch))            condition = DIGIT;
            else if (ch=='+' || ch=='-')     condition = SIGN;
            else if (ch == '.')              condition = DOT;
            else if (ch == 'E' || ch == 'e') condition = EXPONENT;
            else                             condition = INVALID;
            state = next[state][condition];
            if (state == -1) return false;
        }
        return next[state][ENDSTR] == 99;
    }
};
```


"
0064 Minimum Path Sum;"https://leetcode.com/problems/minimum-path-sum/description/

* algorithms
* Medium (45.63%)
* Total Accepted:    211.3K
* Total Submissions: 462.8K
* Testcase Example:  '[[1,3,1],[1,5,1],[4,2,1]]'

Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:


Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.








";"
思路：和62题63题类似，区别在于从左边和上方找到较小的值加和，就是当前格子的最小路径和，注意边界的处理。比较简单，一遍通过。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();         if (m == 0) return 0;
        int n = grid.front().size(); if (n == 0) return 0;
        for (int i=0; i<m; i++) for (int j=0; j<n; j++) {
            (i == 0 && j >  0) && (grid[i][j] += grid[i][j-1]);
            (i >  0 && j == 0) && (grid[i][j] += grid[i-1][j]);
            (i >  0 && j >  0) && (grid[i][j] += min(grid[i-1][j], grid[i][j-1]));
        }
        return grid.back().back();
    }
};
```


"
0063 Unique Paths II;"https://leetcode.com/problems/unique-paths-ii/description/

* algorithms
* Medium (33.22%)
* Total Accepted:    184.9K
* Total Submissions: 556.6K
* Testcase Example:  '[[0,0,0],[0,1,0],[0,0,0]]'

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?



An obstacle and empty space is marked as 1 and 0 respectively in the grid.

Note: m and n will be at most 100.

Example 1:


Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right








";"
思路：注意 [0, 0]位置 和 [m, n] 位置不能为1。可以复用grid作为表用，加和时需要判断一下[i, j]是否为1，已经邻居格是否为1。

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& grid) {
        if (grid.empty() || grid.front().empty()) return 0;
        if (grid.front().front() || grid.back().back()) return 0; 
        grid[0][0] = -1;
        for (int i = 0; i < grid.size(); i++) for (int j = 0; j < grid.front().size(); j++) {
            if (grid[i][j] == 1) continue;
            (j > 0) && (grid[i][j-1] < 0) && (grid[i][j] += grid[i][j-1]);
            (i > 0) && (grid[i-1][j] < 0) && (grid[i][j] += grid[i-1][j]);
        }
        return -grid.back().back();
    }
};
```


"
0062 Unique Paths;"https://leetcode.com/problems/unique-paths/description/

* algorithms
* Medium (46.47%)
* Total Accepted:    262.3K
* Total Submissions: 564.4K
* Testcase Example:  '3\n2'

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?


Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:


Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right


Example 2:


Input: m = 7, n = 3
Output: 28







";"
思路: 每一个格子的可能路径数等于左边格子路径书加上上方格子路径数。

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> tbl(m, vector<int>(n, 0));
        tbl[0][0] = 1;
        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) {
            (i > 0) && (tbl[i][j] += tbl[i-1][j]);
            (j > 0) && (tbl[i][j] += tbl[i][j-1]);
        }
        return tbl.back().back();
    }
};
```


"
0061 Rotate List;"https://leetcode.com/problems/rotate-list/description/

* algorithms
* Medium (26.54%)
* Total Accepted:    179.1K
* Total Submissions: 674.6K
* Testcase Example:  '[1,2,3,4,5]\n2'

Given a linked list, rotate the list to the right by k places, where k is non-negative.

Example 1:


Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL
Explanation:
rotate 1 steps to the right: 5->1->2->3->4->NULL
rotate 2 steps to the right: 4->5->1->2->3->NULL


Example 2:


Input: 0->1->2->NULL, k = 4
Output: 2->0->1->NULL
Explanation:
rotate 1 steps to the right: 2->0->1->NULL
rotate 2 steps to the right: 1->2->0->NULL
rotate 3 steps to the right: 0->1->2->NULL
rotate 4 steps to the right: 2->0->1->NULL






";"
思路：先计算链表长度len，双指针p1和p2，p1先走k步，开始同时走p1和p2，当p1->next指向null时，p2指向倒数第k+1个元素，调整两部分链表的前后顺序即可。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        ListNode *p1=head, *p2=head;
        int len=0; while (p1!=nullptr) { p1=p1->next; len++; }
        if (len == 0) return NULL;
        k = k % len; p1 = head;
        if (k == 0) return head;
        for (int i=0; i<k; ++i) p1 = p1->next;
        while (p1->next != nullptr) { p1 = p1->next; p2 = p2->next; }
        p1->next = head; head = p2->next; p2->next = nullptr;
        return head;
    }
};
```


"
0060 Permutation Sequence;"https://leetcode.com/problems/permutation-sequence/description/

* algorithms
* Medium (32.34%)
* Total Accepted:    129.9K
* Total Submissions: 401.6K
* Testcase Example:  '3\n3'

The set [1,2,3,...,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, we get the following sequence for n = 3:


	""123""
	""132""
	""213""
	""231""
	""312""
	""321""


Given n and k, return the kth permutation sequence.

Note:


	Given n will be between 1 and 9 inclusive.
	Given k will be between 1 and n! inclusive.


Example 1:


Input: n = 3, k = 3
Output: ""213""


Example 2:


Input: n = 4, k = 9
Output: ""2314""







";"
思路：共有 n * (n-1) * (n-2) * ... * 1 个数，第一层可以分为n个(n-1)!，第一位分别以1 2 3 ... n，依次内推。因此，可以先计算出在哪个区间内，并将每一层数字追加到result里。

```cpp
class Solution {
public:
    string getPermutation(int n, int k) {
        int f = 1; vector<char> nums; string result; k = k - 1;
        for (int i=1; i<= n; i++) { f *= i; nums.push_back(i+'0'); }
        while (nums.size() > 1 && k != 0) {
            f /= nums.size();
            int i = k / f; k = k % f;
            result.push_back(nums[i]); 
            nums.erase(begin(nums)+i);
        }
        for (char num : nums) result.push_back(num);
        return result;
    }
};
```
"
0059 Spiral Matrix II;"https://leetcode.com/problems/spiral-matrix-ii/description/

* algorithms
* Medium (45.42%)
* Total Accepted:    128.3K
* Total Submissions: 282.3K
* Testcase Example:  '3'

Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

Example:


Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]







";"
思路：设有四根线在上下左右四侧，遍历一条边之后，就将对应的边增加。

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> result(n, vector<int>(n, 0));
        int rb=0, re=n-1, cb=0, ce=n-1, p=1;
        for (int i=0; i<(n+1)/2; i++) {
            for (int c=cb; c<=ce; c++) result[rb][c] = p++; rb++;
            for (int r=rb; r<=re; r++) result[r][ce] = p++; ce--;
            for (int c=ce; c>=cb; c--) result[re][c] = p++; re--;
            for (int r=re; r>=rb; r--) result[r][cb] = p++; cb++;
        }
        return move(result);
    }
};
```


"
0058 Length of Last Word;"https://leetcode.com/problems/length-of-last-word/description/

* algorithms
* Easy (32.15%)
* Total Accepted:    248.1K
* Total Submissions: 771.5K
* Testcase Example:  '""Hello World""'

Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

Example:

Input: ""Hello World""
Output: 5







";"
思路：需要注意防止尾部有空格，没有其他要注意的了。

```cpp
class Solution {
public:
    int lengthOfLastWord(const string& s) {
        int result = 0; int p = s.length()-1;
        while (p >= 0 && isspace(s[p])) p--;
        while (p >= 0 && isalpha(s[p])) { p--; result++; }
        return move(result);
    }
};
```


"
0057 Insert Interval;"https://leetcode.com/problems/insert-interval/description/

* algorithms
* Hard (30.78%)
* Total Accepted:    165.5K
* Total Submissions: 537.6K
* Testcase Example:  '[[1,3],[6,9]]\n[2,5]'

Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:


Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]


Example 2:


Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].







";"
思路：先找到与start相交的interval，然后开始合并，直到与end相交的interval，再放压入剩余的interval.

```cpp
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> insert(vector<Interval>& I, Interval i) {
        vector<Interval> result; int p=0, len=I.size();
        while (p<len && I[p].end<i.start) result.push_back(I[p++]);
        while (p<len && I[p].start<=i.end) { 
            i.start = min(I[p].start, i.start); 
            i.end   = max(I[p].end  , i.end); 
            p++; 
        } 
        result.push_back(i);
        while (p < len) result.push_back(I[p++]);
        return move(result);
    }
};
```


"
0056 Merge Intervals;"https://leetcode.com/problems/merge-intervals/description/

* algorithms
* Medium (34.88%)
* Total Accepted:    310.2K
* Total Submissions: 889.3K
* Testcase Example:  '[[1,3],[2,6],[8,10],[15,18]]'

Given a collection of intervals, merge all overlapping intervals.

Example 1:


Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].


Example 2:


Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.






";"
思路：先排序，再遍历合并就可以了。

```cpp
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> merge(vector<Interval>& I) {
        if (I.size() <= 1) return I;
        sort(begin(I), end(I), [](const Interval& l, const Interval& r) {
            return l.start < r.start;
        });
        Interval curr = I.front(), next; vector<Interval> result;
        for (int i=1; i<I.size(); i++) {
            next = I[i];
            if (curr.end >= next.start) { curr.end = max(curr.end, next.end);  }
            else                        { result.push_back(curr); curr = next; }
        }
        result.push_back(curr);
        return result;
    }
};
```


"
0055 Jump Game;"https://leetcode.com/problems/jump-game/description/

* algorithms
* Medium (31.35%)
* Total Accepted:    238.8K
* Total Submissions: 761.7K
* Testcase Example:  '[2,3,1,1,4]'

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:


Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.


Example 2:


Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.








";"
思路：计算每一格子能到达的最远位置，然后记录遍历以来能到达的最远位置，只要在最远位置内的都是可到达的点。然后判断最远位置是否能到达终点，如果可以则返回true，反之返回false。

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int reach=0, n=nums.size();
        for (int i=0; i<n && i<=reach; i++) {
            reach = max(i+nums[i], reach);
            if (reach >= n-1) return true;
        }
        return false;
    }
};
```


"
0054 Spiral Matrix;"https://leetcode.com/problems/spiral-matrix/description/

* algorithms
* Medium (29.67%)
* Total Accepted:    212K
* Total Submissions: 714.3K
* Testcase Example:  '[[1,2,3],[4,5,6],[7,8,9]]'

Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example 1:


Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]


Example 2:

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]







";"
思路：用(rb, cb, re, ce)表示矩阵的矩形区域，便利矩形边界和动态更新矩形区域的大小。在向左便利和向上便利的时候，需要判断前面的操作过程中有没有使得矩形失效。

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        if (matrix.empty()) return result;
        int rb=0, cb=0, re=matrix.size()-1, ce=matrix[0].size()-1, i;
        result.reserve((re+1)*(ce+1)); 
        while (cb<=ce && rb<=re) {
            for (i=cb; i<=ce; ++i) result.push_back(matrix[rb][i]); rb++;
            for (i=rb; i<=re; ++i) result.push_back(matrix[i][ce]); ce--;
            if (rb <= re) for (i=ce; i>=cb; --i) result.push_back(matrix[re][i]); re--;
            if (cb <= ce) for (i=re; i>=rb; --i) result.push_back(matrix[i][cb]); cb++;
        }
        return move(result);
    }
};
```


"
0053 Maximum Subarray;"https://leetcode.com/problems/maximum-subarray/description/

* algorithms
* Easy (42.85%)
* Total Accepted:    471.4K
* Total Submissions: 1.1M
* Testcase Example:  '[-2,1,-3,4,-1,2,1,-5,4]'

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:


Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.


Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.






";"
思路：动态规划
last(i)表示在nums[0...i]中，尾部加和的最大值。
maxsum(i)表示在nums[0...i]中，最大子数组的和的值。

last(i) = max(last(i-1)+nums(i), nums(i)) , 只有当加上nums[i]后，值变得更小了，才会将last(i)更新为nums[i]
maxsum(i) = max(maxsum(i-1), last(i))

要注意一下，子数组是否允许为空。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.empty()) return 0;
        int maxsum=nums[0], last=nums[0];
        for (int i=1; i<nums.size(); i++) {
            last += nums[i];
            last = max(last, nums[i]);
            maxsum = max(maxsum, last);
        }
        return maxsum;
    }
};
```


"
0052 N-Queens II;"https://leetcode.com/problems/n-queens-ii/description/

* algorithms
* Hard (50.75%)
* Total Accepted:    93.3K
* Total Submissions: 183.7K
* Testcase Example:  '4'

The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.



Given an integer n, return the number of distinct solutions to the n-queens puzzle.

Example:


Input: 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.
[
 ["".Q.."",  // Solution 1
  ""...Q"",
  ""Q..."",
  ""..Q.""],

 [""..Q."",  // Solution 2
  ""Q..."",
  ""...Q"",
  "".Q..""]
]







";"
思路：类似51题，区别在于统计不同ans的数量，感觉还简单一些。

```cpp
class Solution {
public:
    int totalNQueens(int n) {
        vector<int> vertical(n, 0), diag(n+n, 0), antidiag(n+n, 0); int total = 0;
        dfs(0, n, vertical, diag, antidiag, total);
        return total;
    }
    
    void dfs(int r, int n, vector<int>& vertical, vector<int>& diag, vector<int>& antidiag, int& total) {
        if (r == n) { total++; return; }
        for (int c=0; c<n; c++) {
            if (vertical[c] || diag[r+c] || antidiag[r+n-1-c]) continue;
            vertical[c] = diag[r+c] = antidiag[r+n-1-c] = 1;
            dfs(r+1, n, vertical, diag, antidiag, total);
            vertical[c] = diag[r+c] = antidiag[r+n-1-c] = 0;
        }
    }
};
```


"
0051 N-Queens;"https://leetcode.com/problems/n-queens/description/

* algorithms
* Hard (37.80%)
* Total Accepted:    130.4K
* Total Submissions: 344.8K
* Testcase Example:  '4'

The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.



Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

Example:


Input: 4
Output: [
 ["".Q.."",  // Solution 1
  ""...Q"",
  ""Q..."",
  ""..Q.""],

 [""..Q."",  // Solution 2
  ""Q..."",
  ""...Q"",
  "".Q..""]
]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.








";"
思路：queen所在的位置的水平、竖直、45度斜线、-45度斜线上不能存在另外一个queen。因此，我们逐行搜索，深度优先。用vertical记录第c列是否有其他queen存在、diag记录同45度上是否有其他queen存在，antidiag记录-45度斜线上是否存在其他queen。

有一个小技巧：在同一个45度线上的，r+c的值相同。在同一个-45度上的，可以通过水平翻转，[r+c] -> [r,n-1-c]，然后他们的家和也是相同的了。

```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> result; vector<int> path(n, 0);
        vector<int> vertical(n, 0), diag(n+n, 0), antidiag(n+n, 0);
        dfs(0, n, path, vertical, diag, antidiag, result);
        return result;
    }

    void dfs(int r, int n, vector<int>& path, vector<int>& vertical, vector<int>& diag, 
            vector<int>& antidiag, vector<vector<string>>& result) {
        if (r == n) {
            vector<string> ans(n, string(n, '.')); for (int i=0; i<n; i++) ans[i][path[i]] = 'Q';
            result.push_back(ans);
            return;
        }
        for (int c=0; c<n; c++) {
            if (vertical[c] || diag[r+c] || antidiag[r+n-1-c]) continue;
            vertical[c] = diag[r+c] = antidiag[r+n-1-c] = 1;
            path[r] = c;
            dfs(r+1, n, path, vertical, diag, antidiag, result);
            path[r] = 0;
            vertical[c] = diag[r+c] = antidiag[r+n-1-c] = 0;
        }
    }
};
```


"
0050 Pow(x, n);"https://leetcode.com/problems/powx-n/description/

* algorithms
* Medium (27.57%)
* Total Accepted:    293.2K
* Total Submissions: 1.1M
* Testcase Example:  '2.00000\n10'

Implement pow(x, n), which calculates x raised to the power n (xn).

Example 1:


Input: 2.00000, 10
Output: 1024.00000


Example 2:


Input: 2.10000, 3
Output: 9.26100


Example 3:


Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25


Note:


	-100.0 < x < 100.0
	n is a 32-bit signed integer, within the range [−231, 231 − 1]







";"
```
Last executed input:
1.00000
-2147483648
```

讲道理不应该啊。。。

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        double result = 1.f;
        int save = n;
        n = abs(n);
        while (n != 0) {
            (n & 1 != 0) && (result *= x);
            x *= x; n >>= 1;
        }
        if (save < 0) result = 1.f / result;
        return result;
    }
};
```

好吧，找到原因了，INT_MIN的abs。。。还是INT_MIN.

```
INT_MAX: 2147483647
INT_MIN: -2147483648
abs(INT_MIN): -2147483648
```

换成下面的可以了

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        double result = 1.f;
        long l = abs((long)n);
        while (l != 0) {
            (l & 1 != 0) && (result *= x);
            x *= x; l >>= 1;
        }
        if (n < 0) result = 1.f / result;
        return result;
    }
};
```


"
0049 Group Anagrams;"https://leetcode.com/problems/group-anagrams/description/

* algorithms
* Medium (44.90%)
* Total Accepted:    300.2K
* Total Submissions: 668.2K
* Testcase Example:  '[""eat"",""tea"",""tan"",""ate"",""nat"",""bat""]'

Given an array of strings, group anagrams together.

Example:


Input: [""eat"", ""tea"", ""tan"", ""ate"", ""nat"", ""bat""],
Output:
[
  [""ate"",""eat"",""tea""],
  [""nat"",""tan""],
  [""bat""]
]

Note:


	All inputs will be in lowercase.
	The order of your output does not matter.







";"
思路：将单词按字母排序后值作为key，然后挂到哈希表下的vector中，最终取出来即可。

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> hashmap;
        for (auto &str : strs) { 
            auto tmp = str; sort(begin(tmp), end(tmp)); 
            hashmap[tmp].push_back(str); 
        }
        vector<vector<string>> result;
        for (auto &pair : hashmap) result.push_back(pair.second);
        return move(result);
    }
};
```


"
0048 Rotate Image;"https://leetcode.com/problems/rotate-image/description/

* algorithms
* Medium (46.94%)
* Total Accepted:    228K
* Total Submissions: 485.6K
* Testcase Example:  '[[1,2,3],[4,5,6],[7,8,9]]'

You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:


Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


Example 2:


Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]







";"
思路：先沿着主对角线交换，再沿着中轴线左右交换一次，注意不要重复交换了。

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& mat) {
        if (mat.empty()) return;
        const int ROW = mat.size(), COL = mat[0].size();
        for (int i=0; i<ROW; i++) for (int j=i+1; j<COL; j++) 
            swap(mat[i][j], mat[j][i]);
        for (int i=0; i<ROW; i++) for (int j=0; j<COL/2; j++) 
            swap(mat[i][j], mat[i][COL-1-j]);
    }
};
```


"
0047 Permutations II;"https://leetcode.com/problems/permutations-ii/description/

* algorithms
* Medium (39.24%)
* Total Accepted:    223.3K
* Total Submissions: 568.9K
* Testcase Example:  '[1,1,2]'

Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:


Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]







";"
思路：和46题比起来，多了重复的数字，因此要加上去重的逻辑，已经swap过的值就不再swap了。

f(0, [1,1,2]) = f(1, [1,1,2]) + ~~f(1, [1,1,2])~~ + f(1, [1,2,1]) 

注意，要用哈希表，例如 [1,1,2,2]这样的情况，在f(0,...) 到 f(1, ...) 递推的过程中，不仅仅1不能和1交换，1也不能和2交换。


```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> result;
        dfs(nums, 0, result);
        return result;
    }
    
    void dfs(vector<int>& nums, int p, vector<vector<int>>& result) {
        if (p == nums.size()-1) { result.push_back(nums); return; }
        set<int> tbl;
        for (int i=p; i<nums.size(); i++) {
            if (tbl.insert(nums[i]).second == false) continue;
            swap(nums[i], nums[p]);
            dfs(nums, p+1, result);
            swap(nums[i], nums[p]);
        }
    }
};
```

先排序，后去重，不知道哪出问题了

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> result;
        sort(begin(nums), end(nums));
        dfs(nums, 0, result);
        return result;
    }
    
    void dfs(vector<int>& nums, int p, vector<vector<int>>& result) {
        if (p == nums.size()-1) { result.push_back(nums); return; }
        for (int i=p; i<nums.size(); i++) {
            if (i>p && nums[i]==nums[i-1]) continue;
            swap(nums[i], nums[p]);
            dfs(nums, p+1, result);
            swap(nums[i], nums[p]);
        }
    }
};
```


"
0046 Permutations;"https://leetcode.com/problems/permutations/description/

* algorithms
* Medium (53.52%)
* Total Accepted:    343.3K
* Total Submissions: 641.2K
* Testcase Example:  '[1,2,3]'

Given a collection of distinct integers, return all possible permutations.

Example:


Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]








";"
思路：f(0, [1,2,3]) = f(1, [1,2,3]) + f(1, [2,1,3]) + f(1, [3,2,1]); 

递归求解即可，即[1,2,3]的全排列，等于将各个元素分别提到第一个，然后和剩余元素全排列的结果拼接在一起。

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> result;
        dfs(nums, 0, result);
        return result;
    }
    
    void dfs(vector<int>& nums, int p, vector<vector<int>>& result) {
        if (p == nums.size()-1) { result.push_back(nums); return; }
        for (int i=p; i<nums.size(); i++) {
            swap(nums[p], nums[i]);
            dfs(nums, p+1, result);
            swap(nums[p], nums[i]);
        }
    }
};
```


"
0045 Jump Game II;"https://leetcode.com/problems/jump-game-ii/description/

* algorithms
* Hard (27.53%)
* Total Accepted:    155.9K
* Total Submissions: 566K
* Testcase Example:  '[2,3,1,1,4]'

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

Example:


Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.

Note:

You can assume that you can always reach the last index.







";"
1.45%，很慢的一个解决方法。

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int last = nums.size()-1, jumps = 0, i = 0;
        while (true) {
            for (i=0; i<last; i++) if (nums[i] + i >= last) break;
            last = i, jumps++;
            if (i == 0) return jumps;
        }
        return jumps;
    }
};
```

discuss里有一个很快的办法，单次循环。nums[0] + 0，是第一步能到的最远的位置。在(0, nums[0]+0]区间内，都是第一步能reach的位置，计算这中间的第i2个元素跳的最远，位置是nums[i2]+i2，那么在(nums[0]+0, nums[i2]+i2]，是第二步能跳到的区间。再继续下去，就能计算最终到达的位置。

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int jumps = 0, reached = 0, reaching = 0;
        for (int i = 0; i < nums.size()-1; i++) {
            reaching = max(reaching, i + nums[i]);
            if (i == reached) {
                jumps++;
                reached = reaching;
            }
        }
        return jumps;
    }
};
```


"
0044 Wildcard Matching;"https://leetcode.com/problems/wildcard-matching/description/

* algorithms
* Hard (22.39%)
* Total Accepted:    163.7K
* Total Submissions: 731.1K
* Testcase Example:  '""aa""\n""a""'

Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.


'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).


The matching should cover the entire input string (not partial).

Note:


	s could be empty and contains only lowercase letters a-z.
	p could be empty and contains only lowercase letters a-z, and characters like ? or *.


Example 1:


Input:
s = ""aa""
p = ""a""
Output: false
Explanation: ""a"" does not match the entire string ""aa"".


Example 2:


Input:
s = ""aa""
p = ""*""
Output: true
Explanation: '*' matches any sequence.


Example 3:


Input:
s = ""cb""
p = ""?a""
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.


Example 4:


Input:
s = ""adceb""
p = ""*a*b""
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring ""dce"".


Example 5:


Input:
s = ""acdcb""
p = ""a*c?b""
Output: false







";"
```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        const int slen = s.length(), plen = p.length();
        if ((slen==0 && plen==0) || (slen==0 && p==""*"")) return true;
        return DFS(s, 0, p, 0);
    }
    
    bool DFS(const string& s, int si, const string& p,int pi) {
        if (si == s.length() && pi == p.length()) return true;
        if (pi == p.length()) return false;
        if (p[pi] == '*') 
            for (int i=0; si+i<=s.length(); i++) if (DFS(s, si+i, p, pi+1)) return true; 
        if ((p[pi] == '?' || s[si] == p[pi]) && DFS(s, si+1, p, pi+1)) return true;
        return false;
    }
};
```

用动态规划的思路，dp[i+1][j+1] <=> s[0,i] =~ p[0,j]。那么，dp[i+1][j+1]可以通过以下来推导：

* dp[i][j] 且 ( s[i]==p[j] 或 p[j] == '\*' 或 p[j] == '?' )
* (dp[i+1][j] 或 dp[i][j+1]) 或 p[j] == '\*'

其中部分二的情况，其实是在1中覆盖了：如 `[acc, a*c]`当处于`[acc, a*]`时，2的推导不满足，因为p[j]不等于`*`，但是在`[ac, a*]`时，满足1的情况。只要有一个推导能推导出来就可以了。

初始时，需要初始化掉第一行和第一列的值。dp[0][0]，由题意["""",""""]结果是1.

第一行：当p始终为""\*""时，值就会为1，如：`[ , *]`、`[ , **]`、`[ , ***]`

第一列：空的p匹配任何非空的s，结果都是0

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        const int slen = s.length(), plen = p.length();
        vector<vector<int>> dp(slen+1, vector<int>(plen+1, 0)); dp[0][0]   = 1;
        for (int i=0; i<slen; i++)                              dp[i+1][0] = 0;
        for (int j=0; j<plen; j++) if (p[j]=='*' && dp[0][j])   dp[0][j+1] = 1;
        for (int i=0; i<slen; i++) for (int j=0; j<plen; j++) {
            dp[i+1][j+1] = dp[i][j] && (s[i]==p[j] || p[j]=='?' || p[j]=='*');
            dp[i+1][j+1] = dp[i+1][j+1] || p[j]=='*' && (dp[i+1][j] || dp[i][j+1]);
        }
        return dp[slen][plen];
    }
};
```

稍微做点优化，因为dp默认值是0，所以很多操作可以不要：

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        const int slen = s.length(), plen = p.length();
        vector<vector<int>> dp(slen+1, vector<int>(plen+1, 0)); dp[0][0] = 1;
        for (int j=0; j<plen; j++) if (p[j]=='*') dp[0][j+1] = 1; else break;
        for (int i=0; i<slen; i++) for (int j=0; j<plen; j++) {
            dp[i+1][j+1] = dp[i][j] && (s[i]==p[j] || p[j]=='?' || p[j]=='*');
            dp[i+1][j+1] = dp[i+1][j+1] || p[j]=='*' && (dp[i+1][j] || dp[i][j+1]);
        }
        return dp[slen][plen];
    }
};
```


"
0043 Multiply Strings;"https://leetcode.com/problems/multiply-strings/description/

* algorithms
* Medium (30.00%)
* Total Accepted:    185.4K
* Total Submissions: 617.9K
* Testcase Example:  '""2""\n""3""'

Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.

Example 1:


Input: num1 = ""2"", num2 = ""3""
Output: ""6""

Example 2:


Input: num1 = ""123"", num2 = ""456""
Output: ""56088""


Note:


	The length of both num1 and num2 is < 110.
	Both num1 and num2 contain only digits 0-9.
	Both num1 and num2 do not contain any leading zero, except the number 0 itself.
	You must not use any built-in BigInteger library or convert the inputs to integer directly.







";"
思路：细节考察，模拟乘法的计算过程。

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1==""0"" || num2==""0"") return ""0"";
        int carry=0, len1=num1.length(), len2=num2.length(); string result;
        for (int i=len1-1; i>=0; --i) {
            int k=len1-1-i, j=len2-1;
            while (j>=0 || carry) {
                int tmp = 0;
                if (j>=0) tmp = (num1[i]-'0') * (num2[j]-'0');
                if (k>=result.length()) result.push_back('0');
                tmp += carry+result[k]-'0'; carry = tmp/10; tmp = tmp%10;
                result[k++] = tmp + '0';
                --j;
            } 
        }
        reverse(result.begin(), result.end());
        return move(result);
    }
};
```

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1==""0"" || num2==""0"") return ""0"";
        reverse(num1.begin(), num1.end()); 
        reverse(num2.begin(), num2.end());
        int carry=0; string result(num1.size()+num2.size(), '0');
        for (int i=0; i<num1.length(); ++i) {
            int k=i, j=0;
            while (j<num2.length() || carry) {
                int tmp = 0;
                if (j<num2.length()) tmp = (num1[i]-'0') * (num2[j]-'0');
                tmp += carry + result[k] - '0'; carry = tmp/10; tmp = tmp%10;
                result[k++] = tmp + '0';
                j++;
            } 
        }
        reverse(result.begin(), result.end());
        int l=0; while (result[l]=='0') l++;
        return result.substr(l);
    }
};
```


"
0042 Trapping Rain Water;"https://leetcode.com/problems/trapping-rain-water/description/

* algorithms
* Hard (41.99%)
* Total Accepted:    260.4K
* Total Submissions: 619.8K
* Testcase Example:  '[0,1,0,2,1,0,1,3,2,1,2,1]'

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.


The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!

Example:


Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6






";"
思路：用栈来跟踪两个能存水的bar的索引。

* 当栈顶比当前bar的要矮时，说明还没遇到合适的bar，先压栈。
* 当栈顶比当前的bar要高时，则弹出栈顶，一直到和当前的bar略高的元素。
    - 如果某次出栈以后，栈为空，则说明cur要比栈里所有的bar都高，可以计算两者之间的高度了。
* 如果一直遇不到更高的bar，说明栈里存在更高的元素，但是可以通过计算栈里相邻的元素之间的水量来计算总水量。

```cpp
class Solution {
public:
    int trap(vector<int>& heights) {
        int cur = 0, low = 0, sum = 0;
        stack<int> s; s.push(cur++);
        while (cur < heights.size()) {
            if      (heights[s.top()] >  heights[cur]) { s.push(cur++); }
            else if (heights[s.top()] <= heights[cur]) { 
                low = s.top(); s.pop(); 
                if (s.empty()) { 
                    (cur - low > 1) && (sum += trap(heights, low, cur)); 
                    s.push(cur++); 
                }
            }
        }
        
        cur = s.top(); s.pop();
        while (!s.empty()) {
            low =  s.top(); s.pop();
            sum += trap(heights, low, cur);
            cur =  low;
        }
        
        return sum;
    }
    
    int trap(vector<int>& heights, int low, int cur) {
        int sum = 0; int bar = min(heights[low], heights[cur]);
        for (int i = low+1; i < cur; i++)  sum += bar - heights[i];
        return sum;
    } 
};
```

看discuss里，还有个非常巧妙的思路。可以这么理解，假设在最右侧存在一个最高的bar，比数组里所有的都要高。那么计算的过程就变得很简单了，只要从左向右扫描，然后记录目前扫描过程中遇到的最高的bar。然后，与当前扫描的bar相减就得到了想要的数了。

把这个思路略微变化一下，只需要确定前面存在比当前扫描的bar都更高的bar，然后记录一个扫描过程中遇到的最高的bar。就可以通过相减的方式计算最终值了。而确保前面存在更高的bar的方式，是通过左右来回切换扫描，然后扫过更小的那个值，就能保证对面存在更高的bar值了。然后，只要用一个bar记录当前两端夹逼过程中较小的那一侧的bar值就可以了。

```cpp
class Solution {
public:
    int trap(vector<int>& heights) {
        int L = 0, R = heights.size()-1, bar = 0, sum = 0;
        while (L < R) {
            int cur = heights[heights[L] < heights[R] ? L++ : R--];
            bar = max(bar, cur);
            sum += bar - cur;
        }
        return sum;
    }
};
```

还有一种理解简单的思路，先找到一个最高点，然后分别从左边和从右边向中间扫描，这个时候只要记住一个扫描遇到的最高的bar，就是存水的较短的那个bar。

```cpp
class Solution {
public:
    int trap(vector<int>& heights) {
        int peak = 0, sum = 0;
        for (int i=0; i<heights.size(); i++) 
            if (heights[i] > heights[peak]) peak = i;
        for (int i=0, bar=0; i<peak; i++) {
            bar = max(heights[i], bar);
            sum += bar - heights[i];
        }
        for (int i=heights.size()-1, bar=0; i>peak; i--) {
            bar = max(heights[i], bar);
            sum += bar - heights[i];
        }
        return sum;
    }
};
```

感觉这题挺不错的，能测智商。



"
0041 First Missing Positive;"https://leetcode.com/problems/first-missing-positive/description/

* algorithms
* Hard (28.26%)
* Total Accepted:    193.5K
* Total Submissions: 684.7K
* Testcase Example:  '[1,2,0]'

Given an unsorted integer array, find the smallest missing positive integer.

Example 1:


Input: [1,2,0]
Output: 3


Example 2:


Input: [3,4,-1,1]
Output: 2


Example 3:


Input: [7,8,9,11,12]
Output: 1


Note:

Your algorithm should run in O(n) time and uses constant extra space.






";"
思路：遍历数组将数值x放置到对应的下标x-1上，然后遍历找到第一个无序的数字，返回下标加1。

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int len=nums.size(), i=0;
        while(i < len) {
            if (nums[i]> 0 && nums[i]<=len) swap(nums[nums[i]-1], nums[i]);
            if (nums[i]<=0 || nums[i]> len || nums[nums[i]-1]==nums[i]) ++i;
        }
        for (i=0; i<len; ++i) if (nums[i] != i+1) break;
        return i+1;
    }
};
```

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int len=nums.size(), i=0; vector<int> sort(len, 0);
        for (i=0; i<len; i++) if (nums[i]>0 && nums[i]<=len) sort[nums[i]-1] = nums[i];
        for (i=0; i<len; ++i) if (sort[i] != i+1) break;
        return i+1;
    }
};
```


"
0040 Combination Sum II;"https://leetcode.com/problems/combination-sum-ii/description/

* algorithms
* Medium (40.26%)
* Total Accepted:    202.9K
* Total Submissions: 503.7K
* Testcase Example:  '[10,1,2,7,6,1,5]\n8'

Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:


	All numbers (including target) will be positive integers.
	The solution set must not contain duplicate combinations.


Example 1:


Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]


Example 2:


Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]







";"
思路：先排序，后深搜，注意去重。关键是在path选取第n个数字时，保证唯一。

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> result; vector<int> path;
        sort(begin(candidates), end(candidates));
        DFS(candidates, target, 0, path, result);
        return result;
    }
    
    void DFS(vector<int>& nums, int target, int curr, vector<int> &path, vector<vector<int>> &result) {
        if (target <  0) return;
        if (target == 0) { result.push_back(path); return; }
        for (int i=curr; i<nums.size(); i++) {
            if (i>curr && nums[i]==nums[i-1]) continue;
            path.push_back(nums[i]);
            DFS(nums, target-nums[i], i+1, path, result);
            path.pop_back();
        }
    }
};
```
"
0039 Combination Sum;"https://leetcode.com/problems/combination-sum/description/

* algorithms
* Medium (46.82%)
* Total Accepted:    308.9K
* Total Submissions: 659.3K
* Testcase Example:  '[2,3,6,7]\n7'

Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:


	All numbers (including target) will be positive integers.
	The solution set must not contain duplicate combinations.


Example 1:


Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]


Example 2:


Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]








";"
思路：广度搜索，$f(n, [a,b,c]) = f(n-a, [a,b,c]) + f(n-b, [b,c]) + f(n-c, [c])$。注意去重，所有包含a的答案，已经在$f[n-a, [a,b,c]]$中包含了，所以$f(n-b,[b-c])$从b开始。

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> result; vector<int> path;
        sort(begin(candidates), end(candidates));
        DFS(candidates, 0, target, path, result);
        return move(result);
    }
    
    void DFS(const vector<int>& candidates, int lo, int target, vector<int>& path, vector<vector<int>>& result) {
        if (target == 0) { result.push_back(path); return; }
        for (int i = lo; i < candidates.size(); i++) {
            int candidate = candidates[i];
            if (target < candidate) return;
            path.push_back(candidate);
            DFS(candidates, i, target - candidate, path, result);
            path.pop_back();
        }
    }
};
```


"
0038 Count and Say;"https://leetcode.com/problems/count-and-say/description/

* algorithms
* Easy (39.59%)
* Total Accepted:    261.4K
* Total Submissions: 660.1K
* Testcase Example:  '1'

The count-and-say sequence is the sequence of integers with the first five terms as following:


1.     1
2.     11
3.     21
4.     1211
5.     111221


1 is read off as ""one 1"" or 11.
11 is read off as ""two 1s"" or 21.
21 is read off as ""one 2, then one 1"" or 1211.

Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.

Note: Each term of the sequence of integers will be represented as a string.

 

Example 1:


Input: 1
Output: ""1""


Example 2:


Input: 4
Output: ""1211""







";"
思路：打表记录当前到n的所有可能，时间换空间。转换的时候需要考虑细节情况。

```cpp
class Solution {
public:
    string countAndSay(int n) {
        static vector<string> tbl = {""1"", ""11"", ""21"", ""1211"", ""111221""};
        for (int i = tbl.size(); i < n; i++) {
            tbl.push_back(next(tbl.back()));
        }
        return tbl[n-1];
    }
    
    string next(string& s) {
        int cnt = 1; char ch = s[0]; string next;
        for (int i = 1; i <= s.length(); i++) {
            if (i < s.length() && s[i] == s[i-1]) { 
                cnt++; 
            } else if (i < s.length()) {
                next.append(to_string(cnt)).push_back(ch); 
                cnt = 1; ch = s[i];
            } else { 
                next.append(to_string(cnt)).push_back(ch);  
            }
        }
        return move(next);
    }
};
```


"
0037 Sudoku Solver;"https://leetcode.com/problems/sudoku-solver/description/

* algorithms
* Hard (35.67%)
* Total Accepted:    118.9K
* Total Submissions: 333.2K
* Testcase Example:  '[[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""],[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]'

Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:


	Each of the digits 1-9 must occur exactly once in each row.
	Each of the digits 1-9 must occur exactly once in each column.
	Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.


Empty cells are indicated by the character '.'.


A sudoku puzzle...


...and its solution numbers marked in red.

Note:


	The given board contain only digits 1-9 and the character '.'.
	You may assume that the given Sudoku puzzle will have a single unique solution.
	The given board size is always 9x9.







";"
思路：广搜，按位置遍历，搜索'.'所有可能值，然后递归搜索下去，看看是否能够得出可能解，9ms。

```cpp
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        solveSudoku(board, 0, 0);
    }
    
    bool solveSudoku(vector<vector<char>>& board, int i, int j) {
        if (i == 9)   return true;
        if (board[i][j] != '.') return solveSudoku(board, i=i+(j+1)/9, (j+1)%9);
        
        char tbl[9] = {0}, ch;
        for (int k = 0; k < 9; k++) {
            ch = board[i][k]; if (ch != '.') tbl[ch-'1'] = 1;
            ch = board[k][j]; if (ch != '.') tbl[ch-'1'] = 1;
            ch = board[i/3*3+k/3][j/3*3+k%3];
            if (ch != '.') tbl[ch-'1'] = 1;
        }

        for (int k = 0; k < 9; k++) {
            if (tbl[k] == 1) continue;
            board[i][j] = '1' + k;
            if (solveSudoku(board, i, j)) return true;
        }
        board[i][j] = '.';
        return false;
    }
};
```


"
0036 Valid Sudoku;"https://leetcode.com/problems/valid-sudoku/description/

* algorithms
* Medium (41.94%)
* Total Accepted:    217K
* Total Submissions: 517.1K
* Testcase Example:  '[[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""],[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]'

Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:


	Each row must contain the digits 1-9 without repetition.
	Each column must contain the digits 1-9 without repetition.
	Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.



A partially filled sudoku which is valid.

The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

Example 1:


Input:
[
  [""5"",""3"",""."",""."",""7"",""."",""."",""."","".""],
  [""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],
  [""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],
  [""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],
  [""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],
  [""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],
  [""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],
  [""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],
  [""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]
]
Output: true


Example 2:


Input:
[
  [""8"",""3"",""."",""."",""7"",""."",""."",""."","".""],
  [""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],
  [""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],
  [""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],
  [""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],
  [""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],
  [""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],
  [""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],
  [""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]
]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being 
    modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.


Note:


	A Sudoku board (partially filled) could be valid but is not necessarily solvable.
	Only the filled cells need to be validated according to the mentioned rules.
	The given board contain only digits 1-9 and the character '.'.
	The given board size is always 9x9.








";"
思路：分别按行、列、3x3遍历，看是否满足无重复的数字即可，9 ms。

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        for (int row = 0; row < 9; row++) 
            if (! isValidRowOfSudoku(board, row)) return false;
        for (int col = 0; col < 9; col++) 
            if (! isValidColOfSudoku(board, col)) return false;
        for (int row = 0; row < 9; row += 3) for (int col = 0; col < 9; col += 3) 
            if (! isVaild3x3OfSudoku(board, row, col)) return false;
        return true;
    }
    
    bool isValidRowOfSudoku(vector<vector<char>>& board, int row) {
        char tbl[9]; fill_n(tbl, 9, 1);
        for (int col = 0; col < 9; col++) {
            char ch = board[row][col];
            if      (ch == '.')   continue;
            else if (tbl[ch-'1']) tbl[ch-'1'] = 0;
            else                  return false;
        }
        return true;
    }
 
    bool isValidColOfSudoku(vector<vector<char>>& board, int col) {
        char tbl[9]; fill_n(tbl, 9, 1);
        for (int row = 0; row < 9; row++) {
            char ch = board[row][col];
            if      (ch == '.')   continue;
            else if (tbl[ch-'1']) tbl[ch-'1'] = 0;
            else                  return false;
        }
        return true;
    }
    
    bool isVaild3x3OfSudoku(vector<vector<char>>& board, int row, int col) {
        char tbl[9]; fill_n(tbl, 9, 1);
        for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) {
            char ch = board[row+i][col+j];
            if      (ch == '.')   continue;
            else if (tbl[ch-'1']) tbl[ch-'1'] = 0;
            else                  return false;
        }
        return true;
    }
};
```

思路2：根据上面的答案，将三个for循环缩小为一个，19ms，目前看来循环分开效率要高一些。

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        for (int i = 0; i < 9; i++) {
            char row[9] = {0}, col[9] = {0}, blk[9] = {0};
            for (int j = 0; j < 9; j++) {
                char ch;
                ch = board[i][j];
                if (ch != '.') if (!row[ch-'1']) row[ch-'1'] = 1; else return false;
                ch = board[j][i];
                if (ch != '.') if (!col[ch-'1']) col[ch-'1'] = 1; else return false;
                ch = board[i/3*3+j/3][i%3*3+j%3];
                if (ch != '.') if (!blk[ch-'1']) blk[ch-'1'] = 1; else return false;
            }
        }
        return true;
    }
};
```


"
0035 Search Insert Position;"https://leetcode.com/problems/search-insert-position/description/

* algorithms
* Easy (40.47%)
* Total Accepted:    365.5K
* Total Submissions: 903.2K
* Testcase Example:  '[1,3,5,6]\n5'

Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example 1:


Input: [1,3,5,6], 5
Output: 2


Example 2:


Input: [1,3,5,6], 2
Output: 1


Example 3:


Input: [1,3,5,6], 7
Output: 4


Example 4:


Input: [1,3,5,6], 0
Output: 0







";"
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l = 0, h = nums.size(), m;
        while (l < h) {
            m = (l + h) / 2;
            if (nums[m] < target) {
                l = m + 1;
            } else if (nums[m] > target) {
                h = m;
            } else {
                break;
            }
        }
        return (l + h) / 2;
    }
};
```


"
0034 Find First and Last Position of Element in Sorted Array;"https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/

* algorithms
* Medium (33.01%)
* Total Accepted:    271K
* Total Submissions: 820.5K
* Testcase Example:  '[5,7,7,8,8,10]\n8'

Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example 1:


Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Example 2:


Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]






";"
```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int s = findStartPosition(nums, target);
        if (s == -1) return {-1, -1};
        int e = findEndPosition(nums, target);
        return vector<int>({s, e});
    }
    
    int findStartPosition(vector<int>& nums, int target) {
        int l = 0, h = nums.size(), m, result = -1;
        while (l < h) {
            m = (l + h) / 2;
            if      (nums[m] < target)  { l = m + 1; }
            else if (nums[m] > target)  { h = m; }
            else                        { h = m; result = m; }
        }
        return result;
    }
    
    int findEndPosition(vector<int> &nums, int target) {
        int l = 0, h = nums.size(), m, result = -1;
        while (l < h) {
            m = (l + h) / 2;
            if      (nums[m] < target)  { l = m + 1; }
            else if (nums[m] > target)  { h = m; }
            else                        { l = m + 1; result = m; }
        }
        return result;
    }
};
```


"
0033 Search in Rotated Sorted Array;"https://leetcode.com/problems/search-in-rotated-sorted-array/description/

* algorithms
* Medium (32.66%)
* Total Accepted:    374.2K
* Total Submissions: 1.1M
* Testcase Example:  '[4,5,6,7,0,1,2]\n0'

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:


Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4


Example 2:


Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1






";"
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, h = nums.size();
        while (l < h) {
            int m = (l + h) / 2;
            if (nums[m] < target) {
                if (nums[m] >= nums[0]) l = m + 1; 
                else { if (target >= nums[0]) h = m; else l = m + 1; }
            } else if (nums[m] > target) {
                if (nums[m] >= nums[0]) { if (target >= nums[0]) h = m; else l = m + 1; }
                else h = m;
            } else {
                return m;
            }
        }
        return -1;
    }
};
```

* 在正常的二分查找逻辑中，增加nums[m]和target是否在同一侧的判断。
* 判断的方法为，中间是否存在nums[0]。


```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, h = nums.size();
        while (l < h) {
            int m = (l + h) / 2;
            if (nums[m] < target) {
                if (nums[m] < nums[0] && nums[0] <= target ) h = m;     else l = m + 1;
            } else if (nums[m] > target) {
                if (target  < nums[0] && nums[0] <= nums[m]) l = m + 1; else h = m;
            } else {
                return m;
            }
        }
        return -1;
    }
};
```


"
0032 Longest Valid Parentheses;"https://leetcode.com/problems/longest-valid-parentheses/description/

* algorithms
* Hard (24.96%)
* Total Accepted:    174.7K
* Total Submissions: 699.7K
* Testcase Example:  '""(()""'

Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:


Input: ""(()""
Output: 2
Explanation: The longest valid parentheses substring is ""()""


Example 2:


Input: "")()())""
Output: 4
Explanation: The longest valid parentheses substring is ""()()""








";"
思路：动态规划，有效的括号序列是由多个单有效括号序列组成的：(...)(...)(...) 。设f[i]表示以i为结束位置的最长有效括号序列的长度，则当[l,i]有效时f[i] = f[l-1] + i-l+1

```cpp
class Solution {
public:
    int longestValidParentheses(string& s) {
        stack<int> t; vector<int> f(s.length(), 0); int result = 0;
        for (int i=0; i<s.length(); ++i) {
            if (s[i] == '(') t.push(i);
            else if (!t.empty()) {
                int l = t.top(); t.pop();
                f[i] = i - l + 1 + (l>0 ? f[l-1] : 0);
                result = max(result, f[i]);
            }
        }
        return result;
    }
};
```


"
0031 Next Permutation;"https://leetcode.com/problems/next-permutation/description/

* algorithms
* Medium (30.07%)
* Total Accepted:    216.1K
* Total Submissions: 718.6K
* Testcase Example:  '[1,2,3]'

Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1






";"
思路：

1. 从尾部开始找到第一个不满足逆序序列的元素i
2. 在逆序序列中找到最接近的较小元素j
3. 交换i和j，并将逆序序列反置

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i=0, j=0, len=nums.size();
        i=len-2; while (i>=0 && nums[i+1]<=nums[i]) --i;
        if (i == -1) { reverse(nums.begin(), nums.end()); return; }
        j=len-1; while (j>i && nums[i]>=nums[j]) --j;
        swap(nums[i], nums[j]);
        reverse(nums.begin()+i+1, nums.end());
    }
};
```


"
0030 Substring with Concatenation of All Words;"https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/

* algorithms
* Hard (23.18%)
* Total Accepted:    124K
* Total Submissions: 534.7K
* Testcase Example:  '""barfoothefoobarman""\n[""foo"",""bar""]'

You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

Example 1:


Input:
  s = ""barfoothefoobarman"",
  words = [""foo"",""bar""]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are ""barfoor"" and ""foobar"" respectively.
The output order does not matter, returning [9,0] is fine too.


Example 2:


Input:
  s = ""wordgoodgoodgoodbestword"",
  words = [""word"",""good"",""best"",""word""]
Output: []








";"
思路：用的map，耗时206ms，超过45%

```cpp
class Solution {
public:
    vector<int> findSubstring(const string& s, vector<string>& words) {
        map<string, int> tbl; map<string, int> vst;
        vector<int> result;
        if (words.empty()) return result;
        int lenW = words[0].length(), lenT = words.size() * lenW, lenS = s.length();
        if (s.size() < lenT) return result;
        for (auto &word : words) tbl[word] = tbl.find(word) == tbl.end() ? 1 : tbl[word]+1;
        for (int i = 0; i <= lenS - lenT; i++) {
            string tar = s.substr(i, lenW);
            if (tbl.find(tar) != tbl.end()) {
                int fnd = 1;
                vst[tar] = 1;
                for (int j = lenW; j < lenT; j += lenW) {
                    tar = s.substr(i+j, lenW);
                    if (tbl.find(tar) != tbl.end()) {
                        vst[tar] = vst.find(tar) == vst.end() ? 1 : vst[tar]+1;
                        if (tbl[tar] >= vst[tar]) fnd++; else break;
                    } else break;
                }
                vst.clear();
                if (fnd == words.size()) result.push_back(i);
            }
        }
        return result;
    }
};
```

用unorderd_map试试，好像还慢了一些，299ms，击败24%

```cpp
class Solution {
public:
    vector<int> findSubstring(const string& s, vector<string>& words) {
        unordered_map<string, int> tbl; unordered_map<string, int> vst;
        vector<int> result;
        if (words.empty()) return result;
        int lenW = words[0].length(), lenT = words.size() * lenW, lenS = s.length();
        if (s.size() < lenT) return result;
        for (auto &word : words) tbl[word] = tbl.find(word) == tbl.end() ? 1 : tbl[word]+1;
        for (int i = 0; i <= lenS - lenT; i++) {
            string tar = s.substr(i, lenW);
            if (tbl.find(tar) != tbl.end()) {
                int fnd = 1;
                vst[tar] = 1;
                for (int j = lenW; j < lenT; j += lenW) {
                    tar = s.substr(i+j, lenW);
                    if (tbl.find(tar) != tbl.end()) {
                        vst[tar] = vst.find(tar) == vst.end() ? 1 : vst[tar]+1;
                        if (tbl[tar] >= vst[tar]) fnd++; else break;
                    } else {
                        break;
                    }
                }
                vst.clear();
                if (fnd == words.size()) result.push_back(i);
            }
        }
        return result;
    }
};
```

用unordered_multiset，直接超时。

```cpp
class Solution {
public:
    vector<int> findSubstring(const string& s, vector<string>& words) {
        unordered_multiset<string> tbl; unordered_multiset<string> vst;
        vector<int> result;
        if (words.empty()) return result;
        int lenW = words[0].length(), lenT = words.size() * lenW, lenS = s.length();
        if (s.size() < lenT) return result;
        for (auto &word : words) tbl.insert(word);
        for (int i = 0; i <= lenS-lenT; i++) {
            string tar = s.substr(i, lenW);
            if (tbl.find(tar) != tbl.end()) {
                int fnd = 1;
                vst.insert(tar);
                for (int j = lenW; j < lenT; j += lenW) {
                    tar = s.substr(i+j, lenW);
                    if (tbl.find(tar) != tbl.end() && tbl.count(tar) > vst.count(tar)) {
                        vst.insert(tar);
                        fnd++;
                    } else {
                        break;
                    }
                }
                vst.clear();
                if (fnd == words.size()) result.push_back(i);
            }
        }
        return result;
    }
};
```

貌似还有O(n)的解法，没想出来。


"
0029 Divide Two Integers;"https://leetcode.com/problems/divide-two-integers/description/

* algorithms
* Medium (16.09%)
* Total Accepted:    181.8K
* Total Submissions: 1.1M
* Testcase Example:  '10\n3'

Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero.

Example 1:


Input: dividend = 10, divisor = 3
Output: 3

Example 2:


Input: dividend = 7, divisor = -3
Output: -2

Note:


	Both dividend and divisor will be 32-bit signed integers.
	The divisor will never be 0.
	Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.








";"
思路：

* unsigned int(0 ~ 4294967295), INT_MIN(-2147483648), INT_MAX(2147483647)。
* INT_MAX的二进制表示为：0111 1111 1111 1111 1111 1111 1111 1111
* INT_MIN的二进制表示为：1000 0000 0000 0000 0000 0000 0000 0000
* int型最高为为符号位，0正1负。CPU眼中只有数值，INT_MAX + 1 == INT_MIN。
* unsigned int最大表示： 1111 1111 1111 1111 1111 1111 1111 1111
* unsigned int可以防止转换为正数时溢出。
* 当unsigned int值为-INT_MIN(2147483648)再左移会溢出。
* \+ 比 << 优先级要高，详见：http://www.jb51.net/article/37282.htm

```cpp
class Solution {
public:
    int divide(int dividend, int divisor) {
        long long a = dividend>=0 ? dividend : -(long long)dividend;
        long long b = divisor>=0  ? divisor  : -(long long)divisor;
        long long r = 0; int i = 0;
        while (b<<1 < a) { i++; b<<=1; };
        while (a>=b || i>0) {
            a -= b; r += 1<<i;
            while (a < b && i > 0) { i--; b>>=1; }
        }
        if ((dividend^divisor)>>31) r = -r;
        else if (r > INT_MAX)       r = INT_MAX;
        return r;
    }
};
```

```cpp
class Solution {
public:
    int divide(int dividend, int divisor) {
        unsigned int a = dividend>=0 ? dividend : -dividend;
        unsigned int b = divisor>=0  ? divisor  : -divisor;
        int r=0; long long bb; int i;
        while (a >= b) for (i=0, bb=b; a >= bb; i++, bb<<=1) {
            a -= bb; r += 1<<i;
        }
        if      ((dividend^divisor)>>31)     r = -r;
        else if ((unsigned int)r > INT_MAX)  r = INT_MAX;
        return r;
    }
};
```


"
0028 Implement strStr();"https://leetcode.com/problems/implement-strstr/description/

* algorithms
* Easy (31.29%)
* Total Accepted:    387.5K
* Total Submissions: 1.2M
* Testcase Example:  '""hello""\n""ll""'

Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:


Input: haystack = ""hello"", needle = ""ll""
Output: 2


Example 2:


Input: haystack = ""aaaaa"", needle = ""bba""
Output: -1


Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().






";"
思路：暴力求解
耗时3ms

```cpp
class Solution {
public:
    int strStr(const string &haystack, const string &needle) {
        int lenH = haystack.length(), lenN = needle.length();
        if (lenH < lenN) return -1;
        for (int i = 0; i <= lenH - lenN; i++) {
            bool eq = true;
            for (int j = 0; j < lenN; j++) 
                if (haystack[i+j] != needle[j]) { eq = false; break; }
            if (eq) return i;
        }
        return -1;
    }
};
```


"
0027 Remove Element;"https://leetcode.com/problems/remove-element/description/

* algorithms
* Easy (43.64%)
* Total Accepted:    376K
* Total Submissions: 861.4K
* Testcase Example:  '[3,2,2,3]\n3'

Given an array nums and a value val, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example 1:


Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.


Example 2:


Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.

Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:


// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}






";"
```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int i = 0, j = 0;
        for (j = 0; j < nums.size(); j++) {
            if (nums[j] == val) continue;
            nums[i++] = nums[j];
        }
        return i;
    }
};
```


"
0026 Remove Duplicates from Sorted Array;"https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/

* algorithms
* Easy (39.72%)
* Total Accepted:    533K
* Total Submissions: 1.3M
* Testcase Example:  '[1,1,2]'

Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:


Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.

Example 2:


Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.


Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:


// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}






";"```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        auto len = nums.size();
        if (len <= 1) return len;
        int last = nums[0], i = 1, j = 1;
        while (j < len) {
            if (nums[j] != last) { nums[i++] = nums[j]; last = nums[j]; }
            j++;
        }
        return i;
    }
};
```


"
0025 Reverse Nodes in k-Group;"https://leetcode.com/problems/reverse-nodes-in-k-group/description/

* algorithms
* Hard (35.41%)
* Total Accepted:    169.7K
* Total Submissions: 479.1K
* Testcase Example:  '[1,2,3,4,5]\n2'

Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.




Example:

Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5

Note:


	Only constant extra memory is allowed.
	You may not alter the values in the list's nodes, only nodes itself may be changed.







";"
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (k == 1) return head;
        ListNode dummy(0); dummy.next = head;
        ListNode *p = &dummy, *q, *hold, *first, *last;
        while (true) {
            q = p;
            for (int i = 0; i < k; ++i) if (q && q->next) q = q->next; else return dummy.next;
            hold = q->next; q->next = nullptr;
            reverseList(p->next, &first, &last);
            p->next = first; last->next = hold; p = last;
        }
        
        return dummy.next;
    }
    
    void reverseList(ListNode *head, ListNode **first, ListNode **last) {
        static ListNode dummy(0); dummy.next = head; 
        ListNode *a = &dummy, *b = a->next, *c = nullptr;
        while (b) { c = b->next; b->next = a; a = b; b = c; }
        *first = a; *last = head; head->next = nullptr;
    }
};
```


"
0024 Swap Nodes in Pairs;"https://leetcode.com/problems/swap-nodes-in-pairs/description/

* algorithms
* Medium (43.27%)
* Total Accepted:    284.7K
* Total Submissions: 657.6K
* Testcase Example:  '[1,2,3,4]'

Given a linked list, swap every two adjacent nodes and return its head.

You may not modify the values in the list's nodes, only nodes itself may be changed.

 

Example:


Given 1->2->3->4, you should return the list as 2->1->4->3.







";"
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dummy(0); dummy.next = head;
        ListNode *p = &dummy, *a, *b, *tmp;
        while (true) {
            if (p->next) a = p->next; else break;
            if (a->next) b = a->next; else break;
            tmp = b->next;
            b->next = a; a->next = tmp; p->next = b;
            p = a;
        }
        return dummy.next;
    }
};
```


"
0023 Merge k Sorted Lists;"https://leetcode.com/problems/merge-k-sorted-lists/description/

* algorithms
* Hard (33.08%)
* Total Accepted:    346.4K
* Total Submissions: 1M
* Testcase Example:  '[[1,4,5],[1,3,4],[2,6]]'

Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:


Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6







";"
思路：
1. 优先级队列，压入每个链表当前节点.
2. 取出最小节点，组成新链表，压入该节点的非空next.
3. 队列为空时结束.

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        struct NodeGreater { bool operator()(ListNode *lhs, ListNode *rhs) { 
            return lhs->val > rhs->val; 
        } };
        priority_queue<ListNode*, vector<ListNode*>, NodeGreater> q;
        for (auto node : lists) if (node) q.push(node); 
        ListNode dummy(0), *p = &dummy; p->next = nullptr;
        while (!q.empty()) {
            ListNode *node = q.top(); q.pop();
            p->next = node; p = p->next;
            if (node->next) q.push(node->next);
        }
        return dummy.next;
    }
};
```


"
0022 Generate Parentheses;"https://leetcode.com/problems/generate-parentheses/description/

* algorithms
* Medium (53.27%)
* Total Accepted:    304.7K
* Total Submissions: 571.8K
* Testcase Example:  '3'


Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.



For example, given n = 3, a solution set is:


[
  ""((()))"",
  ""(()())"",
  ""(())()"",
  ""()(())"",
  ""()()()""
]







";"
```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> result; string path;
        generateParenthesis(0, 0, n, path, result);
        return move(result);
    }
    
    void generateParenthesis(int o, int c, int n, string &path, vector<string>& result) {
        if (o + c == n*2) { result.push_back(path); return; }
        
        if (o < n) { 
            path.push_back('('); generateParenthesis(o+1, c, n, path, result); path.pop_back(); 
        }
        
        if (o > c && c < n) { 
            path.push_back(')'); generateParenthesis(o, c+1, n, path, result); path.pop_back(); 
        }
    }
};
```


"
0021 Merge Two Sorted Lists;"https://leetcode.com/problems/merge-two-sorted-lists/description/

* algorithms
* Easy (45.96%)
* Total Accepted:    519.5K
* Total Submissions: 1.1M
* Testcase Example:  '[1,2,4]\n[1,3,4]'

Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4







";"
使用优先级队列解决该问题

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        struct NodeGreater { bool operator()(ListNode *lhs, ListNode *rhs) { return lhs->val > rhs->val; } };
        priority_queue<ListNode *, vector<ListNode *>, NodeGreater> q;
        if (l1) q.push(l1); if (l2) q.push(l2);
        ListNode dummy = ListNode(0); ListNode *p = &dummy;
        while (!q.empty()) {
            ListNode *tmp = q.top(); q.pop();
            if (tmp->next) q.push(tmp->next);
            p->next = tmp; p = p->next;
        }
        p->next = nullptr;
        return dummy.next;
    }
};
```


"
0020 Valid Parentheses;"https://leetcode.com/problems/valid-parentheses/description/

* algorithms
* Easy (35.94%)
* Total Accepted:    525.5K
* Total Submissions: 1.5M
* Testcase Example:  '""()""'

Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:


	Open brackets must be closed by the same type of brackets.
	Open brackets must be closed in the correct order.


Note that an empty string is also considered valid.

Example 1:


Input: ""()""
Output: true


Example 2:


Input: ""()[]{}""
Output: true


Example 3:


Input: ""(]""
Output: false


Example 4:


Input: ""([)]""
Output: false


Example 5:


Input: ""{[]}""
Output: true








";"
使用单纯的比较 beat 15.3%

```cpp 
class Solution {
public:
    bool isValid(string s) {
        stack<char> stk;
        for (auto c : s) {
            if (!stk.empty() && (stk.top()=='(' && c==')' || stk.top()=='[' && c==']' || stk.top()=='{' && c=='}')) { 
                stk.pop(); 
            } else {
                stk.push(c);
            }
        }
        return stk.empty();
    }
};
```

使用hashmap，beat 1.73%

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> stk;
        for (auto c : s) {
            unordered_map<char, char> tbl = {{'(',')'},{'{','}'},{'[',']'}};
            if (!stk.empty() && tbl[stk.top()] == c) { 
                stk.pop(); 
            } else {
                stk.push(c);
            }
        }
        return stk.empty();
    }
};
```

打表法 beat 15%

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> stk; char tbl[256] = {0};
        tbl['('] = ')'; tbl['['] = ']'; tbl['{'] = '}';
        for (auto c : s) {
            if (!stk.empty() && tbl[stk.top()] == c) { 
                stk.pop(); 
            } else {
                stk.push(c);
            }
        }
        return stk.empty();
    }
};
```


"
0019 Remove Nth Node From End of List;"https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/

* algorithms
* Medium (34.01%)
* Total Accepted:    358.2K
* Total Submissions: 1.1M
* Testcase Example:  '[1,2,3,4,5]\n2'

Given a linked list, remove the n-th node from the end of list and return its head.

Example:


Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.


Note:

Given n will always be valid.

Follow up:

Could you do this in one pass?






";"
两趟遍历

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *p;
        int len = 0; for (p = head; p != nullptr; p = p->next) len++;
        if (n >  len) return head;
        if (n == len) return head->next;
        p = head; for (int i = 0; i < len - n - 1; i++) p = p->next;
        ListNode *tmp = p->next;
        p->next = p->next->next;
        delete tmp;
        return head;
    }
};
```

单趟遍历

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *p = head;
        for (int i = 0; i < n; i++) { if (!p) return head; p = p->next; }
        ListNode dummy(0); ListNode *pre = &dummy; pre->next = head;
        for (; p != nullptr; p = p->next) { pre = pre->next; }
        ListNode *tmp = pre->next;
        pre->next = pre->next->next;
        delete tmp;
        return dummy.next;
    }
};
```

注意，如果把delete tmp注释掉，速度就能快上很多。不注释，就只能打败6%。深深怀疑，大部分同志忘记了delete tmp了。


"
0018 4Sum;"https://leetcode.com/problems/4sum/description/

* algorithms
* Medium (29.77%)
* Total Accepted:    214.4K
* Total Submissions: 719.8K
* Testcase Example:  '[1,0,-1,0,-2,2]\n0'

Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

The solution set must not contain duplicate quadruplets.

Example:


Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]







";"
思路：在3Sum的基础上，多做一层循环

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result; int len=nums.size();
        for (int i=0; i<=len-4;) {
            for (int j=i+1; j<=len-3;) {
                for (int k=j+1, l=len-1; k<l;) {
                    int sum = nums[i] + nums[j] + nums[k] + nums[l];
                    if      (sum > target) for (l--; k<l&&nums[l]==nums[l+1]; l--);
                    else if (sum < target) for (k++; j<k&&nums[k]==nums[k-1]; k++);
                    else if (sum == target) {
                        result.push_back({nums[i], nums[j], nums[k], nums[l]});
                        for (k++, l--; k<l&&nums[k]==nums[k-1]; k++);
                    } 
                }
                for (j++; j<=len-3&&nums[j-1]==nums[j]; j++);
            }
            for (i++; i<=len-4&&nums[i-1]==nums[i]; i++);
        }
        return move(result);
    }
};
```

整理下，可以改改就能过threeSum和twoSum，还有点优化，在nSum中通过最小值和最大值乘以n和target做比较来截枝，这边就没做了。

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result; vector<int> path;
        if (nums.size() < 4) return result;
        sort(nums.begin(), nums.end());
        fourSum(nums, target, 0, path, result);
        return move(result);
    }
    
    void fourSum(vector<int> &nums, int target, int low, vector<int> &path, vector<vector<int>> &result) {
        for (int i=low; i<=nums.size()-4; i++) {
            if (i>low && nums[i-1]==nums[i]) continue;
            path.push_back(nums[i]);
            threeSum(nums, target-nums[i], i+1, path, result);
            path.pop_back();
        }
    }
    
    void threeSum(vector<int> &nums, int target, int low, vector<int> &path, vector<vector<int>> &result) {
        for (int i=low; i<=nums.size()-3; i++) {
            if (i>low && nums[i-1] == nums[i]) continue;
            path.push_back(nums[i]);
            twoSum(nums, target-nums[i], i+1, path, result);
            path.pop_back();
        }
    }
    
    void twoSum(vector<int> &nums, int target, int low, vector<int> &path, vector<vector<int>> &result) {
        int i=low, j=nums.size()-1;
        while (i < j) {
            int sum = nums[i] + nums[j];
            if (sum == target) {
                vector<int> tmp = path; tmp.push_back(nums[i]); tmp.push_back(nums[j]);
                result.push_back(tmp);
                for (i++, j--; i<j && nums[i-1]==nums[i]; ++i);
            } 
            else if (sum > target) for (j--; i<j&&nums[j]==nums[j+1]; j--);
            else if (sum < target) for (i++; i<j&&nums[i-1]==nums[i]; i++);
        }
    }
};
```


"
0017 Letter Combinations of a Phone Number;"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/

* algorithms
* Medium (40.48%)
* Total Accepted:    351.5K
* Total Submissions: 868.1K
* Testcase Example:  '""23""'

Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.



Example:


Input: ""23""
Output: [""ad"", ""ae"", ""af"", ""bd"", ""be"", ""bf"", ""cd"", ""ce"", ""cf""].


Note:

Although the above answer is in lexicographical order, your answer could be in any order you want.






";"
```cpp
class Solution {
public:
    vector<string> letterCombinations(const string& digits) {
        static vector<string> ss = {""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};
        vector<string> result;
        for (auto d : digits) {
            int idx = d - '0' - 2;
            if (idx < 0 || idx >= 8) { continue; }
            string s = ss[idx];
            if (result.empty()) { result.push_back(""""); }
            vector<string> tmp; result.swap(tmp);
            for (auto c : s) for (auto it : tmp) {
                it.push_back(c); result.push_back(it);
            }
        }
        return move(result);
    }
};
```

"
0016 3Sum Closest;"https://leetcode.com/problems/3sum-closest/description/

* algorithms
* Medium (41.04%)
* Total Accepted:    291.4K
* Total Submissions: 708.8K
* Testcase Example:  '[-1,2,1,-4]\n1'

Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

Example:


Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).








";"
13ms

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int l = 0, len = nums.size(), result = nums[0]+nums[1]+nums[2];
        for (l = 0; l <= len-3; ++l) for (int i=l+1, h=len-1; i <= h-1;) {
            int sum = nums[l] + nums[i] + nums[h];
            result = abs(sum-target) < abs(result-target) ? sum : result;
            if      (sum < target) { for (i++; i<=h-1 && nums[i]==nums[i-1]; i++); }
            else if (sum > target) { for (h--; i<=h-1 && nums[h]==nums[h+1]; h--); }
            else                   { return sum; }
        }
        return result;
    }
};
```

和上面的差不多时间，12ms

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int l = 0, len = nums.size(), result = nums[0]+nums[1]+nums[2];
        while (l <= len-3) { 
            for (int i=l+1, h=len-1; i <= h-1;) {
                int sum = nums[l] + nums[i] + nums[h];
                result = abs(sum-target) < abs(result-target) ? sum : result;
                if      (sum < target) { for (i++; i<=h-1 && nums[i]==nums[i-1]; i++); }
                else if (sum > target) { for (h--; i<=h-1 && nums[h]==nums[h+1]; h--); }
                else                   { return sum; }
            }
            for (l++; l<=len-3 && nums[l]==nums[l-1]; l++);
        }
        return result;
    }
};
```


"
0015 3Sum;"https://leetcode.com/problems/3sum/description/

* algorithms
* Medium (23.48%)
* Total Accepted:    491.5K
* Total Submissions: 2.1M
* Testcase Example:  '[-1,0,1,2,-1,-4]'

Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:


Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]







";"
思路：

1. 先排序.
2. 固定l，调整i和h,加和，大于0则减小h，小于0则增大i，等于0则减小h增大i，注意去重.
3. 迭代第2步，l从0到len-3.

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result; int l=0, len=nums.size();
        while (l <= len-3) {
            for (int i = l+1, h=len-1; i <= h-1;) {
                int sum = nums[l] + nums[i] + nums[h];
                if      (sum > 0) for (h--; i<=h-1&&nums[h]==nums[h+1]; h--);
                else if (sum < 0) for (i++; i<=h-1&&nums[i]==nums[i-1]; i++);
                else if (sum == 0) {
                    result.push_back({nums[l], nums[i], nums[h]});
                    for (i++, h--; i<=h-1&&nums[i]==nums[i-1]; i++);
                } 
            }
            for (l++; l<=len-3&&nums[l-1]==nums[l]; l++);
        }
        return result;
    }
};
```

"
0014 Longest Common Prefix;"https://leetcode.com/problems/longest-common-prefix/description/

* algorithms
* Easy (33.03%)
* Total Accepted:    416.2K
* Total Submissions: 1.3M
* Testcase Example:  '[""flower"",""flow"",""flight""]'

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string """".

Example 1:


Input: [""flower"",""flow"",""flight""]
Output: ""fl""


Example 2:


Input: [""dog"",""racecar"",""car""]
Output: """"
Explanation: There is no common prefix among the input strings.


Note:

All given inputs are in lowercase letters a-z.







";"
```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (strs.empty()) return """";
        if (strs.size() == 1) return strs.front();
        sort(strs.begin(), strs.end());
        string result, &a = strs.front(), &b = strs.back();
        int len = min(a.length(), b.length());
        for (int i = 0; i < len; i++) 
            if (a[i] == b[i]) result.push_back(a[i]); else break;
        return move(result);
    }
};
```

"
0013 Roman to Integer;"https://leetcode.com/problems/roman-to-integer/description/

* algorithms
* Easy (51.61%)
* Total Accepted:    370.9K
* Total Submissions: 718.4K
* Testcase Example:  '""III""'

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.


Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:


	I can be placed before V (5) and X (10) to make 4 and 9. 
	X can be placed before L (50) and C (100) to make 40 and 90. 
	C can be placed before D (500) and M (1000) to make 400 and 900.


Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:


Input: ""III""
Output: 3

Example 2:


Input: ""IV""
Output: 4

Example 3:


Input: ""IX""
Output: 9

Example 4:


Input: ""LVIII""
Output: 58
Explanation: L = 50, V= 5, III = 3.


Example 5:


Input: ""MCMXCIV""
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.






";"
思路1：用trie树，没写完。

```cpp
class Solution {
public:
    struct TrieNode {
        TrieNode *next[26]; int flag;
        TrieNode() { flag = 0; fill_n(next, 26, nullptr); }
        ~TrieNode() { for (auto p : next) if (p) delete p; }
    }
    
    int romanToInt(const string &s) {
        vector<string> I = {""I"", ""II"", ""III"", ""IV"", ""V"", ""VI"", ""VII"", ""VIII"", ""IX""};
        vector<string> X = {""X"", ""XX"", ""XXX"", ""XL"", ""L"", ""LX"", ""LXX"", ""LXXX"", ""XC""};
        vector<string> C = {""C"", ""CC"", ""CCC"", ""CD"", ""D"", ""DC"", ""DCC"", ""DCCC"", ""CM""};
        vector<string> M = {""M"", ""MM"", ""MMM""};
        static TrieNode *root = nullptr;
        if (root == nullptr) {
            root = new TrieNode();
            for (auto &ss : {I, X, C, M}) for (int i = 0; i < ss.length(); ++i) {
                TrieNode *p = root;
                for (char c : s) {
                    if (p->next(s-'A') == nullptr) p->next(s-'A') = new TrieNode();
                    p = p->next(s-'A');
                }
                p->flag = (i-0+1) * 10;
            }
        }
    }
};
```

思路2：从后往前

```cpp
class Solution {
public:
    int romanToInt(const string &s) {
        static unordered_map<char, int> f;
        if (f.size() == 0) 
            f = {{'I',1}, {'V',5}, {'X',10}, {'L',50}, {'C',100}, {'D',500}, {'M',1000}};

        int result = f[s.back()];
        for (int i = s.length()-2; i >= 0; --i) 
            if (f[s[i]] < f[s[i+1]]) result -= f[s[i]];
            else                     result += f[s[i]];
        return result;
    }
};

```

"
0012 Integer to Roman;"https://leetcode.com/problems/integer-to-roman/description/

* algorithms
* Medium (49.84%)
* Total Accepted:    206.5K
* Total Submissions: 414.3K
* Testcase Example:  '3'

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.


Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:


	I can be placed before V (5) and X (10) to make 4 and 9. 
	X can be placed before L (50) and C (100) to make 40 and 90. 
	C can be placed before D (500) and M (1000) to make 400 and 900.


Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:


Input: 3
Output: ""III""

Example 2:


Input: 4
Output: ""IV""

Example 3:


Input: 9
Output: ""IX""

Example 4:


Input: 58
Output: ""LVIII""
Explanation: L = 50, V = 5, III = 3.


Example 5:


Input: 1994
Output: ""MCMXCIV""
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.







";"
```cpp
class Solution {
public:
    string intToRoman(int num) {
        static string I[] = {"""", ""I"", ""II"", ""III"", ""IV"", ""V"", ""VI"", ""VII"", ""VIII"", ""IX""};
        static string X[] = {"""", ""X"", ""XX"", ""XXX"", ""XL"", ""L"", ""LX"", ""LXX"", ""LXXX"", ""XC""};
        static string C[] = {"""", ""C"", ""CC"", ""CCC"", ""CD"", ""D"", ""DC"", ""DCC"", ""DCCC"", ""CM""};
        static string M[] = {"""", ""M"", ""MM"", ""MMM""};
        string result; result.reserve(20);
        result.append(M[num/1000]).append(C[num%1000/100]).append(X[num%100/10]).append(I[num%10]);
        return move(result);
    }
};
```

"
0011 Container With Most Water;"https://leetcode.com/problems/container-with-most-water/description/

* algorithms
* Medium (42.77%)
* Total Accepted:    324.5K
* Total Submissions: 758.2K
* Testcase Example:  '[1,8,6,2,5,4,8,3,7]'

Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and n is at least 2.

 



The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. 

 

Example:


Input: [1,8,6,2,5,4,8,3,7]
Output: 49






";"
思路：

```cpp
class Solution {
public:
    int maxArea(vector<int>& heights) {
        int result = 0;
        int i = 0, j = heights.size()-1;
        while (i < j) {
            int hi = heights[i], hj = heights[j];
            int area = min(hi, hj) * (j-i);
            result = max(area, result);
            if      (hi < hj) i++;
            else if (hi > hj) j--;
            else              i++, j--;
        }
        return result;
    }
};
```

"
0010 Regular Expression Matching;"https://leetcode.com/problems/regular-expression-matching/description/

* algorithms
* Hard (24.99%)
* Total Accepted:    279.4K
* Total Submissions: 1.1M
* Testcase Example:  '""aa""\n""a""'

Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.


'.' Matches any single character.
'*' Matches zero or more of the preceding element.


The matching should cover the entire input string (not partial).

Note:


	s could be empty and contains only lowercase letters a-z.
	p could be empty and contains only lowercase letters a-z, and characters like . or *.


Example 1:


Input:
s = ""aa""
p = ""a""
Output: false
Explanation: ""a"" does not match the entire string ""aa"".


Example 2:


Input:
s = ""aa""
p = ""a*""
Output: true
Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes ""aa"".


Example 3:


Input:
s = ""ab""
p = "".*""
Output: true
Explanation: "".*"" means ""zero or more (*) of any character (.)"".


Example 4:


Input:
s = ""aab""
p = ""c*a*b""
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches ""aab"".


Example 5:


Input:
s = ""mississippi""
p = ""mis*is*p*.""
Output: false








";"
思路：这题状态转换比较繁，我用图简单画了下。
![empty](leanote://file/getImage?fileId=5808e2341b6f9f2c0e000000)

```cpp
class Solution {
public:
    bool isMatch(const string &s, const string &p) {
        const int slen = s.length(), plen = p.length();
        vector<vector<int> > f(slen+1, vector<int>(plen+1, 0));
        f[slen][plen] = 1;
        for (int j=plen-1; j>=1; --j) f[slen][j-1] = p[j] == '*' && f[slen][j+1];
        for (int i=slen-1; i>=0; --i) for (int j=plen-1; j>=0;) {
            if (s[i] == p[j] || p[j] == '.') { 
                f[i][j] = f[i+1][j+1]; j -= 1; 
            } 
            else if (p[j] == '*') {
                if (p[j-1] == '.' || s[i] == p[j-1]) { 
                    f[i][j-1] = f[i][j+1] || f[i+1][j-1] || f[i+1][j+1]; j -= 2; 
                } else if (s[i] != p[j-1]) { 
                    f[i][j-1] = f[i][j+1]; j -= 2; 
                }
            }
            else { j -= 1; }
        }
        return f[0][0];
    }
};
```

"
0009 Palindrome Number;"https://leetcode.com/problems/palindrome-number/description/

* algorithms
* Easy (42.08%)
* Total Accepted:    519.8K
* Total Submissions: 1.2M
* Testcase Example:  '121'

Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:


Input: 121
Output: true


Example 2:


Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.


Example 3:


Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.


Follow up:

Coud you solve it without converting the integer to a string?






";"
思路：前后依次计算对应位置的值，然后前后对比。

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) return false;
        int p=1, q=1;
        while (x / p >= 10) p *= 10;
        while (p >= q) {
            if ((x/p)%10 != (x/q)%10) return false;
            p = p / 10; q = q * 10;
        }
        return true;
    }
};
```


"
0008 String to Integer (atoi);"https://leetcode.com/problems/string-to-integer-atoi/description/

* algorithms
* Medium (14.50%)
* Total Accepted:    331.5K
* Total Submissions: 2.3M
* Testcase Example:  '""42""'

Implement atoi which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

Note:


	Only the space character ' ' is considered as whitespace character.
	Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.


Example 1:


Input: ""42""
Output: 42


Example 2:


Input: ""   -42""
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.


Example 3:


Input: ""4193 with words""
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.


Example 4:


Input: ""words and 987""
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical 
             digit or a +/- sign. Therefore no valid conversion could be performed.

Example 5:


Input: ""-91283472332""
Output: -2147483648
Explanation: The number ""-91283472332"" is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.






";"
思路：细节考察题，注意：空格、符号、溢出问题。

```cpp
class Solution {
public:
    int myAtoi(const string &str) {
        int i=0, sign=1; long long result=0; const int len = str.length();
        // trim spaces.
        while (i<len && str[i]==' ') i++;
        // handle sign.
        if      (i<len && str[i]=='+') i++;
        else if (i<len && str[i]=='-') { sign = -1; i++; }
        // convert.
        while (i<len && result+INT_MIN<=0 && isdigit(str[i])) { 
            result = result*10 + str[i] - '0'; i++; 
        }
        // handle overflow.
        if (sign==+1 && result-INT_MAX>=0) return INT_MAX;
        if (sign==-1 && result+INT_MIN>=0) return INT_MIN;
        // return.
        return (int)result * sign;
    }
};
```

"
0007 Reverse Integer;"https://leetcode.com/problems/reverse-integer/description/

* algorithms
* Easy (25.16%)
* Total Accepted:    621.6K
* Total Submissions: 2.5M
* Testcase Example:  '123'

Given a 32-bit signed integer, reverse digits of an integer.

Example 1:


Input: 123
Output: 321


Example 2:


Input: -123
Output: -321


Example 3:


Input: 120
Output: 21


Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.






";"
细节题，abcd，一次取d c b a，在加到result中去，result\*10 + tmp。要注意符号和溢出的处理，不需要单独处理INT\_MIN，因为INT\_MIN和INT\_MAX的reverse都不存在。

```cpp
class Solution {
public:
    int reverse(int x) {
        bool flag = false; if (x < 0) { flag = true; x = -x; } 
        long long result = 0;
        while (x > 0) {
            int tmp = x % 10; x = x / 10;
            result = result * 10 + tmp;
        }
        if (result > INT_MAX) return 0;
        if (flag) result = -result;
        return result;
    }
};
```


"
0006 ZigZag Conversion;"https://leetcode.com/problems/zigzag-conversion/description/

* algorithms
* Medium (30.76%)
* Total Accepted:    290.5K
* Total Submissions: 944.1K
* Testcase Example:  '""PAYPALISHIRING""\n3'

The string ""PAYPALISHIRING"" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)


P   A   H   N
A P L S I I G
Y   I   R


And then read line by line: ""PAHNAPLSIIGYIR""

Write the code that will take a string and make this conversion given a number of rows:


string convert(string s, int numRows);

Example 1:


Input: s = ""PAYPALISHIRING"", numRows = 3
Output: ""PAHNAPLSIIGYIR""


Example 2:


Input: s = ""PAYPALISHIRING"", numRows = 4
Output: ""PINALSIGYAHRPI""
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I






";"
思路：映射索引到对应的row的位置，然后存储在不同的string中，最后合并起来。

```cpp
class Solution {
public:
    string convert(const string &s, int n) {
        if (n == 1 || n >= s.length()) return s;
        vector<string> buckets(n);
        // map form [0, 1, 2, 3, 4, 5 ...] to [0, 1, 2, 1, 0, 1 ...]
        for (int i=0; i<s.length(); ++i) 
            buckets[n-1-abs(i%(n*2-2)-n+1)].push_back(s[i]);
        string result; result.reserve(s.length());
        for (auto bucket : buckets) result.append(bucket);
        return move(result);
    }
};
```


"
0005 Longest Palindromic Substring;"https://leetcode.com/problems/longest-palindromic-substring/description/

* algorithms
* Medium (26.66%)
* Total Accepted:    488.5K
* Total Submissions: 1.8M
* Testcase Example:  '""babad""'

Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:


Input: ""babad""
Output: ""bab""
Note: ""aba"" is also a valid answer.


Example 2:


Input: ""cbbd""
Output: ""bb""







";"
思路：动态规划，设f[i,j]表示s[i,j]是否是回文字符串，`f[i,j] = s[i]==s[j] && (i>=j-1 || f[i+1,j-1])`。进一步发现f[i,j]依赖f[i+1,j-1]，可以优化为一维表，即`f[i] = s[i]==s[j] && (i>=j-1 || f[i+1])`。

```cpp
class Solution {
public:
    string longestPalindrome(const string& s) {
        const int len = s.length(); int l=0, h=0;
        int f[len] = {0};
        for (int j=0; j<len; ++j) for (int i=0; i<=j; ++i) {
            f[i] = s[i]==s[j] && (i>=j-1 || f[i+1]);
            if (f[i] && (j-i>h-l)) { l=i; h=j; }
        }
        return move(s.substr(l, h-l+1));
    }
};
```


"
0004 Median of Two Sorted Arrays;"https://leetcode.com/problems/median-of-two-sorted-arrays/description/

* algorithms
* Hard (25.60%)
* Total Accepted:    389.9K
* Total Submissions: 1.5M
* Testcase Example:  '[1,3]\n[2]'

There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume nums1 and nums2 cannot be both empty.

Example 1:


nums1 = [1, 3]
nums2 = [2]

The median is 2.0


Example 2:


nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5







";"
思路：转化问题为找到两个有序数组中第k个数的问题。排除法，取两数组中第k/2(必须保证加起来和为k)大小的数字作比较，第k大的数字肯定不在较小的那个k/2序列中。将其下标l提升k/2，转化为在l1和l2起始位置开始找第k-k/2大小的数字。

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int h1 = nums1.size(), h2 = nums2.size();
        if ((h1 + h2) % 2 != 0)
            return  kthNum(nums1, 0, nums2, 0, (h1 + h2)/2+1);
        else 
            return (kthNum(nums1, 0, nums2, 0, (h1 + h2)/2) 
                +   kthNum(nums1, 0, nums2, 0, (h1 + h2)/2+1)) / 2;
    }
    
    double kthNum(vector<int>& nums1, int l1, vector<int>& nums2, int l2, int k) {
        int h1 = nums1.size(), h2 = nums2.size();
        if (h1-l1 < h2-l2) return kthNum(nums2, l2, nums1, l1, k);
        if (h2-l2 <= 0)    return nums1[l1+k-1];
        if (k == 1)        return min(nums1[l1], nums2[l2]);
        int i2 = min(h2, l2+k/2); int i1 = l1+k-(i2-l2);
        if (nums1[i1-1] < nums2[i2-1]) return kthNum(nums1, i1, nums2, l2, k-(i1-l1));
        if (nums1[i1-1] > nums2[i2-1]) return kthNum(nums1, l1, nums2, i2, k-(i2-l2));
        return nums1[i1-1];
    }
};
```


"
0003 Longest Substring Without Repeating Characters;"https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

* algorithms
* Medium (27.98%)
* Total Accepted:    822.8K
* Total Submissions: 2.9M
* Testcase Example:  '""abcabcbb""'

Given a string, find the length of the longest substring without repeating characters.


Example 1:


Input: ""abcabcbb""
Output: 3 
Explanation: The answer is ""abc"", with the length of 3. 



Example 2:


Input: ""bbbbb""
Output: 1
Explanation: The answer is ""b"", with the length of 1.



Example 3:


Input: ""pwwkew""
Output: 3
Explanation: The answer is ""wke"", with the length of 3. 
             Note that the answer must be a substring, ""pwke"" is a subsequence and not a substring.










";"
思路：使用t[256]计数。双指针l和i，i遍历直到有重复字符。计算距离i-l和最大值r。移动l消除重复字符。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string& s) {
        if (s.empty()) return 0;
        int t[256], l=0, r=1, len=s.length();
        fill_n(t, 256, 0); t[s[0]]++;
        for (int i=1; i<len; ++i) {
            if (t[s[i]] == 0) {
                t[s[i]]++;
            } else {
                r = max(r, i-l);
                while (s[l] != s[i]) t[s[l++]]--; 
                l++;
            }
        }
        return max(r, len-l);
    }
};
```


"
0002 Add Two Numbers;"https://leetcode.com/problems/add-two-numbers/description/

* algorithms
* Medium (30.63%)
* Total Accepted:    779.9K
* Total Submissions: 2.5M
* Testcase Example:  '[2,4,3]\n[5,6,4]'

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example:


Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.








";"
思路：细节考察题，见代码。

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int carry = 0; ListNode result(0), *p = &result;
        while (l1 || l2 || carry) {
            if (l1) { carry += l1->val; l1 = l1->next; }
            if (l2) { carry += l2->val; l2 = l2->next; }
            ListNode *n = new ListNode(carry % 10); carry /= 10;
            p->next = n; p = p->next;
        }
        return result.next;
    }
};
```


"
0001 Two Sum;"https://leetcode.com/problems/two-sum/description/

* algorithms
* Easy (42.16%)
* Total Accepted:    1.5M
* Total Submissions: 3.6M
* Testcase Example:  '[2,7,11,15]\n9'

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:


Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].


 






";"
思路1：暴力搜索，586ms

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int i=0, j=i+1, len=nums.size();
        vector<int> result;
        for (int i=0; i<len-1; ++i) for (j=i+1; j<len; j++)
            if (nums[i]+nums[j] == target) { result = {i,j}; break; }
        return move(result);
    }
};
```

思路2：用hash，O(n)，用时13ms,注意如果把下面的unordered_map替换成map会耗时26ms。看来用hashtable实现的unordered_map比红黑树实现的map要快一倍多。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> tbl; vector<int> result;
        for (int i=0; i<nums.size(); ++i) {
            int need = target-nums[i];
            if (tbl.find(need) != tbl.end()) { result = {tbl[need],i}; break;}
            tbl[nums[i]] = i;
        }
        return move(result);
    }
};
```


"
